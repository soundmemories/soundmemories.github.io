<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"soundmemories.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":true,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="泛型的概念无泛型问题举例：下面有四个瓶子，准备用来装“醋”、“酱油”、“黄酒”、“花椒油”，如果瓶子没有标签的话，那么当这些调料一旦装进去之后，我们就容易忘记哪个瓶子里装了什么，每次用的时候，需要“闻”或“尝”等确认一下才能用，否则就容易加错调料。 生产瓶子的厂家不知道我们将来用这个瓶子装什么，因此我们为了后面的“方便”、“安全”，可以在装完调料之后贴“标签”。同理，在前一章的时候，我们使用集合时">
<meta property="og:type" content="article">
<meta property="og:title" content="Java泛型">
<meta property="og:url" content="https://soundmemories.github.io/2020/03/01/Java/26.Java%E6%B3%9B%E5%9E%8B/index.html">
<meta property="og:site_name" content="SoundMemories">
<meta property="og:description" content="泛型的概念无泛型问题举例：下面有四个瓶子，准备用来装“醋”、“酱油”、“黄酒”、“花椒油”，如果瓶子没有标签的话，那么当这些调料一旦装进去之后，我们就容易忘记哪个瓶子里装了什么，每次用的时候，需要“闻”或“尝”等确认一下才能用，否则就容易加错调料。 生产瓶子的厂家不知道我们将来用这个瓶子装什么，因此我们为了后面的“方便”、“安全”，可以在装完调料之后贴“标签”。同理，在前一章的时候，我们使用集合时">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-02-29T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-03T08:46:11.131Z">
<meta property="article:author" content="SoundMemories">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://soundmemories.github.io/2020/03/01/Java/26.Java%E6%B3%9B%E5%9E%8B/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java泛型 | SoundMemories</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SoundMemories</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
	   
		  
      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">泛型的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%B3%9B%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">无泛型问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">1.2.</span> <span class="nav-text">泛型的引入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">泛型类、接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">如何定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8C%87%E5%AE%9A%E6%B3%9B%E5%9E%8B%E5%AE%9E%E5%8F%82"><span class="nav-number">2.2.</span> <span class="nav-text">如何指定泛型实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BB%B6%E7%BB%AD%E4%BD%BF%E7%94%A8%E7%88%B6%E7%B1%BB%E3%80%81%E7%88%B6%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%B3%9B%E5%9E%8B%E5%BD%A2%E5%8F%82"><span class="nav-number">2.3.</span> <span class="nav-text">如何延续使用父类、父接口的泛型形参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%AE%9A%E6%B3%9B%E5%9E%8B%E5%BD%A2%E5%8F%82%E7%9A%84%E4%B8%8A%E9%99%90"><span class="nav-number">2.4.</span> <span class="nav-text">设定泛型形参的上限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">泛型方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">如何声明泛型方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%AE%9A%E6%B3%9B%E5%9E%8B%E5%BD%A2%E5%8F%82%E7%9A%84%E4%B8%8A%E9%99%90-1"><span class="nav-number">3.2.</span> <span class="nav-text">设定泛型形参的上限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">4.</span> <span class="nav-text">类型通配符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%AE%9A%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%B8%8A%E9%99%90"><span class="nav-number">4.1.</span> <span class="nav-text">设定类型通配符的上限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%B8%8B%E9%99%90"><span class="nav-number">4.2.</span> <span class="nav-text">设定通配符的下限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E4%B8%8E%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="nav-number">4.3.</span> <span class="nav-text">泛型方法与方法重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">5.</span> <span class="nav-text">泛型擦除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84Class%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.</span> <span class="nav-text">并不存在泛型类的Class对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Type-%E4%B8%8EType-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.</span> <span class="nav-text">Type\与Type\的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof%E5%90%8E%E9%9D%A2%E4%B8%8D%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">6.2.</span> <span class="nav-text">instanceof后面不支持泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">6.3.</span> <span class="nav-text">泛型与数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="nav-number">6.4.</span> <span class="nav-text">泛型与异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text">Collections工具类</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SoundMemories"
      src="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
  <p class="site-author-name" itemprop="name">SoundMemories</p>
  <div class="site-description" itemprop="description">今日事，今日毕</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">120</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvdW5kbWVtb3JpZXM=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soundmemories"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNvdW5kbWVtb3JpZXNAMTYzLmNvbQ==" title="E-Mail → mailto:soundmemories@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2020/03/01/Java/26.Java%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java泛型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-01T00:00:00+08:00">2020-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><h3 id="无泛型问题"><a href="#无泛型问题" class="headerlink" title="无泛型问题"></a>无泛型问题</h3><p>举例：下面有四个瓶子，准备用来装“醋”、“酱油”、“黄酒”、“花椒油”，如果瓶子没有标签的话，那么当这些调料一旦装进去之后，我们就容易忘记哪个瓶子里装了什么，每次用的时候，需要“闻”或“尝”等确认一下才能用，否则就容易加错调料。</p>
<p>生产瓶子的厂家不知道我们将来用这个瓶子装什么，因此我们为了后面的“方便”、“安全”，可以在装完调料之后贴“标签”。<br>同理，在前一章的时候，我们使用集合时，一旦把一个对象“丢进”Java集合中，集合就会忘记对象的类型，把所有的对象当成Object类型处理。当程序从集合中取出对象后，就需要进行强制类型转换，这种强制类型转换不仅代码臃肿，而且容易引起ClassCastException异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListErr</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//strList集合，本来只想装字符串对象</span></span><br><span class="line">		List strList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		strList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		strList.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		strList.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		<span class="comment">//“不小心”把Integer对象装进去了</span></span><br><span class="line">		strList.add(<span class="number">666</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strList.size(); i++) &#123;</span><br><span class="line">			<span class="comment">//因为strList中是按照Object处理的，所以必须强制类型转换</span></span><br><span class="line">			<span class="comment">//最后一个元素将出现ClassCastException</span></span><br><span class="line">			String str = (String) strList.get(i);</span><br><span class="line">			System.out.println( str + <span class="string">&quot;的长度：&quot;</span> + str.length());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a id="more"></a><br>Java集合之所以被设计成这样，是因为设计集合的程序员不会知道我们需要用它来装什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做也带来了两个问题：<br>（1）集合对元素类型没有任何限制，这样可能引发一些问题：例如只想存储字符串对象，却不小心把Integer对象轻易的放进去，因为编译期间没有类型检查。<br>（2）由于把对象“丢进”集合时，在编译期间，集合就忘记了对象的实际类型，集合只知道它盛装的是Object，因此取出集合元素后，该对象的编译时类型就变成了Object类型（其实际的运行时类型没变），如果要使用还需要强制类型转换。这种强制类型转换既会增加编程的复杂度，也可能引发ClassCastException。</p>
<h3 id="泛型的引入"><a href="#泛型的引入" class="headerlink" title="泛型的引入"></a>泛型的引入</h3><p>如何解决呢？生活的智慧往往可以启迪我们，我们可以给集合“贴标签”。<br>那么如何实现“贴标签”呢？<br>回忆一下：我们要实现求两个整数的最大值，如何设计方法的？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max = max(<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">	System.out.println(max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我们设计了两个形参a,b，因为我们无法确定“两个整数”的值，我们就用形参a,b来代替未知的整数的值来完成该方法的实现。当调用方法时，再确定a,b的实际值，我们称为实参，例如3,6就是给a,b赋值的实参。</p>
<p>同样的JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了“类型形参”，这个类型形参将在声明变量、创建对象时确定，即传入实际的类型称为“类型实参”。我们把这个“参数化的类型”称为泛型（Generic）。格式：<code>&lt;类型&gt;</code>，如<code>&lt;String&gt;</code>，<code>&lt;Integer&gt;</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// strList集合，本来只想装字符串对象</span></span><br><span class="line">		ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		strList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		strList.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		strList.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">		<span class="comment">// 编译器将阻止我们把Integer对象装进去</span></span><br><span class="line">		strList.add(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strList.size(); i++) &#123;</span><br><span class="line">			<span class="comment">// 因为strList中都是String，所以不需要强制类型转换</span></span><br><span class="line">			String str = strList.get(i);</span><br><span class="line">			System.out.println(str + <span class="string">&quot;的长度：&quot;</span> + str.length());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>未用泛型时：<br>（1）任何类型都可以添加到集合中，类型不安全。<br>（2）读取出来的对象需要强转，可能有ClassCastException，繁琐。<br>使用泛型时（好处）：<br>（1）只有指定类型才可以添加到集合中，类型安全。<br>（2）读取出来的对象不需要强转，便捷。</p>
<p>泛型的使用形式有2种：<br>（1）泛型类、接口。<br>（2）泛型方法。</p>
<h2 id="泛型类、接口"><a href="#泛型类、接口" class="headerlink" title="泛型类、接口"></a>泛型类、接口</h2><p>下面是JDK1.5改写后ArrayList接口、Iterator接口、Map的代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//.....省略</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//....省略</span></span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//....省略</span></span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">	<span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">	<span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从上面的代码中，我们可以看出可以在定义接口、类时指定类型形参，例如：E，K，V。当我们使用这些集合时，就可以为E，K，V指定具体的类型实参。</p>
<h3 id="如何定义"><a href="#如何定义" class="headerlink" title="如何定义"></a>如何定义</h3><p>可以为任何类和接口增加泛型声明，并不是只有集合类才可以使用泛型声明。<br>泛型形参的命名一般使用单个的大写字母，如果有多个类型形参，那么使用逗号分隔，例如：Map\<K,V\>。<br>常见字母（见名知意）：<br>（1）T：Type<br>（2）K，V：Key，Value<br>（3）E：Element<br>这些T，K，V，E等代表的是某种元素的类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义学生类，其中的学生成绩是（1）整数（2）小数（3）字符串 类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student&lt;Integer&gt; s1 = <span class="keyword">new</span> Student&lt;Integer&gt;(<span class="string">&quot;张三&quot;</span>,<span class="number">95</span>);</span><br><span class="line">		Student&lt;String&gt; s2 = <span class="keyword">new</span> Student&lt;String&gt;(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">		Student&lt;Double&gt; s3 = <span class="keyword">new</span> Student&lt;Double&gt;(<span class="string">&quot;张三&quot;</span>,<span class="number">80.5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> T score;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, T score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(T score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;, 成绩：&quot;</span> + score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从上面的代码中，我们可以看出可以在定义接口、类时指定类型形参，类型形参在整个接口或类体中可以当成类型使用，几乎所有可使用其他普通类型的地方都可以使用这种类型形参，例如：属性类型、方法的形参类型、方法返回值类型等。</p>
<p><strong>但是泛型类或泛型接口上的泛型形参，不能用于声明静态变量，也不能用在静态方法中</strong>，那是因为静态成员的初始化是随着类的初始化而初始化的，此时泛型实参无法指定，那么泛型形参的类型就不确定。所以请不要在静态成员上使用类或接口上的泛型形参。</p>
<p id="div-border-left-blue">
当创建带泛型声明的类时，为该类定义构造器时，构造器名还是原来的类名，不需要增加泛型声明。例如：Student<T>类定义的构造器依然是Student()，而不是Student<T>，但调用构造器时缺可以使用Student<T>的形式，而且应该为T类型形参传入实际的类型实参。<br>
</p>

<h3 id="如何指定泛型实参"><a href="#如何指定泛型实参" class="headerlink" title="如何指定泛型实参"></a>如何指定泛型实参</h3><p><strong>1、泛型实参的要求：</strong><br>首先泛型实参必须是引用数据类型，不能是基本数据类型，因为集合中只能存储对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下指定为int是错误的</span></span><br><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须是引用数据类型，因此可以指定为包装类型</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><br><strong>2、什么时候指定泛型实参？</strong><br>（1）在使用 泛型类、接口 声明变量时。<br>（2）在创建泛型类对象时。<br>（3）在继承泛型类或实现泛型接口时，如果子类不延续使用该泛型，那么必须明确指定实际类型。此时子类不再是泛型类了。<br><div class="tabs" id="泛型实参"><ul class="nav-tabs"><li class="tab active"><a href="#泛型实参-1">声明/创建对象</a></li><li class="tab"><a href="#泛型实参-2">继承/实现接口</a></li></ul><div class="tab-content"><div class="tab-pane active" id="泛型实参-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.7之前（=号左边声明，右边创建对象）</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//JDK1.7之后支持如下简化写法</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习：组长姓名作为key，多个组员姓名用ArrayList装起来作为value，放到HashMap中</span></span><br><span class="line">HashMap&lt;String, ArrayList&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt;();</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="泛型实参-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承泛型类</span></span><br><span class="line"><span class="comment">//此处ArrayList&lt;String&gt;就不能写成ArrayList&lt;E&gt;</span></span><br><span class="line"><span class="comment">//因为MyArrayList不再是泛型类了，因此E必须给出具体的类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现泛型接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div></p>
<h3 id="如何延续使用父类、父接口的泛型形参"><a href="#如何延续使用父类、父接口的泛型形参" class="headerlink" title="如何延续使用父类、父接口的泛型形参"></a>如何延续使用父类、父接口的泛型形参</h3><p>如果继承泛型类、实现泛型接口时，想要继续保留父类、父接口的泛型，必须在父类、父接口和子类、子接口中都要保留泛型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SubArrayList&lt;E&gt;和ArrayList&lt;E&gt;保持一样的泛型字母即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//在子类中泛型形参还是E</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SubArrayList&lt;T&gt;和ArrayList&lt;T&gt;保持一样的泛型字母即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//在子类中泛型形参是T，父类中使用泛型形参的位置也自动修改为T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>集合中大量是这种情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//....省略了代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//....省略了代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//....省略了代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="comment">//...省略了代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="设定泛型形参的上限"><a href="#设定泛型形参的上限" class="headerlink" title="设定泛型形参的上限"></a>设定泛型形参的上限</h3><p>如果泛型形参没有设定上限，那么泛型实参可以是任意引用数据类型。如果泛型形参设定了上限（例如：<code>T extends 父类上限</code>），那么只能指定为该父类本身或其各子类类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义学生类，其中的学生成绩可以是如下数字类型：Integer、Float、Double...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;<span class="comment">//T限定是Number</span></span><br><span class="line">	<span class="comment">//...省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在一种更极端的情况下，程序需要为形参设定多个上限（至多有一个父类上限，可以有多个接口上限）表明该类型形参必须是其父类的子类（包括是父类本身也行），并且实现多个上限接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//...省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>与类同时继承父类、实现接口类似的是：为类型形参指定多个上限时，所有的接口上限必须位于类上限之后。也就是说，如果需要为类型形参指定类上限，类上限必须位于第一位。</p>
<p>思考：如果在使用泛型类或泛型接口的时候，没有指定泛型实参，会怎么样？<br>泛型被擦除，擦除后泛型形参被解析为其第一个上限的类型。如果没有指定泛型形参的上限，就按照Object处理。</p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>前面介绍了在定义类、接口时可以使用类型形参，在该类的方法和属性定义、接口的方法定义中，这些类型形参可被当成普通类型来用。<br>但是，在另外一些情况下：<br>（1）如果定义类、接口时定义的形参不合适，或没有使用类型形参，在某个方法（静态/非静态）定义时，可单独设计；<br>（2）类和接口上的类型形参是不能用于静态方法中，当某个静态方法想要使用类型形参时，可单独设计。</p>
<h3 id="如何声明泛型方法"><a href="#如何声明泛型方法" class="headerlink" title="如何声明泛型方法"></a>如何声明泛型方法</h3><p>例如：假设需要实现这样的一个方法，该方法负责将一个数组的所有元素添加到一个Collection集合中，考虑采用如下代码来实现该方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericMethod</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String[] array = &#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line">		Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="comment">//编译报错，因为Collection&lt;Object&gt;形参不接收Collection&lt;String&gt;实参，因为它俩不是父子类关系</span></span><br><span class="line">		fromArrayToCollection(array,coll);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(Object[] a,Collection&lt;Object&gt; c)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Object object : a) &#123;</span><br><span class="line">			c.add(object);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了解决这个问题，可以使用泛型方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(T[] a,Collection&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (T object : a) &#123;</span><br><span class="line">		c.add(object);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>把上面的方法格式与普通方法的格式进行对比，不难发现泛型方法的方法签名比普通的多了类型形参声明，类型形参声明以尖括号括起来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】  &lt;泛型形参列表&gt;  返回类型  方法名(【形参列表】)  抛出的异常列表&#123;</span><br><span class="line">	<span class="comment">//方法体...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（1）其中泛型形参列表，可以是一个或多个，如果多个，使用逗号分隔，和定义泛型类、接口时一样。而且&lt;泛型形参列表&gt;必须在修饰符和返回值类型之间。<br>（2）与接口、类声明中定义的泛型形参不同，方法声明中定义的泛型形参只能在当前方法中使用，和其他方法无关。<br>（3）与接口、类声明中定义的泛型形参不同，方法声明中定义的泛型形参无需显式传入实际类型参数，编译器可以根据实参类型直接推断形参的实际类型。</p>
<h3 id="设定泛型形参的上限-1"><a href="#设定泛型形参的上限-1" class="headerlink" title="设定泛型形参的上限"></a>设定泛型形参的上限</h3><p>例如，我们有几个图形类，我们想定义一个方法，可以求多个图形的面积：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGraphic</span> </span>&#123;</span><br><span class="line">	<span class="comment">//想定义一个方法，可以求多个图形的面积</span></span><br><span class="line">	<span class="comment">//其实没有设定泛型形参上限的，可以看成它的上限默认是Object</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Graphic&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArea</span><span class="params">(List&lt;T&gt; graphics)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (T t : graphics) &#123;</span><br><span class="line">			System.out.println(t.getArea());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Circle&gt; cList = <span class="keyword">new</span> ArrayList&lt;Circle&gt;();</span><br><span class="line">		cList.add(<span class="keyword">new</span> Circle(<span class="number">1.2</span>));</span><br><span class="line">		cList.add(<span class="keyword">new</span> Circle(<span class="number">2.3</span>));</span><br><span class="line">		printArea(cList);</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;Rectangle&gt; rList = <span class="keyword">new</span> ArrayList&lt;Rectangle&gt;();</span><br><span class="line">		rList.add(<span class="keyword">new</span> Rectangle(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">		rList.add(<span class="keyword">new</span> Rectangle(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">		printArea(rList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Graphic</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> length;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> length, <span class="keyword">double</span> width)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.length = length;</span><br><span class="line">		<span class="keyword">this</span>.width = width;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> length * width;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Graphic</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Graphic</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2><p>当我们声明一个方法时，某个形参的类型是一个泛型类或泛型接口类型，但是在声明方法时，又不确定该泛型实际类型，我们可以考虑使用类型通配符。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List c)</span></span>&#123;<span class="comment">//List报警告</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">		System.out.println(c.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的程序当然没问题，但是此处使用List接口时没有传入实际类型参数，这将引起泛型警告。如何消除这个警告呢？<br>方式一：传入泛型实参<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(List&lt;Object&gt; c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">		System.out.println(c.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是这样的形参太局限了，只能传入List<Object>类型的实参。<br>方式二：声明一个泛型方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(List&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">		System.out.println(c.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>需要声明泛型形参T。<br>方式三：使用类型通配符<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(List&lt;?&gt; c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.size(); i++) &#123;</span><br><span class="line">		System.out.println(c.get(i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么方式二的泛型方法test2()和方式三的test3()使用类型通配符有什么区别呢？<br>test3方法带通配符的List仅表示它可以接受指定了任意泛型实参的List，并不能把元素加入其中，例如如下代码将会引起编译错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;?&gt; c, String str)</span></span>&#123;</span><br><span class="line">	<span class="comment">//c.add(str);//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为我们不知道上面程序中c集合里元素的类型，所以不能向其中添加对象，除了null对象，因为它是所有引用数据类型的实例。<br>test2方法带泛型的List，表示该集合的元素类型是T，因此允许T系列的对象加入其中，例如如下代码是可行的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;T&gt; c, T t)</span></span>&#123;</span><br><span class="line">	c.add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>即如果不涉及添加元素到带泛型的集合中，那么两种方式都可以，如果涉及到添加元素到带泛型的集合中，使用类型通配符&lt;?&gt;的不支持。</p>
<h3 id="设定类型通配符的上限"><a href="#设定类型通配符的上限" class="headerlink" title="设定类型通配符的上限"></a>设定类型通配符的上限</h3><p>当直接使用List&lt;?&gt;这种形式时，即表明这个List集合接收泛型实参指定为<strong>任意类型</strong>的List。但有时候我们只希望接收<strong>部分类型</strong>的List。<br>例如：一个图形的抽象父类Graphic，两个子类Circle和Rectangle，代码见上节，接下来我们想定义一个方法，可以打印不同图形的面积。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGraphic</span> </span>&#123;</span><br><span class="line">	<span class="comment">//想定义一个方法，可以求多个图形的面积</span></span><br><span class="line">	<span class="comment">//其实没有设定泛型形参上限的，可以看成它的上限默认是Object</span></span><br><span class="line"><span class="comment">/*	public static &lt;T extends Graphic&gt; void printArea(List&lt;T&gt; graphics)&#123;</span></span><br><span class="line"><span class="comment">		for (T t : graphics) &#123;</span></span><br><span class="line"><span class="comment">			System.out.println(t.getArea());</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用通配符，可计算两个子类面积</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArea</span><span class="params">(List&lt;?&gt; graphics)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Object obj : graphics) &#123;</span><br><span class="line">			Graphic g = (Graphic) obj;</span><br><span class="line">			System.out.println(g.getArea());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是这样有两个问题，一个是List&lt;?&gt;可以接收任意类型，不仅仅图形，第二个是需要强制类型转换。为了解决这个问题，Java允许设定通配符的上限：<code>&lt;? extends Type&gt;</code>，这个通配符表示它必须是Type本身，或是Type的子类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArea</span><span class="params">(List&lt;? extends Graphic&gt; graphics)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Graphic g : graphics) &#123;</span><br><span class="line">		System.out.println(g.getArea());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>与前面的完全相同，因为我们不知道这个受限制的通配符的具体类型，所以我们不能把Graphic对象或其子类对象加入这个泛型集合中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArea</span><span class="params">(List&lt;? extends Graphic&gt; graphics)</span></span>&#123;</span><br><span class="line">	graphics.add(<span class="keyword">new</span> Circle());<span class="comment">//编译错误，因为不知道？的具体类型，也可能是Rectangle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果要需要将Graphic对象或其子类对象加入这个泛型集合，那么就只能用方式二：泛型方法了。</p>
<h3 id="设定通配符的下限"><a href="#设定通配符的下限" class="headerlink" title="设定通配符的下限"></a>设定通配符的下限</h3><p>假设自己实现一个工具方法：实现将src集合里元素复制到dest集合中的功能，因为dest集合需要接受src的所有元素，所以dest集合元素的类型应该是src集合元素的父类。为了表示两个参数之间的类型依赖，考虑同时使用通配符、泛型形参类实现该方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(Collection&lt;T&gt; dest,Collection&lt;? extends T&gt; src)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (T t : src) &#123;</span><br><span class="line">		dest.add(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的方法实现了前面的功能。现在假设该方法需要一个返回值，返回最后一个被复制的元素，可以把上面方法修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Collection&lt;T&gt; dest,Collection&lt;? extends T&gt; src)</span></span>&#123;</span><br><span class="line">	T last = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (T t : src) &#123;</span><br><span class="line">		dest.add(t);</span><br><span class="line">		last = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>表面上看这个实现没有问题，实际上有一个问题，当遍历src元素的类型是不确定（但可以肯定是T的子类），程序只能用T来笼统的表示，所以返回值类型是T。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	ArrayList&lt;String&gt; src = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	src.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	src.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	ArrayList&lt;Object&gt; dest = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">	<span class="comment">//返回的是Object类型！</span></span><br><span class="line">	Object last = copy(dest, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>发现返回的T是Object，也就是说，程序在复制集合元素的过程中，丢失了src集合元素的类型String。</p>
<p>对于上面的copy方法，可以这样理解两个集合参数之间的依赖关系：不管src集合元素的类型是什么，只要dest集合元素类型与src的元素类相同或是它的父类即可。为了表示这种约束关系，Java允许设定通配符的下限：<code>&lt;? super Type&gt;</code>，这个通配符表示它必须是Type本身或是Type的父类。<strong>所以使用通配符时设定上下限时，通过先确定已知变量（src），达到限定未知变量（dest）的目的。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Collection&lt;? <span class="keyword">super</span> T&gt; dest,Collection&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">	T last = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">for</span> (T t : src) &#123;</span><br><span class="line">		dest.add(t);</span><br><span class="line">		last = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p id="div-border-left-blue">
注意：只有类型通配符才可以设定下限，泛型形参是不能设定下限的。<br>
</p>

<h3 id="泛型方法与方法重载"><a href="#泛型方法与方法重载" class="headerlink" title="泛型方法与方法重载"></a>泛型方法与方法重载</h3><p>因为泛型既允许设定通配符的上限，也允许设定通配符的下限，如果在一个类里包含这样两个方法定义，会报错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Collection&lt;? <span class="keyword">super</span> T&gt; dest,Collection&lt;T&gt; src)</span></span>&#123;</span><br><span class="line">	<span class="comment">//....省略代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">copy</span><span class="params">(Collection&lt;T&gt; dest,Collection&lt;? extends T&gt; src)</span></span>&#123;</span><br><span class="line">	<span class="comment">//....省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><p>在严格的泛型代码里，带泛型声明的类总应该带着类型参数。但为了与老的Java代码保持一致，也允许在使用带泛型声明的类时不指定类型参数。如果没有为这个泛型类指定类型参数，则该类型参数被称作一个原始类型（raw type），默认是该类型形参的第一个上限（如果没有上限，默认就是Object）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestErase</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//ArrayList&lt;String&gt;被转换为了ArrayList</span></span><br><span class="line">		ArrayList list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		<span class="comment">//泛型被擦除，按照默认上限Object处理</span></span><br><span class="line">		Object object = list.get(<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		Student s = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>,<span class="number">12</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//泛型被擦除，按照第一个上限Number处理</span></span><br><span class="line">		Number score = s.getScore();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> T score;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, T score)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.score = score;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="并不存在泛型类的Class对象"><a href="#并不存在泛型类的Class对象" class="headerlink" title="并不存在泛型类的Class对象"></a>并不存在泛型类的Class对象</h2><h3 id="Type-与Type-的区别"><a href="#Type-与Type-的区别" class="headerlink" title="Type\与Type\的区别?"></a>Type\<String\>与Type\<Integer\>的区别?</h3><p>我们通过泛型使得一个类型的功能增强了，好像扩展出好多子类一样。例如：<code>ArrayList&lt;E&gt;</code>，通过指定泛型，可以延伸出<code>ArrayList&lt;String&gt;</code>只能处理字符串类型的集合，<code>ArrayList&lt;Employee&gt;</code>只能处理Employee员工类型的集合。但是，实际上，系统并没有为<code>ArrayList&lt;String&gt;</code>等生成新的class文件，而且也不会把<code>ArrayList&lt;String&gt;</code>当成新的类型处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">System.out.println(list1.getClass());<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(list2.getClass());<span class="comment">//class java.util.ArrayList</span></span><br><span class="line">System.out.println(list1.getClass() == list2.getClass()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><br>可见<code>ArrayList&lt;String&gt;</code>不是<code>ArrayList&lt;Object&gt;</code>的子类，因为他们的运行时类型都是ArrayList，因此不允许如下赋值操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();   <span class="comment">//错误的</span></span><br></pre></td></tr></table></figure><br>这点和数组不同，因为数组是要生成新的Class对象的，String[]仍然是Object[]的子类，因此允许如下赋值操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><br>但是数组这么处理也是有风险的，如下操作编译正确，但运行时会报ArrayStoreException，所以请谨慎这样操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] arr = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;<span class="comment">//因为12不是字符串对象</span></span><br></pre></td></tr></table></figure></p>
<h3 id="instanceof后面不支持泛型类"><a href="#instanceof后面不支持泛型类" class="headerlink" title="instanceof后面不支持泛型类"></a>instanceof后面不支持泛型类</h3><p>由于系统中并不会真正生成泛型类，所以如下操作也都是不允许的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//编译错误，instanceof后面不能使用泛型类</span></span><br><span class="line"><span class="keyword">if</span>(list <span class="keyword">instanceof</span> ArrayList&lt;String&gt;)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="泛型与数组"><a href="#泛型与数组" class="headerlink" title="泛型与数组"></a>泛型与数组</h3><p>数组的元素类型不能包含类型变量或类型形参，除非是无上限的类型通配符：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List&lt;?&gt;[] arr = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">2</span>];</span><br><span class="line">	arr[<span class="number">0</span>] = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;java&quot;</span>);</span><br><span class="line">	arr[<span class="number">1</span>] = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">	<span class="comment">//遍历</span></span><br><span class="line">	<span class="keyword">for</span> (List&lt;?&gt; list : arr) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">			System.out.println(object);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不能创建下面这样的数组对象，以下代码编译错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt;[] array = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">5</span>]; <span class="comment">//编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> T[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.arr = <span class="keyword">new</span> T[length]; <span class="comment">//编译错误</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="泛型与异常"><a href="#泛型与异常" class="headerlink" title="泛型与异常"></a>泛型与异常</h3><p>不能在try-catch中使用类型变量，也不能在throws 后面使用类型变量，以下代码编译错误：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(T t)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>参考操作数组的工具类：Arrays。<br>Collections 是一个操作 Set、List 和 Map 等集合的工具类。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法：<br>（1）<code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c,T... elements)</code>将所有指定元素添加到指定 collection 中。<br>（2）<code>public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)</code>在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。<br>（3）<code>public static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? super T&gt; c)</code>在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。<br>（4）<code>public static void reverse(List&lt;?&gt; list)</code>反转指定列表List中元素的顺序。<br>（5）<code>public static void shuffle(List&lt;?&gt; list)</code> List 集合元素进行随机排序，类似洗牌。<br>（6）<code>public static int frequency(Collection&lt;?&gt; c,Object o)</code>返回指定集合中指定元素的出现次数。<br>（7）<code>public static &lt;T&gt; void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)</code>将src中的内容复制到dest中。<br>（8）<code>public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list，T oldVal，T newVal)</code>：使用新值替换 List 对象的所有旧值。<br>（9）<code>public static void swap(List&lt;?&gt; list,int i,int j)</code>将指定 list 集合中的 i 处元素和 j 处元素进行交换。<br>（10）<code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>根据元素的自然顺序对指定 List 集合元素按升序排序。<br>（11）<code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; c)</code>根据指定的 Comparator 产生的顺序对 List 集合元素进行排序。<br>（12）<code>public static &lt;T&gt; T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)</code>在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者。<br>（13）<code>public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</code>在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序。<br>（14）Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，把一个线程不安全的集合变成一个线程安全的集合。<br>（15）Collections类中提供了多个unmodifiableXxx()方法，把集合变成一个不可修改的集合，只读的集合。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\01\20\Java\01.Java语言简介和环境搭建\" rel="bookmark">Java语言简介和环境搭建</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\01\22\Java\03.Java标识符和变量\" rel="bookmark">Java标识符和变量</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\01\21\Java\02.第一个Java程序\" rel="bookmark">第一个Java程序</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\01\23\Java\04.Java数据类型、进制和补码\" rel="bookmark">Java数据类型、进制和补码</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\01\24\Java\05.Java类型转换\" rel="bookmark">Java类型转换</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>SoundMemories
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://soundmemories.github.io/2020/03/01/Java/26.Java%E6%B3%9B%E5%9E%8B/" title="Java泛型">https://soundmemories.github.io/2020/03/01/Java/26.Java泛型/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/02/27/Java/25.Java%E9%9B%86%E5%90%88/" rel="prev" title="Java集合">
                  <i class="fa fa-chevron-left"></i> Java集合
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/03/04/Java/27.JavaIO%E6%B5%81/" rel="next" title="JavaIO流">
                  JavaIO流 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SoundMemories</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>








<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  








    <div class="pjax">
  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://soundmemories.github.io/2020/03/01/Java/26.Java%E6%B3%9B%E5%9E%8B/',]
      });
      });
  </script>

    </div>
</body>
</html>
