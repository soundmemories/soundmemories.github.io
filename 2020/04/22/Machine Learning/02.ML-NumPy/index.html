<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"soundmemories.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":true,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="Python数据的存储和操作要实现高效的数据驱动的科学和计算，需要理解数据是如何被存储和操作的。Python 语言中数据数组是如何被处理的，并对比 NumPy 所做的改进。这也是理解其他数据科学工具的数据处理的基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="ML-NumPy">
<meta property="og:url" content="https://soundmemories.github.io/2020/04/22/Machine%20Learning/02.ML-NumPy/index.html">
<meta property="og:site_name" content="SoundMemories">
<meta property="og:description" content="Python数据的存储和操作要实现高效的数据驱动的科学和计算，需要理解数据是如何被存储和操作的。Python 语言中数据数组是如何被处理的，并对比 NumPy 所做的改进。这也是理解其他数据科学工具的数据处理的基础。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/05/06/OHdiXwJb9Ev7jKR.jpg">
<meta property="og:image" content="https://i.loli.net/2021/05/06/uN5AyJ1g9GIdkVv.jpg">
<meta property="og:image" content="https://i.loli.net/2021/05/06/FUYlmujL684MbkN.jpg">
<meta property="article:published_time" content="2020-04-21T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-12T15:02:22.385Z">
<meta property="article:author" content="SoundMemories">
<meta property="article:tag" content="Machine Learning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/05/06/OHdiXwJb9Ev7jKR.jpg">


<link rel="canonical" href="https://soundmemories.github.io/2020/04/22/Machine%20Learning/02.ML-NumPy/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ML-NumPy | SoundMemories</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SoundMemories</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
	   
		  
      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Python%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">Python数据的存储和操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">Python中的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E5%88%97%E8%A1%A8%E4%B8%8D%E6%98%AF%E2%80%9C%E5%88%97%E8%A1%A8%E2%80%9D"><span class="nav-number">1.2.</span> <span class="nav-text">Python列表不是“列表”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E4%B8%AD%E7%9A%84%E5%9B%BA%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.</span> <span class="nav-text">Python中的固定类型数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NumPy%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">NumPy概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NumPy%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">NumPy数组基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">特殊量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96"><span class="nav-number">3.3.</span> <span class="nav-text">结构化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-number">3.4.</span> <span class="nav-text">创建数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">3.5.</span> <span class="nav-text">数组的属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">3.6.</span> <span class="nav-text">数组的索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87"><span class="nav-number">3.7.</span> <span class="nav-text">数组的切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%BD%A2"><span class="nav-number">3.8.</span> <span class="nav-text">数组的变形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E5%88%86%E8%A3%82"><span class="nav-number">3.9.</span> <span class="nav-text">数组拼接和分裂</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NumPy%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">NumPy通用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E7%BC%93%E6%85%A2%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="nav-number">4.1.</span> <span class="nav-text">Python缓慢的循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">通用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD"><span class="nav-number">4.3.</span> <span class="nav-text">广播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%BF%90%E7%AE%97"><span class="nav-number">4.4.</span> <span class="nav-text">数组的运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="nav-number">4.4.1.</span> <span class="nav-text">数学运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97"><span class="nav-number">4.4.2.</span> <span class="nav-text">比较运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="nav-number">4.4.3.</span> <span class="nav-text">逻辑运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">4.4.4.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">4.4.5.</span> <span class="nav-text">自定义通用函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.4.6.</span> <span class="nav-text">通用函数的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E8%BF%90%E7%AE%97"><span class="nav-number">4.5.</span> <span class="nav-text">统计运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%9F%E8%AE%A1-%E5%9D%87%E5%80%BC%E6%96%B9%E5%B7%AE"><span class="nav-number">4.5.1.</span> <span class="nav-text">顺序统计&#x2F;均值方差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0"><span class="nav-number">4.5.2.</span> <span class="nav-text">相关系数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">4.5.3.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="nav-number">4.5.4.</span> <span class="nav-text">直方图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.5.</span> <span class="nav-text">分段函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E7%A7%AF%E3%80%81%E5%A4%96%E7%A7%AF%E3%80%81%E5%BC%A0%E9%87%8F%E7%A7%AF"><span class="nav-number">4.5.6.</span> <span class="nav-text">内积、外积、张量积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="nav-number">4.5.7.</span> <span class="nav-text">线性代数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8C%83%E6%95%B0"><span class="nav-number">4.5.8.</span> <span class="nav-text">范数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Numpy%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">Numpy随机函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="nav-number">5.2.</span> <span class="nav-text">排列组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">概率分布函数</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SoundMemories"
      src="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
  <p class="site-author-name" itemprop="name">SoundMemories</p>
  <div class="site-description" itemprop="description">今日事，今日毕</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvdW5kbWVtb3JpZXM=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soundmemories"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNvdW5kbWVtb3JpZXNAMTYzLmNvbQ==" title="E-Mail → mailto:soundmemories@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2020/04/22/Machine%20Learning/02.ML-NumPy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ML-NumPy
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-04-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-22T00:00:00+08:00">2020-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Machine-Learning/" itemprop="url" rel="index"><span itemprop="name">Machine Learning</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>46k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>42 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="Python数据的存储和操作"><a href="#Python数据的存储和操作" class="headerlink" title="Python数据的存储和操作"></a>Python数据的存储和操作</h2><p>要实现高效的数据驱动的科学和计算，需要理解数据是如何被存储和操作的。Python 语言中数据数组是如何被处理的，并对比 NumPy 所做的改进。这也是理解其他数据科学工具的数据处理的基础。<br><a id="more"></a></p>
<h3 id="Python中的数据类型"><a href="#Python中的数据类型" class="headerlink" title="Python中的数据类型"></a>Python中的数据类型</h3><p>Python 的用户往往被其易用性所吸引，其中一个易用之处就在于动态输入。静态类型的语言（如 C 或 Java）往往需要每一个变量都明确地声明，而动态类型的语言（例如 Python）可以跳过这个特殊规定。例如在 C 语言和 Python 语言中做一个累加操作：<br><div class="tabs" id="c"><ul class="nav-tabs"><li class="tab active"><a href="#c-1">C</a></li><li class="tab"><a href="#c-2">Python</a></li></ul><div class="tab-content"><div class="tab-pane active" id="c-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">    result += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="c-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    result += i</span><br></pre></td></tr></table></figure></div></div></div><br>这里最大的不同之处：在 C 语言中，每个变量的数据类型被明确地声明；而在 Python中，类型是动态推断的。这意味着，在 Python 语言中可以将任何类型的数据指定给任何变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">x = <span class="string">&quot;hello“</span></span><br></pre></td></tr></table></figure><br>而在 C 语言中将会导致编译错误或其他未知的后果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">x = <span class="string">&quot;hello&quot;</span>; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><br>这种灵活性是使 Python 和其他动态类型的语言更易用的原因之一。但是这种类型灵活性也有代价，Python 变量中存储的不仅是它们的值，还包括了关于值的类型的一些额外信息。</p>
<p>标准的 Python 实现是用 C 语言编写的。当用 Python 定义一个整型变量时，它并不是一个“原生”整型，而是一个指针，指向一个 C 语言的复合结构体。这意味着每一个 Python 对象都是一个聪明的伪 C 语言结构体，该结构体不仅包含其值，还有其他信息，查看 Python 的源代码，可以发现整型（长整型）的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> ob_refcnt;</span><br><span class="line">    PyTypeObject *ob_type;</span><br><span class="line">    <span class="keyword">size_t</span> ob_size;</span><br><span class="line">    <span class="keyword">long</span> ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>Python 中的一个整型实际上包括 4 个部分：<br>（1）ob_refcnt：是一个引用计数，它帮助 Python 默默地处理内存的分配和回收。<br>（2）ob_type：将变量的类型编码。<br>（3）ob_size：指定接下来的数据成员的大小。<br>（4）ob_digit：包含我们希望 Python 变量表示的实际整型值。</p>
<p>由于 Python 的整型结构体里面包含了这些大量额外的信息，所以 Python 可以自由、动态地编码。但是，Python 类型中的这些额外信息也会成为负担，在多个对象组合的结构体中尤其明显。</p>
<h3 id="Python列表不是“列表”"><a href="#Python列表不是“列表”" class="headerlink" title="Python列表不是“列表”"></a>Python列表不是“列表”</h3><p>如果使用一个包含很多 Python 对象的 Python 数据结构（比如 列表），会发生什么？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]: L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">Out[<span class="number">1</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">In[<span class="number">2</span>]: <span class="built_in">type</span>(L[<span class="number">0</span>])</span><br><span class="line">Out[<span class="number">2</span>]: <span class="built_in">int</span></span><br></pre></td></tr></table></figure><br>因为 Python 的动态类型特性，甚至可以创建一个异构的列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">3</span>]: L = [<span class="literal">True</span>, <span class="string">&quot;2&quot;</span>, <span class="number">3.0</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In[<span class="number">4</span>]: [<span class="built_in">type</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> L]</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="built_in">bool</span>, <span class="built_in">str</span>, <span class="built_in">float</span>, <span class="built_in">int</span>]</span><br></pre></td></tr></table></figure><br>由前述可知，列表中的每一项都是一个完整的 Python 对象，即列表中的每一项必须包含各自的类型信息、引用计数和其他信息。<br>如果列表中的所有变量都是同一类型的，那么很多信息都会显得多余：将数据存储在固定类型的数组中应该会更高效。这就是动态类型的列表和固定类型的（NumPy 式）数组间的区别。</p>
<h3 id="Python中的固定类型数组"><a href="#Python中的固定类型数组" class="headerlink" title="Python中的固定类型数组"></a>Python中的固定类型数组</h3><p>Python 提供了几种将数据存储在有效的、固定类型的数据缓存中的选项。内置的数组（array）模块（在 Python 3.3 之后可用）可以用于创建统一类型的密集数组：<br><figure class="highlight python"><figcaption><span>In[1]:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> array</span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">A = array.array(<span class="string">&#x27;i&#x27;</span>, L)</span><br><span class="line"></span><br><span class="line">A <span class="comment"># array(&#x27;i&#x27;, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br></pre></td></tr></table></figure><br>这里的 ‘i’ 是一个数据类型码，表示数据为整型。<br>更实用的是 NumPy 包中的 ndarray 对象：Python 的数组对象提供了数组型数据的<strong>有效存储</strong>，而 NumPy 为该数据加上了<strong>高效的操作</strong>。</p>
<h2 id="NumPy概述"><a href="#NumPy概述" class="headerlink" title="NumPy概述"></a>NumPy概述</h2><p>由于数据集的来源与格式都十分丰富，比如文档集合、图像集合、声音片段集合、数值数据集合，等等。这些数据虽然存在明显的异构性，但是将所有数据简单地看作数字数组非常有助于我们理解和处理数据。</p>
<p>例如，可以将图像（尤其是数字图像）简单地看作二维数字数组，这些数字数组代表各区域的像素值；声音片段可以看作时间和强度的一维数组；文本也可以通过各种方式转换成数值表示，一种可能的转换是用二进制数表示特定单词或单词对出现的频率。不管数据是何种形式，第一步都是将这些数据转换成数值数组形式的可分析数据。</p>
<p>所以，有效地存储和操作数值数组是数据科学中绝对的基础过程。这次介绍 Python中专门用来处理这些数值数组的工具 NumPy 包。</p>
<p>NumPy（Numerical Python 的简称）提供了高效存储和操作密集数据缓存的接口。在某些方面，NumPy 数组与 Python 内置的列表类型非常相似。但是随着数组在维度上变大，NumPy 数组提供了更加高效的存储和数据操作。NumPy 数组几乎是整个 Python 数据科学工具生态系统的核心。因此，不管你对数据科学的哪个方面感兴趣，花点时间学习如何有效地使用 NumPy 都是非常值得的。</p>
<p>如果你安装了 Anaconda，那么你已经安装好 NumPy，并可以使用它了。如果你喜欢自己安装，则可以到 <span class="exturl" data-url="aHR0cHM6Ly9udW1weS5vcmcv">NumPy官网<i class="fa fa-external-link-alt"></i></span>按照其安装指导进行安装。安装好后，可以查看包的版本和导入包，以及自动补全和内置文档：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># 常用np别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看包的版本</span></span><br><span class="line">np.__version__</span><br><span class="line"><span class="comment"># NumPy 自动补全</span></span><br><span class="line">np.&lt;TAB&gt;</span><br><span class="line"><span class="comment"># 显示 NumPy 内置的文档</span></span><br><span class="line">np?</span><br></pre></td></tr></table></figure><br>Jupyter 中对 NumPy 的常用配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jupyter启用多行输出</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">&quot;all&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy常用np别名</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">np.set_printoptions(threshold=np.inf) <span class="comment"># 设置数组全打印出来，nan可能会报错</span></span><br></pre></td></tr></table></figure></p>
<h2 id="NumPy数组基础"><a href="#NumPy数组基础" class="headerlink" title="NumPy数组基础"></a>NumPy数组基础</h2><p>NumPy中封装的数组类型，是ndarray类型。</p>
<p>在 NumPy 中，明确一些定义：<br>axis：每一个维度（dimension）被称为一个 axis （轴）。<br>rank：axis的数量（轴数） 称为 rank（秩）。例如 3×4 的矩阵是 rank为2（维度为2） 的数组，第一个axis是3，第二个axis是4。<br>shape：数组的 axis列表 称为数组的 shape（形状），是一个整数元组，每个元素保存了对应轴长。例如上述矩阵的 shape 是(3, 4)。rank 等于 shape 的长度。<br>size：数组中存储的元素数量。所有 axis 长度乘积（上述矩阵3×4=12）等于size。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>NumPy 数组包含同一类型的值，因此详细了解 NumPy 数据类型及其限制是非常重要的。NumPy标准数据类型（np.typeDict）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool_            布尔值（真、 True 或假、 False），用一个字节存储</span><br><span class="line">int_             默认整型（类似于 C 语言中的 long，通常情况下是 int64 或 int32）</span><br><span class="line">intc             同 C 语言的 int 相同（通常是 int32 或 int64）</span><br><span class="line">intp             用作索引的整型（和 C 语言的 ssize_t 相同，通常情况下是 int32 或 int64）</span><br><span class="line">int8             字节（byte，范围从 –128 到 127）</span><br><span class="line">int16            整型（范围从 –32768 到 32767）</span><br><span class="line">int32            整型（范围从 –2147483648 到 2147483647）</span><br><span class="line">int64            整型（范围从 –9223372036854775808 到 9223372036854775807）</span><br><span class="line">uint8            无符号整型（范围从 0 到 255）</span><br><span class="line">uint16           无符号整型（范围从 0 到 65535）</span><br><span class="line">uint32           无符号整型（范围从 0 到 4294967295）</span><br><span class="line">uint64           无符号整型（范围从 0 到 18446744073709551615）</span><br><span class="line">float_           float64 的简化形式</span><br><span class="line">float16          半精度浮点型：符号比特位， 5 比特位指数（exponent）， 10 比特位尾数（mantissa）</span><br><span class="line">float32          单精度浮点型：符号比特位， 8 比特位指数， 23 比特位尾数</span><br><span class="line">float64          双精度浮点型：符号比特位， 11 比特位指数， 52 比特位尾数</span><br><span class="line">complex_         complex128 的简化形式</span><br><span class="line">complex64        复数，由两个 32 位浮点数表示</span><br><span class="line">complex128       复数，由两个 64 位浮点数表示</span><br></pre></td></tr></table></figure><br>还可以使用缩写形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">类型符号    描述                  示例</span><br><span class="line">&#39;b&#39;       字节型               np.dtype(&#39;b&#39;)</span><br><span class="line">&#39;i&#39;       有符号整型           np.dtype(&#39;i4&#39;) &#x3D;&#x3D; np.int32</span><br><span class="line">&#39;u&#39;       无符号整型           np.dtype(&#39;u1&#39;) &#x3D;&#x3D; np.uint8</span><br><span class="line">&#39;f&#39;       浮点型               np.dtype(&#39;f8&#39;) &#x3D;&#x3D; np.int64</span><br><span class="line">&#39;c&#39;       复数浮点型           np.dtype(&#39;c16&#39;) &#x3D;&#x3D; np.complex128</span><br><span class="line">&#39;S&#39;&#x2F;&#39;a&#39;   字符串               np.dtype(&#39;S5&#39;)</span><br><span class="line">&#39;U&#39;       Unicode编码字符串    np.dtype(&#39;U&#39;) &#x3D;&#x3D; np.str_</span><br><span class="line">&#39;V&#39;       原生数据（空，void）  np.dtype(&#39;V&#39;) &#x3D;&#x3D; np.void</span><br></pre></td></tr></table></figure><br>NumPy的数值对象的运算速度比Python内置类型的运算速度要慢很多。所以应当尽量避免使用NumPy的数值对象。</p>
<p>还可以进行更高级的数据类型指定，例如指定高位字节数或低位字节数；更多的信息可以在 <span class="exturl" data-url="aHR0cHM6Ly9udW1weS5vcmcvZG9jL3N0YWJsZS9yZWZlcmVuY2UvYXJyYXlzLmR0eXBlcy5odG1s">NumPy文档<i class="fa fa-external-link-alt"></i></span>中查看。NumPy 也支持复合数据类型和缩写方式。</p>
<h3 id="特殊量"><a href="#特殊量" class="headerlink" title="特殊量"></a>特殊量</h3><p>在numpy中，有几个特殊量：<br><code>np.nan</code>：NaN值，它不是数，也并不等价于np.inf。<br><code>np.inf</code>：正无穷。<br><code>np.PINF</code>：正无穷，它就引用的是np.inf。<br><code>np.NINF</code>：负无穷。</p>
<p>有下列函数用于判断这几个特殊量：<br><code>np.isnan(x[,out])</code>：返回x是否是/有NaN，其中x可以是标量，可以是数组。<br><code>np.isfinite(x[, out])</code>：返回x是否是/有有限大小的数，其中x可以是标量，可以是数组。np.nan返回False。<br><code>np.isposinf(x[, out])</code>：返回x是否是/有正无穷大的数，其中x可以是标量，可以是数组。np.nan返回False。<br><code>np.isneginf(x[, out])</code>：返回x是否是/有负无穷大的数，其中x可以是标量，可以是数组。np.nan返回False。<br><code>np.isinf(x[, out])</code>：返回x是否是/有无穷大的数，其中x可以是标量，可以是数组。np.nan返回False。</p>
<p>下列函数用于对这几个特殊量进行转换：<br><code>np.nan_to_num(x)</code>：将数组x中的特殊量替换掉：NaN（替换为0）、正无穷（替换为一个非常大的数字）、负无穷（替换为一个非常小的数字），返回替换掉之后的新数组。</p>
<h3 id="结构化"><a href="#结构化" class="headerlink" title="结构化"></a>结构化</h3><p>当数组中数组字段可以对应实际意义时，我们可以对其加上字段，使其结构化。结构化之后，就可以使用字段处理数据，类似Pandas。<br>假设，有关于一些人的分类数据（如姓名、年龄和体重），使其结构化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Cathy&#x27;</span>, <span class="string">&#x27;Doug&#x27;</span>]</span><br><span class="line">age = [<span class="number">25</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">19</span>]</span><br><span class="line">weight = [<span class="number">55.0</span>, <span class="number">85.5</span>, <span class="number">68.0</span>, <span class="number">61.5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用复合数据结构的结构化数组</span></span><br><span class="line">data = np.zeros(<span class="number">4</span>, dtype=&#123;<span class="string">&#x27;names&#x27;</span>:(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>),</span><br><span class="line">                          <span class="string">&#x27;formats&#x27;</span>:(<span class="string">&#x27;U10&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>, <span class="string">&#x27;f8&#x27;</span>)&#125;)</span><br><span class="line">data</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([(&#x27;&#x27;, 0, 0.), (&#x27;&#x27;, 0, 0.), (&#x27;&#x27;, 0, 0.), (&#x27;&#x27;, 0, 0.)],</span></span><br><span class="line"><span class="string">      dtype=[(&#x27;name&#x27;, &#x27;&lt;U10&#x27;), (&#x27;age&#x27;, &#x27;&lt;i4&#x27;), (&#x27;weight&#x27;, &#x27;&lt;f8&#x27;)])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 给每个字段赋值</span></span><br><span class="line">data[<span class="string">&#x27;name&#x27;</span>] = name</span><br><span class="line">data[<span class="string">&#x27;age&#x27;</span>] = age</span><br><span class="line">data[<span class="string">&#x27;weight&#x27;</span>] = weight</span><br><span class="line">data</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[(&#x27;Alice&#x27;, 25, 55. ) (&#x27;Bob&#x27;, 45, 85.5) (&#x27;Cathy&#x27;, 37, 68. ) (&#x27;Doug&#x27;, 19, 61.5)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 获取所有名字</span></span><br><span class="line">data[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Cathy&#x27;, &#x27;Doug&#x27;], dtype=&#x27;&lt;U10&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 获取年龄小于30岁的人的名字</span></span><br><span class="line">data[data[<span class="string">&#x27;age&#x27;</span>] &lt; <span class="number">30</span>][<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([&#x27;Alice&#x27;, &#x27;Doug&#x27;], dtype=&#x27;&lt;U10&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p><strong>1、可以用 np.array 从 Python 列表创建数组：</strong><br><code>np.array(object[, dtype, copy, order, subok, ndmin])</code>：从object创建。object可以是一个ndarray，也可以是一个序列。copy默认为True，表示拷贝对象。order可以为’C’、’F’、’A’。默认为’A’。subok结果类型是否跟随object，默认为False（结果始终是ndarray类型）。ndmin指定结果ndarray最少有多少个维度。<br><code>np.asarray(a[, dtype, order])</code>：将a转换成一个ndarray。其中a是array_like的对象， 可以是list、list of tuple、tuple、tuple of list、ndarray类型。order默认为C。<br><code>np.asmatrix(data[, dtype])</code>：返回matrix。matrix是ndarray子类。<br><figure class="highlight python"><figcaption><span>In[1]:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.array([<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><br>不同于 Python 列表， NumPy 要求数组必须包含同一类型的数据。如果类型不匹配， NumPy 将会向上转换（如果可行）。这里整型被转换为浮点型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: np.array([<span class="number">3.14</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]) </span><br><span class="line">Out[<span class="number">2</span>]: array([<span class="number">3.14</span>, <span class="number">4.</span>  , <span class="number">2.</span>  , <span class="number">3.</span>  ])</span><br></pre></td></tr></table></figure><br>如果希望明确设置数组的数据类型，可以用 dtype 关键字：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">3</span>]: np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], dtype=<span class="string">&#x27;float32&#x27;</span>) </span><br><span class="line">Out[<span class="number">3</span>]: array([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>], dtype=float32)</span><br></pre></td></tr></table></figure><br>最后，不同于 Python 列表， NumPy 数组可以被指定为多维的。以下是用列表的列表初始化多维数组的一种方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 嵌套列表构成的多维数组</span></span><br><span class="line">In[<span class="number">4</span>]: np.array([<span class="built_in">range</span>(i, i + <span class="number">3</span>) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">Out[<span class="number">4</span>]: array([[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">               [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">               [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br></pre></td></tr></table></figure><br><strong>2、面对大型数组的时候，用 NumPy 内置的方法从头创建数组是一种更高效的方法：</strong><br><code>np.zeros(shape[, dtype, order])</code>：返回一个新的ndarray，指定了shape和type，每个元素初始化为0。<br><code>np.ones(shape[, dtype, order])</code>：返回一个新的ndarray，指定了shape和type，每个元素初始化为1。<br><code>np.full(shape, fill_value[, dtype, order])</code>：返回一个新的ndarray，指定了shape和type，每个元素初始化为fill_value。<br><code>np.eye(N[, M, k, dtype])</code>：返回一个二维数组，对角线元素为1，其余元素为0。M默认等于N。k默认为0表示对角线元素为1，如为正数则表示对角线上方一格的元素为1，如为负数表示对角线下方一格的元素为1。<br><code>np.empty(shape[,dtype,order])</code>：返回一个新的ndarray，指定了shape和dtype，但是没有初始化元素，因此其内容是随机的。<br><code>np.arange([start,] stop[, step,][, dtype])</code>：返回均匀间隔的值组成的一维ndarray。区间是左闭右开[start,stop)，其采样行为类似Python的range函数。<br><code>np.linspace(start, stop[, num, endpoint, ...])</code>：返回num个均匀采样的数值组成的一维ndarray（默认为50）。区间是闭区间[start,stop]。endpoint为布尔值，如果为真则表示stop是最后采样的值（默认为True），否则结果不包含stop。retstep如果为True则返回结果包含采样步长step，默认为True。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个长度为10的数组，数组的值都是0</span></span><br><span class="line">In[<span class="number">5</span>]: np.zeros(<span class="number">10</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line">Out[<span class="number">5</span>]: array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个3×5的浮点型数组，数组的值都是1</span></span><br><span class="line">In[<span class="number">6</span>]: np.ones((<span class="number">3</span>, <span class="number">5</span>), dtype=<span class="built_in">float</span>)</span><br><span class="line">Out[<span class="number">6</span>]: array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">               [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">               [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个3×5的浮点型数组，数组的值都是3.14</span></span><br><span class="line">In[<span class="number">7</span>]: np.full((<span class="number">3</span>, <span class="number">5</span>), <span class="number">3.14</span>)</span><br><span class="line">Out[<span class="number">7</span>]: array([[ <span class="number">3.14</span>, <span class="number">3.14</span>, <span class="number">3.14</span>, <span class="number">3.14</span>, <span class="number">3.14</span>],</span><br><span class="line">               [ <span class="number">3.14</span>, <span class="number">3.14</span>, <span class="number">3.14</span>, <span class="number">3.14</span>, <span class="number">3.14</span>],</span><br><span class="line">               [ <span class="number">3.14</span>, <span class="number">3.14</span>, <span class="number">3.14</span>, <span class="number">3.14</span>, <span class="number">3.14</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个3×5的浮点型数组，数组的值是一个线性序列</span></span><br><span class="line"><span class="comment"># 从0开始，到20结束，步长为2。和内置的range()函数类似</span></span><br><span class="line">In[<span class="number">8</span>]: np.arange(<span class="number">0</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">8</span>]: array([ <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个5个元素的数组，这5个数均匀地分配到0~1</span></span><br><span class="line">In[<span class="number">9</span>]: np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">Out[<span class="number">9</span>]: array([ <span class="number">0.</span> , <span class="number">0.25</span>, <span class="number">0.5</span> , <span class="number">0.75</span>, <span class="number">1.</span> ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个3×3的、在0~1均匀分布的随机数组成的数组</span></span><br><span class="line">In[<span class="number">10</span>]: np.random.random((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">Out[<span class="number">10</span>]:  array([[ <span class="number">0.99844933</span>, <span class="number">0.52183819</span>, <span class="number">0.22421193</span>],</span><br><span class="line">                 [ <span class="number">0.08007488</span>, <span class="number">0.45429293</span>, <span class="number">0.20941444</span>],</span><br><span class="line">                 [ <span class="number">0.14360941</span>, <span class="number">0.96910973</span>, <span class="number">0.946117</span> ]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个3×3的、均值为0、方差为1的、正态分布的随机数数组</span></span><br><span class="line">In[<span class="number">11</span>]: np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">Out[<span class="number">11</span>]: array([[ <span class="number">1.51772646</span>, <span class="number">0.39614948</span>, <span class="number">-0.10634696</span>],</span><br><span class="line">                [ <span class="number">0.25671348</span>, <span class="number">0.00732722</span>, <span class="number">0.37783601</span>],</span><br><span class="line">                [ <span class="number">0.68446945</span>, <span class="number">0.15926039</span>, <span class="number">-0.70744073</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个3×3的、[0, 10)区间的随机整型数组</span></span><br><span class="line">In[<span class="number">12</span>]: np.random.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">Out[<span class="number">12</span>]: array([[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">                [<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">                [<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个3×3的单位矩阵</span></span><br><span class="line">In[<span class="number">13</span>]: np.eye(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">13</span>]: array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">               [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">               [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个由3个整型数组成的未初始化的数组</span></span><br><span class="line"><span class="comment"># 数组的值是随机的</span></span><br><span class="line">In[<span class="number">14</span>]: np.empty(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">14</span>]: array([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回对角线，k控制对角线偏移</span></span><br><span class="line">In[<span class="number">15</span>]: np.diag([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                 [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                 [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]], k=<span class="number">0</span>) </span><br><span class="line">Out[<span class="number">15</span>]: array([<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对角线及以下是1，其他是0</span></span><br><span class="line">In[<span class="number">15</span>]: np.tri(<span class="number">4</span>, <span class="number">4</span>, k=<span class="number">0</span>, dtype=np.float32)</span><br><span class="line">Out[<span class="number">15</span>]: array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">                [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">                [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">                [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]], dtype=float32)</span><br></pre></td></tr></table></figure><br>还有一些其他创建方式：<br><code>np.asanyarray(a[, dtype, order])</code>：将a转换成ndarray。<br><code>np.asmatrix(data[, dtype])</code>：返回matrix。<br><code>np.frombuffer(buffer[, dtype, count, offset])</code>：从输入数据中返回一维ndarray。count指定读取的数量，-1表示全部读取。<br><code>np.fromfile(file[, dtype, count, sep])</code>：从二进制文件或者文本文件中读取数据返回ndarray。sep分隔符。<br><code>np.fromfunction(function, shape, **kwargs)</code>：返回一个从函数中获取每一个坐标点的ndarray数据。shape有几个维度等于function有几个参数，其返回值就是该坐标点的维度通过function计算的值。function是lambda表达式。<br><code>np.fromiter(iterable, dtype[, count])</code>：从可迭代对象中迭代获取数据创建一维ndarray。<br><code>np.fromstring(string[, dtype, count, sep])</code>：从字符串或者二进制串中创建一维ndarray。默认sep为空，字符串按照ASCII码转成对应数值。可将字符串转成数值类型。</p>
<p>数组array对象，还有一些转换方法：<br><code>astype(dtype)</code>：元素转成指定格式。<br><code>tolist()</code>：转成Python列表。<br><code>tobytes()</code>：转成二进制字节。tostring()和其等价。<br><code>tofile()</code>：转成二进制字节写入指定文本中。</p>
<h3 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h3><p>数组的属性：数组的大小、形状、存储大小、数据类型。</p>
<p>首先介绍一些有用的数组属性。定义三个随机的数组：一个一维数组、一个二维数组和一个三维数组。<br>我们将用 NumPy 的随机数生成器设置一组<strong>种子值</strong>，以确保每次程序执行时都可以生成同样的随机数组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">       np.random.seed(<span class="number">0</span>) <span class="comment"># 设置随机数种子</span></span><br><span class="line">       </span><br><span class="line">       x1 = np.random.randint(<span class="number">10</span>, size=<span class="number">6</span>) <span class="comment"># 一维数组</span></span><br><span class="line">       x2 = np.random.randint(<span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">4</span>)) <span class="comment"># 二维数组</span></span><br><span class="line">       x3 = np.random.randint(<span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment"># 三维数组</span></span><br></pre></td></tr></table></figure><br>每个数组有 <code>nidm</code>（数组的维度）、<code>shape</code>（数组每个维度的大小）、<code>size</code>（数组的总大小）和 <code>dtype</code>（数组的数据类型）属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">2</span>]: print(<span class="string">&quot;x3 ndim: &quot;</span>, x3.ndim) <span class="comment"># 等于len(x3.shape)</span></span><br><span class="line">       print(<span class="string">&quot;x3 shape:&quot;</span>, x3.shape)</span><br><span class="line">       print(<span class="string">&quot;x3 size: &quot;</span>, x3.size)</span><br><span class="line">       print(<span class="string">&quot;x3 dtype:&quot;</span>, x3.dtype)</span><br><span class="line">       print(<span class="string">&quot;x3 dtype.type:&quot;</span>, x3.dtype.<span class="built_in">type</span>)</span><br><span class="line"></span><br><span class="line">x3 ndim: <span class="number">3</span></span><br><span class="line">x3 shape: (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">x3 size: <span class="number">60</span></span><br><span class="line">x3 dtype: int64</span><br><span class="line">x3 dtype.<span class="built_in">type</span>: &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">numpy</span>.<span class="title">int64</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><br><strong>dtype是一种对象，它不同于数值类型。只有dtype.type才能获取对应的数值类型</strong>。<br>可使用 <code>astype(dtype)</code> 方法可以对数组元素类型进行转换。</p>
<p>其他的属性，表示每个数组元素字节大小的 <code>itemsize</code>，表示数组总字节大小的 <code>nbytes</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">4</span>]: print(<span class="string">&quot;itemsize:&quot;</span>, x3.itemsize, <span class="string">&quot;bytes&quot;</span>)</span><br><span class="line">       print(<span class="string">&quot;nbytes:&quot;</span>, x3.nbytes, <span class="string">&quot;bytes&quot;</span>)</span><br><span class="line"></span><br><span class="line">itemsize: <span class="number">8</span> <span class="built_in">bytes</span></span><br><span class="line">nbytes: <span class="number">480</span> <span class="built_in">bytes</span></span><br></pre></td></tr></table></figure><br>一般来说，可以认为 nbytes 跟 itemsize 和 size 的乘积大小相等。</p>
<h3 id="数组的索引"><a href="#数组的索引" class="headerlink" title="数组的索引"></a>数组的索引</h3><p><strong>1、简单索引</strong><br>同 Python列表一样，在一维数组中，你也可以通过中括号指定索引获取第 i 个值（从 0 开始计数）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">5</span>]: x1</span><br><span class="line">Out[<span class="number">5</span>]: array([<span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">6</span>]: x1[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用负值索引</span></span><br><span class="line">In[<span class="number">7</span>]: x1[<span class="number">-1</span>]</span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">9</span></span><br></pre></td></tr></table></figure><br>在多维数组中，可以用逗号分隔的索引元组获取元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">8</span>]: x2</span><br><span class="line">Out[<span class="number">8</span>]: array([[<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">                [<span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>],</span><br><span class="line">                [<span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">9</span>]: x2[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In[<span class="number">10</span>]: x2[<span class="number">0</span>, <span class="number">-1</span>]</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure><br>也可以用以上索引方式修改元素值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">11</span>]: x2[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">12</span></span><br><span class="line">        x2</span><br><span class="line">Out[<span class="number">11</span>]: array([[<span class="number">12</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">                [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>],</span><br><span class="line">                [ <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>]])</span><br></pre></td></tr></table></figure><br>注意，和 Python 列表不同， NumPy 数组是固定类型的。<br>当你将一个浮点值插入一个整型数组时，浮点值会被截短成整型。并且这种截短是自动完成的，不会给你提示或警告！<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">12</span>]: x1[<span class="number">0</span>] = <span class="number">3.14159</span> <span class="comment"># 这将被截短</span></span><br><span class="line">        x1</span><br><span class="line">Out[<span class="number">12</span>]: array([<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><br><strong>2、布尔数组作为掩码</strong><br>通过数组的比较运算（后面会讲），可以得到布尔数组，用其作为掩码可选择数据的子数据集（筛选数据）：返回的是一个<strong>一维数组</strong>，它包含了所有满足条件的值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">           [<span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">           [<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>]])</span><br><span class="line">x &lt; <span class="number">5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[False, True, True, True],</span></span><br><span class="line"><span class="string">       [False, False, True, False],</span></span><br><span class="line"><span class="string">       [ True, True, False, False]], dtype=bool)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">x[x &lt; <span class="number">5</span>] <span class="comment"># 布尔数组作为掩码，筛选数据</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([0, 3, 3, 3, 2, 4])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br><strong>3、普通数组作为索引</strong><br>和前面那些简单的索引非常类似，但是传递的是索引数组，而不是单个标量。<strong>结果的形状与索引数组的形状一致</strong>，而不是与被索引数组的形状一致。<br>假设从一维数组中获取三个不同元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">51</span>, <span class="number">92</span>, <span class="number">14</span>, <span class="number">71</span>, <span class="number">60</span>, <span class="number">20</span>, <span class="number">82</span>, <span class="number">86</span>, <span class="number">74</span>, <span class="number">74</span>])</span><br><span class="line"><span class="comment"># 第一种：直接索引</span></span><br><span class="line">[x[<span class="number">3</span>], x[<span class="number">7</span>], x[<span class="number">2</span>]]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([71, 86, 14])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 第二种：传递索引的单个列表或数组</span></span><br><span class="line">x[[<span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([71, 86, 60])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 新第三种：普通数组作为索引，结果的形状与索引数组的形状一致！</span></span><br><span class="line">ind = np.array([[<span class="number">3</span>, <span class="number">7</span>],</span><br><span class="line">                [<span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">x[ind] </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[71, 86],</span></span><br><span class="line"><span class="string">       [60, 20]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>对于多维数组也一样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">           [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">           [ <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="comment"># 第一个索引指的是行，第二个索引指的是列</span></span><br><span class="line">row = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">col = np.array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">x[row, col]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([ 2, 5, 11])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 如果增加维度，遵循广播规则</span></span><br><span class="line">x[row[:, np.newaxis], col]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 原始数组shape</span></span><br><span class="line"><span class="string">row.shape -&gt; (3,)</span></span><br><span class="line"><span class="string">col.shape -&gt; (3,)</span></span><br><span class="line"><span class="string"># newaxis后的数组shape</span></span><br><span class="line"><span class="string">row.shape -&gt; (3, 1)</span></span><br><span class="line"><span class="string">col.shape -&gt; (3,)</span></span><br><span class="line"><span class="string"># 根据（1），数组 col 的维度数更小，所以在其左边补 1：</span></span><br><span class="line"><span class="string">row.shape -&gt; (3, 1)</span></span><br><span class="line"><span class="string">col.shape -&gt; (1, 3)</span></span><br><span class="line"><span class="string"># 根据（2），两个维度不匹配，按照维度为 1 的扩展：</span></span><br><span class="line"><span class="string">row.shape -&gt; (3, 3)</span></span><br><span class="line"><span class="string">col.shape -&gt; (3, 3)</span></span><br><span class="line"><span class="string"># 现在两个数组的形状匹配了，可以看到它们的最终形状都为 (3, 3)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 对应的row和col数组变化</span></span><br><span class="line"><span class="string"># 原始数组shape</span></span><br><span class="line"><span class="string">[0, 1, 2]</span></span><br><span class="line"><span class="string">[2, 1, 3]</span></span><br><span class="line"><span class="string"># newaxis后的数组shape</span></span><br><span class="line"><span class="string">[[0],</span></span><br><span class="line"><span class="string"> [1],</span></span><br><span class="line"><span class="string"> [2]]</span></span><br><span class="line"><span class="string">[2, 1, 3]</span></span><br><span class="line"><span class="string"># 根据（1）...</span></span><br><span class="line"><span class="string">[[0],</span></span><br><span class="line"><span class="string"> [1],</span></span><br><span class="line"><span class="string"> [2]]</span></span><br><span class="line"><span class="string">[[2, 1, 3]]</span></span><br><span class="line"><span class="string"># 根据（2）...</span></span><br><span class="line"><span class="string">[[0, 0, 0],</span></span><br><span class="line"><span class="string"> [1, 1, 1],</span></span><br><span class="line"><span class="string"> [2, 2, 2]]</span></span><br><span class="line"><span class="string">[[2, 1, 3]</span></span><br><span class="line"><span class="string"> [2, 1, 3]</span></span><br><span class="line"><span class="string"> [2, 1, 3]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><br><strong>4、组合索引</strong><br>可以将多种索引组合应用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[ <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">           [ <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">           [ <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]])</span><br><span class="line"><span class="comment"># 普通数组 + 简单索引</span></span><br><span class="line">x[<span class="number">2</span>, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([10, 8, 9])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 普通数组 + 切片</span></span><br><span class="line">x[<span class="number">1</span>:, [<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[ 6, 4, 5],</span></span><br><span class="line"><span class="string">       [10, 8, 9]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 普通数组 + 布尔掩码</span></span><br><span class="line">row = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">mask = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line">x[row[:, np.newaxis], mask]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[ 0, 2],</span></span><br><span class="line"><span class="string">       [ 4, 6],</span></span><br><span class="line"><span class="string">       [ 8, 10]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>对于切片操作在下面会讲解。</p>
<h3 id="数组的切片"><a href="#数组的切片" class="headerlink" title="数组的切片"></a>数组的切片</h3><p>NumPy 切片语法和 Python 列表的标准切片语法相同。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x[start:stop:step]</span><br></pre></td></tr></table></figure><br>如果以上 3 个参数都未指定，那么它们会被分别设置默认值 start=0、 stop= 维度的大小 和 step=1。<br><strong>1、一维子数组</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">13</span>]: x = np.arange(<span class="number">10</span>)</span><br><span class="line">        x</span><br><span class="line">Out[<span class="number">13</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">14</span>]: x[:<span class="number">5</span>] <span class="comment"># 前五个元素</span></span><br><span class="line">Out[<span class="number">14</span>]: array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">15</span>]: x[<span class="number">5</span>:] <span class="comment"># 索引五之后的元素</span></span><br><span class="line">Out[<span class="number">15</span>]: array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">16</span>]: x[<span class="number">4</span>:<span class="number">7</span>] <span class="comment"># 中间的子数组</span></span><br><span class="line">Out[<span class="number">16</span>]: array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">17</span>]: x[::<span class="number">2</span>] <span class="comment"># 每隔一个元素</span></span><br><span class="line">Out[<span class="number">17</span>]: array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">18</span>]: x[<span class="number">1</span>::<span class="number">2</span>] <span class="comment"># 每隔一个元素，从索引1开始</span></span><br><span class="line">Out[<span class="number">18</span>]: array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">19</span>]: x[::<span class="number">-1</span>] <span class="comment"># 所有元素，逆序的</span></span><br><span class="line">Out[<span class="number">19</span>]: array([<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">20</span>]: x[<span class="number">5</span>::<span class="number">-2</span>] <span class="comment"># 从索引5开始每隔一个元素逆序</span></span><br><span class="line">Out[<span class="number">20</span>]: array([<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><br><strong>2、多维子数组</strong><br>多维情况下，每一个axis都可以写一次切片。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">21</span>]: x2</span><br><span class="line">Out[<span class="number">21</span>]: array([[<span class="number">12</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">                [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>],</span><br><span class="line">                [ <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">22</span>]: x2[:<span class="number">2</span>, :<span class="number">3</span>] <span class="comment"># 两行，三列</span></span><br><span class="line">Out[<span class="number">22</span>]: array([[<span class="number">12</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">                [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">23</span>]: x2[:<span class="number">3</span>, ::<span class="number">2</span>] <span class="comment"># 三行，每隔一列</span></span><br><span class="line">Out[<span class="number">23</span>]: array([[<span class="number">12</span>, <span class="number">2</span>],</span><br><span class="line">                [ <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">                [ <span class="number">1</span>, <span class="number">7</span>]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">24</span>]: x2[::<span class="number">-1</span>, ::<span class="number">-1</span>] <span class="comment"># 逆序</span></span><br><span class="line">Out[<span class="number">24</span>]: array([[ <span class="number">7</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>],</span><br><span class="line">                [ <span class="number">8</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">                [ <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">25</span>]: x3</span><br><span class="line">Out[<span class="number">25</span>]: array([[[<span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">8</span>],</span><br><span class="line">                 [<span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">                 [<span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>],</span><br><span class="line">                 [<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">7</span>]],</span><br><span class="line"></span><br><span class="line">                [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>],</span><br><span class="line">                 [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">                 [<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>]],</span><br><span class="line"></span><br><span class="line">                [[<span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">7</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line">                 [<span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">                 [<span class="number">9</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>]]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">26</span>]: x3[:<span class="number">2</span>, :<span class="number">2</span>, :] <span class="comment"># 一维2行，二维2行，三维全部</span></span><br><span class="line">Out[<span class="number">26</span>]: array([[[<span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">8</span>],</span><br><span class="line">                 [<span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">                [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">0</span>],</span><br><span class="line">                 [<span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>]]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">27</span>]: x3[:<span class="number">2</span>, :<span class="number">2</span>, :<span class="number">2</span>] <span class="comment"># 一维2行，二维2行，三维2列</span></span><br><span class="line">Out[<span class="number">27</span>]: array([[[<span class="number">8</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">9</span>, <span class="number">4</span>]],</span><br><span class="line"></span><br><span class="line">                [[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                 [<span class="number">4</span>, <span class="number">7</span>]]])</span><br></pre></td></tr></table></figure><br><strong>3、获取数组的行和列</strong><br>可以将索引与切片组合起来，实现获取数组的单行和单列：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">28</span>]: print(x2[:, <span class="number">0</span>]) <span class="comment"># x2的第一列</span></span><br><span class="line">[<span class="number">12</span> <span class="number">7</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In[<span class="number">29</span>]: print(x2[<span class="number">0</span>, :]) <span class="comment"># x2的第一行，空的切片可省略：x2[0]</span></span><br><span class="line">[<span class="number">12</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure><br><strong>4、非副本的视图子数组</strong><br>关于数组切片有一点很重要也非常有用，那就是数组切片返回的是数组数据的视图，而不是数值数据的副本。这一点也是 NumPy 数组切片和 Python 列表切片的不同之处：在Python 列表中，切片是值的副本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">30</span>]: print(x2)</span><br><span class="line">[[<span class="number">12</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span>]</span><br><span class="line">[ <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">8</span>]</span><br><span class="line">[ <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从中抽取一个 2×2 的子数组</span></span><br><span class="line">In[<span class="number">31</span>]: x2_sub = x2[:<span class="number">2</span>, :<span class="number">2</span>]</span><br><span class="line">        print(x2_sub)</span><br><span class="line">[[<span class="number">12</span> <span class="number">5</span>]</span><br><span class="line">[ <span class="number">7</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在如果修改这个子数组，将会看到原始数组也被修改了！</span></span><br><span class="line">In[<span class="number">32</span>]: x2_sub[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">        print(x2_sub)</span><br><span class="line">[[<span class="number">99</span> <span class="number">5</span>]</span><br><span class="line">[ <span class="number">7</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">In[<span class="number">33</span>]: print(x2)</span><br><span class="line">[[<span class="number">99</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span>]</span><br><span class="line">[ <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">8</span>]</span><br><span class="line">[ <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span>]]</span><br></pre></td></tr></table></figure><br>这种默认的处理方式实际上非常有用：它意味着在处理非常大的数据集时，可以获取或处理这些数据集的片段，而不用复制底层的数据缓存。<br><div class="note info"><p>注意，NumPy索引返回的是深拷贝 copy() 结果，而NumPy切片返回的是浅拷贝（视图）结果。</p>
</div></p>
<p><strong>5、创建数组的副本</strong><br>有些时候需要明确地复制数组里的数据或子数组，可以通过深拷贝 <code>copy()</code> 方法实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">34</span>]: x2_sub_copy = x2[:<span class="number">2</span>, :<span class="number">2</span>].copy()</span><br><span class="line">        print(x2_sub_copy)</span><br><span class="line">[[<span class="number">99</span> <span class="number">5</span>]</span><br><span class="line">[ <span class="number">7</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果修改这个子数组，原始的数组不会被改变</span></span><br><span class="line">In[<span class="number">35</span>]: x2_sub_copy[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">42</span></span><br><span class="line">        print(x2_sub_copy)</span><br><span class="line">[[<span class="number">42</span> <span class="number">5</span>]</span><br><span class="line">[ <span class="number">7</span> <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">In[<span class="number">36</span>]: print(x2)</span><br><span class="line">[[<span class="number">99</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span>]</span><br><span class="line">[ <span class="number">7</span> <span class="number">6</span> <span class="number">8</span> <span class="number">8</span>]</span><br><span class="line">[ <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span>]]</span><br></pre></td></tr></table></figure></p>
<h3 id="数组的变形"><a href="#数组的变形" class="headerlink" title="数组的变形"></a>数组的变形</h3><p>数组变形最灵活的实现方式是通过 <code>reshape()</code> 函数来实现，例如，如果你希望将数字 1~9 放入一个 3×3 的矩阵中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">37</span>]: grid = np.arange(<span class="number">1</span>, <span class="number">10</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">        print(grid)</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line">[<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><br>注意，原始数组的大小必须和变形后数组的大小一致，如果不确定某个量，可以使用 -1 让它自己计算。如果满足这个条件， reshape 方法将会用到原始数组的一个非副本视图（深拷贝）。</p>
<p>另一种方式是将一个一维数组转变为二维的行或列的矩阵。可以通过 reshape 方法来实现，或者在一个切片操作中利用<code>np.newaxis</code>关键字：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过变形获得的行向量 </span></span><br><span class="line">In[<span class="number">38</span>]: x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">        x.reshape((<span class="number">1</span>, <span class="number">3</span>)) </span><br><span class="line">Out[<span class="number">38</span>]: array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过newaxis获得的行向量</span></span><br><span class="line">In[<span class="number">39</span>]: x[np.newaxis, :] </span><br><span class="line">Out[<span class="number">39</span>]: array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过变形获得的列向量</span></span><br><span class="line">In[<span class="number">40</span>]: x.reshape((<span class="number">3</span>, <span class="number">1</span>)) </span><br><span class="line">Out[<span class="number">40</span>]: array([[<span class="number">1</span>],</span><br><span class="line">                [<span class="number">2</span>],</span><br><span class="line">                [<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过newaxis获得的列向量</span></span><br><span class="line">In[<span class="number">41</span>]: x[:, np.newaxis] </span><br><span class="line">Out[<span class="number">41</span>]: array([[<span class="number">1</span>],</span><br><span class="line">                [<span class="number">2</span>],</span><br><span class="line">                [<span class="number">3</span>]])</span><br></pre></td></tr></table></figure><br>还可以扁平化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">y = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[ 0  1  2  3]</span></span><br><span class="line"><span class="string"> [ 4  5  6  7]</span></span><br><span class="line"><span class="string"> [ 8  9 10 11]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回新的(拷贝),扁平化(转成一维的)</span></span><br><span class="line">y.flatten()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数组拼接和分裂"><a href="#数组拼接和分裂" class="headerlink" title="数组拼接和分裂"></a>数组拼接和分裂</h3><p>以上所有的操作都是针对单一数组的，但有时也需要将多个数组合并为一个，或将一个数组分裂成多个。<br><strong>1. 数组的拼接</strong><br>拼接或连接 NumPy 中的多个数组主要由 np.concatenate、np.vstack 和 np.hstack 和 np.dstack实现。<br><code>np.concatenate((a1, a2, ...), axis=0)</code>：连接多个数组。其中(a1,a2,…)为待连接数组的序列，它们沿着axis指定的轴连接。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">42</span>]: x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">        y = np.array([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">        np.concatenate([x, y])<span class="comment"># 沿着0轴拼接</span></span><br><span class="line">Out[<span class="number">42</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">43</span>]: grid = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                         [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着0轴拼接</span></span><br><span class="line">In[<span class="number">44</span>]: np.concatenate([grid, grid])</span><br><span class="line">Out[<span class="number">44</span>]: array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着1轴拼接（从0开始索引）</span></span><br><span class="line">In[<span class="number">45</span>]: np.concatenate([grid, grid], axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">45</span>]: array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><br>沿着固定维度处理数组时，使用 np.vstack（0维）和 np.hstack（1维）和 np.dstack（2维） 会更简洁：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">46</span>]: x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">        grid = np.array([[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>],</span><br><span class="line">                         [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>]])</span><br><span class="line">        np.vstack([x, grid])<span class="comment"># 沿0轴拼接，增加行</span></span><br><span class="line">Out[<span class="number">46</span>]: array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>],</span><br><span class="line">                [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">47</span>]: y = np.array([[<span class="number">99</span>],</span><br><span class="line">                      [<span class="number">99</span>]])</span><br><span class="line">        np.hstack([grid, y])<span class="comment"># 沿1轴拼接，增加列</span></span><br><span class="line">Out[<span class="number">47</span>]: array([[ <span class="number">9</span>,  <span class="number">8</span>,  <span class="number">7</span>, <span class="number">99</span>],</span><br><span class="line">                [ <span class="number">6</span>,  <span class="number">5</span>,  <span class="number">4</span>, <span class="number">99</span>]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">48</span>]: x = np.array([[[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>],</span><br><span class="line">                       [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>]],</span><br><span class="line">              </span><br><span class="line">                      [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                       [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]]])</span><br><span class="line">        grid = np.array([[[<span class="number">11</span>],</span><br><span class="line">                          [<span class="number">12</span>]],</span><br><span class="line">                    </span><br><span class="line">                         [[<span class="number">13</span>],</span><br><span class="line">                          [<span class="number">14</span>]]])</span><br><span class="line">        np.dstack([x, grid])<span class="comment"># 沿2轴拼接，增加列</span></span><br><span class="line">Out[<span class="number">48</span>]: array([[[ <span class="number">9</span>,  <span class="number">8</span>,  <span class="number">7</span>, <span class="number">11</span>],</span><br><span class="line">                 [ <span class="number">6</span>,  <span class="number">5</span>,  <span class="number">4</span>, <span class="number">12</span>]],</span><br><span class="line"></span><br><span class="line">                [[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>, <span class="number">13</span>],</span><br><span class="line">                 [ <span class="number">3</span>,  <span class="number">2</span>,  <span class="number">1</span>, <span class="number">14</span>]]])</span><br></pre></td></tr></table></figure><br><strong>2、数组的分裂</strong><br>与拼接相反的过程是分裂。分裂可以通过 np.split、 np.vsplit 和 np.hsplit 和 np.dsplit 函数来实现。<br><code>np.split(ary, indices_or_sections, axis=0)</code>：用于沿着指定的轴拆分数组ary。indices_or_sections指定了拆分点：如果为整数N，则表示平均拆分成N份。如果不能平均拆分，则报错；如果为序列，则该序列指定了分裂点的位置，N 个分裂点会得到 N + 1 个子数组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">49</span>]: x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">        x1, x2, x3 = np.split(x, [<span class="number">3</span>, <span class="number">5</span>])<span class="comment"># 在3和5位置分裂，2个分裂点，分裂成3个子数组</span></span><br><span class="line">        print(x1, x2, x3)</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>] [<span class="number">99</span> <span class="number">99</span>] [<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>相关的 np.vsplit 和 np.hsplit 和 np.dsplit 的用法也类似：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">50</span>]: grid = np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">        grid</span><br><span class="line">Out[<span class="number">50</span>]: array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">                [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">                [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">                [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">51</span>]: upper, lower = np.vsplit(grid, [<span class="number">3</span>]) <span class="comment"># 沿0轴分裂，分裂行，在第3行分裂</span></span><br><span class="line">        print(upper)</span><br><span class="line">        print(lower)</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"> [[<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]]</span><br><span class="line"></span><br><span class="line">In[<span class="number">52</span>]: left, right = np.hsplit(grid, [<span class="number">3</span>])<span class="comment"># 沿1轴分裂，分裂列，在第3列分裂</span></span><br><span class="line">        print(left)</span><br><span class="line">        print(right)</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line"> [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span>]]</span><br><span class="line">[[ <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">7</span>]</span><br><span class="line"> [<span class="number">11</span>]</span><br><span class="line"> [<span class="number">15</span>]]</span><br><span class="line"></span><br><span class="line">In[<span class="number">53</span>]: x = np.array([[[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>],</span><br><span class="line">                       [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>],</span><br><span class="line">                       [<span class="number">22</span>, <span class="number">21</span>, <span class="number">20</span>]],</span><br><span class="line">                        </span><br><span class="line">                      [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                       [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                       [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]],</span><br><span class="line">                        </span><br><span class="line">                      [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">                       [<span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">                       [<span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]]])</span><br><span class="line"></span><br><span class="line">In[<span class="number">54</span>]: left, right = np.dsplit(x, [<span class="number">1</span>]) <span class="comment"># 沿2轴分裂，分裂列，在第1列分裂</span></span><br><span class="line">        print(left)</span><br><span class="line">        print(right)</span><br><span class="line">[[[ <span class="number">9</span>]</span><br><span class="line">  [ <span class="number">6</span>]</span><br><span class="line">  [<span class="number">22</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">1</span>]</span><br><span class="line">  [ <span class="number">3</span>]</span><br><span class="line">  [<span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">4</span>]</span><br><span class="line">  [ <span class="number">6</span>]</span><br><span class="line">  [<span class="number">14</span>]]]]</span><br><span class="line">[[[ <span class="number">8</span>  <span class="number">7</span>]</span><br><span class="line">  [ <span class="number">5</span>  <span class="number">4</span>]</span><br><span class="line">  [<span class="number">21</span> <span class="number">20</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line">  [ <span class="number">2</span>  <span class="number">1</span>]</span><br><span class="line">  [<span class="number">12</span> <span class="number">13</span>]]</span><br><span class="line"></span><br><span class="line"> [[ <span class="number">5</span>  <span class="number">6</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line">  [<span class="number">15</span> <span class="number">16</span>]]]]</span><br></pre></td></tr></table></figure></p>
<h2 id="NumPy通用函数"><a href="#NumPy通用函数" class="headerlink" title="NumPy通用函数"></a>NumPy通用函数</h2><p>NumPy 数组的计算有时非常快，有时也非常慢。使 NumPy 变快的关键是利用向量化操作，通常在 NumPy 的通用函数（ufunc）中实现。它可以提高数组元素的重复计算的效率。</p>
<h3 id="Python缓慢的循环"><a href="#Python缓慢的循环" class="headerlink" title="Python缓慢的循环"></a>Python缓慢的循环</h3><p>Python 的相对缓慢通常出现在很多小操作需要不断重复的时候，比如对数组的每个元素做循环操作时。假设有一个数组，我们想计算每个元素的倒数，一种直接的解决方法是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_reciprocals</span>(<span class="params">values</span>):</span></span><br><span class="line">    output = np.empty(<span class="built_in">len</span>(values))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(values)):</span><br><span class="line">        output[i] = <span class="number">1.0</span> / values[i]</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line">        </span><br><span class="line">values = np.random.randint(<span class="number">1</span>, <span class="number">10</span>, size=<span class="number">5</span>)</span><br><span class="line">compute_reciprocals(values) <span class="comment"># array([ 0.16666667,  1.        ,  0.25      ,  0.25      ,  0.125     ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试下处理大数量数据时，执行时间</span></span><br><span class="line">big_array = np.random.randint(<span class="number">1</span>, <span class="number">100</span>, size=<span class="number">1000000</span>)</span><br><span class="line">%timeit compute_reciprocals(big_array) <span class="comment"># 2.35 s ± 55.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></span><br></pre></td></tr></table></figure><br>完成百万次上述操作并存储结果竟然花了几秒钟的时间，现在手机运算速度都比这快，所以为什么这么慢呢？<br>事实上，这里的处理瓶颈并不是运算本身，而是 CPython 在每次循环时必须做数据类型的检查和函数的调度。每次进行倒数运算时， Python 首先检查对象的类型，并且动态查找可以使用该数据类型的正确函数。如果我们在编译代码时进行这样的操作，那么就能在代码执行之前知晓类型的声明，结果的计算也会更加有效率。</p>
<h3 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h3><p>NumPy 为很多类型的操作提供了非常方便的、静态类型的、可编译程序的接口，也被称作<strong>向量操作</strong>。这种向量方法被用于将循环推送至 NumPy 之下的编译层（C语言），这样会取得更快的执行效率。比如上述操作，换成向量操作进行对比：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%timeit compute_reciprocals(values)</span><br><span class="line">%timeit (<span class="number">1.0</span> / values) <span class="comment"># 向量操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#11.8 µs ± 40.6 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></span><br><span class="line"><span class="comment">#1.14 µs ± 7.56 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)</span></span><br></pre></td></tr></table></figure><br>向量操作所花费的时间更少！<br>NumPy 中的向量操作是通过通用函数实现的。通用函数的主要目的是对 NumPy 数组中的值执行更快的重复操作。<br>只要看到 Python 脚本中有大数组的循环操作，就应该考虑能否用向量方式（通用函数）替换这个循环操作。</p>
<p>基本上所有的通用函数可以指定一个<code>out</code>参数来保存计算结果数组，并返回out数组。如果未指定out参数，则创建新的数组来保存计算结果。可以用这个特性将计算结果直接写入到你期望的存储位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line">y = np.zeros(<span class="number">10</span>)</span><br><span class="line">print(x) <span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line">print(y) <span class="comment"># [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]</span></span><br><span class="line">print(np.power(<span class="number">2</span>, x, out=y[::<span class="number">2</span>])) <span class="comment"># [ 1.,  2.,  4.,  8., 16.]</span></span><br><span class="line">print(y) <span class="comment"># [ 1.,  0.,  2.,  0.,  4.,  0.,  8.,  0., 16.,  0.]</span></span><br></pre></td></tr></table></figure><br>如果这里写的是 <code>y[::2] = 2**x</code>，那么结果将是创建一个临时数组，该数组存放的是<code>2**x</code>的结果，并且接下来会将这些值复制到 y 数组中。对于较大的数组，通过慎重使用 out 参数将能够有效节约内存。</p>
<p>这种技巧同样适用于普通计算：当表达式比较复杂，数组还很大时，会产生很多中间结果而降低运算速度，比如<code>x=a*b+c</code>会创建一个临时数组存放<code>a*b</code>的结果，再执行<code>x=临时数组+c</code>，最后<code>del 临时数组</code>。我们可以使用<code>x=a*b</code>，再<code>x+=c</code>，从而减少了一次内存分配。</p>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>NumPy 如何通过通用函数的向量化操作来减少缓慢的 Python 循环，另外一种向量化操作的方法是利用 NumPy 的广播功能。广播可以简单理解为用于不同大小数组的二进制通用函数（加、减、乘等）的一组规则。</p>
<p>可以将一个标量（可以认为是一个零维的数组）和一个数组相加：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line">y = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">print(x + y) </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;[5 6 7]&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>这个操作是将数值 5 扩展或重复至数组 [5, 5, 5]，然后执行加法。 NumPy广播功能的好处是，这种对值的重复实际上并没有发生，但是这是一种很好用的理解广播的模型。<br><img src="https://i.loli.net/2021/05/06/OHdiXwJb9Ev7jKR.jpg" alt=""></p>
<p>也可以将这个原理扩展到更高维度的数组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">y = np.ones((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">print(x + y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[1. 2. 3.]</span></span><br><span class="line"><span class="string"> [1. 2. 3.]</span></span><br><span class="line"><span class="string"> [1. 2. 3.]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>一维数组 x 被扩展或者广播了，它沿着第二个维度扩展，扩展到匹配 y 数组的形状。<br><img src="https://i.loli.net/2021/05/06/uN5AyJ1g9GIdkVv.jpg" alt=""></p>
<p>更复杂的情况会涉及对两个数组的同时广播：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">3</span>) <span class="comment">#shape：(3,) </span></span><br><span class="line">y = np.arange(<span class="number">3</span>)[:, np.newaxis] <span class="comment">#shape：(3,1) </span></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[0 1 2]</span></span><br><span class="line"><span class="string">[[0]</span></span><br><span class="line"><span class="string"> [1]</span></span><br><span class="line"><span class="string"> [2]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">print(x + y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[0 1 2]</span></span><br><span class="line"><span class="string"> [1 2 3]</span></span><br><span class="line"><span class="string"> [2 3 4]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2021/05/06/FUYlmujL684MbkN.jpg" alt=""><br>注意的是，这个额外的内存并没有在实际操作中进行分配，但是这样的想象方式更方便我们从概念上理解。</p>
<p><strong>广播的规则</strong><br>NumPy 的广播遵循一组严格的规则，设定这组规则是为了决定两个数组间的操作。<br>（1）如果两个数组的维度数不相同，那么小维度数组的形状将会在最左边补 1。<br>（2）如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为 1 的维度扩展以匹配另外一个数组的形状。<br>（3）如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度等于 1，那么会引发异常。</p>
<p>如果你不确定广播后数组的情况，可使用<code>np.broadcast_arrays()</code>查看广播后的数组，但广播不成功的也会报错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">x = np.ones((<span class="number">2</span>, <span class="number">3</span>)) </span><br><span class="line">y = np.arange(<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[1. 1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1. 1.]]</span></span><br><span class="line"><span class="string">[0 1 2] </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 原始数组shape</span></span><br><span class="line"><span class="string">x.shape -&gt; (2, 3)</span></span><br><span class="line"><span class="string">y.shape -&gt; (3,)</span></span><br><span class="line"><span class="string"># 根据（1），数组 y 的维度数更小，所以在其左边补 1：</span></span><br><span class="line"><span class="string">x.shape -&gt; (2, 3)</span></span><br><span class="line"><span class="string">y.shape -&gt; (1, 3)</span></span><br><span class="line"><span class="string"># 根据（2），第一个维度不匹配，因此扩展这个维度以匹配数组：</span></span><br><span class="line"><span class="string">x.shape -&gt; (2, 3)</span></span><br><span class="line"><span class="string">y.shape -&gt; (2, 3)</span></span><br><span class="line"><span class="string"># 现在两个数组的形状匹配了，可以看到它们的最终形状都为 (2, 3)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># np.broadcast_arrays(x, y)</span></span><br><span class="line">print(x + y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[1. 2. 3.]</span></span><br><span class="line"><span class="string"> [1. 2. 3.]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">y = np.arange(<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[0]</span></span><br><span class="line"><span class="string"> [1]</span></span><br><span class="line"><span class="string"> [2]]</span></span><br><span class="line"><span class="string">[0 1 2]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 原始数组shape</span></span><br><span class="line"><span class="string">x.shape -&gt; (3, 1)</span></span><br><span class="line"><span class="string">y.shape -&gt; (3,)</span></span><br><span class="line"><span class="string"># 根据（1），数组 y 的维度数更小，所以在其左边补 1：</span></span><br><span class="line"><span class="string">x.shape -&gt; (3, 1)</span></span><br><span class="line"><span class="string">y.shape -&gt; (1, 3)</span></span><br><span class="line"><span class="string"># 根据（2），维度为1的数组扩展维度，这两个数组的维度都有1，所以都扩展来相互匹配：</span></span><br><span class="line"><span class="string">x.shape -&gt; (3, 3)</span></span><br><span class="line"><span class="string">y.shape -&gt; (3, 3)</span></span><br><span class="line"><span class="string"># 现在两个数组的形状匹配了，可以看到它们的最终形状都为 (3, 3)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># np.broadcast_arrays(x, y)</span></span><br><span class="line">print(x + y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[0, 1, 2],</span></span><br><span class="line"><span class="string">[1, 2, 3],</span></span><br><span class="line"><span class="string">[2, 3, 4]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">x = np.ones((<span class="number">3</span>, <span class="number">2</span>)) </span><br><span class="line">y = np.arange(<span class="number">3</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1.]</span></span><br><span class="line"><span class="string"> [1. 1.]]</span></span><br><span class="line"><span class="string">[0 1 2] </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 原始数组shape</span></span><br><span class="line"><span class="string">x.shape -&gt; (3, 2)</span></span><br><span class="line"><span class="string">y.shape -&gt; (3,)</span></span><br><span class="line"><span class="string"># 根据（1），数组 y 的维度数更小，所以在其左边补 1：</span></span><br><span class="line"><span class="string">x.shape -&gt; (3, 2)</span></span><br><span class="line"><span class="string">y.shape -&gt; (1, 3)</span></span><br><span class="line"><span class="string"># 根据（2），维度为1的数组扩展维度：</span></span><br><span class="line"><span class="string">x.shape -&gt; (3, 2)</span></span><br><span class="line"><span class="string">y.shape -&gt; (3, 3)</span></span><br><span class="line"><span class="string"># 现在两个数组的形状还不匹配，因此这两个数组是不兼容的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">print(x + y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ValueError                                Traceback (most recent call last)</span></span><br><span class="line"><span class="string">&lt;ipython-input-217-39cb3db33052&gt; in &lt;module&gt;</span></span><br><span class="line"><span class="string">----&gt; 1 print(x+y)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ValueError: operands could not be broadcast together with shapes (3,2) (3,) </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>还有一些有意思的广播方法：<br><code>ndarray.repeat(repeats, axis=None)</code>：重复某个轴上的值。repeats为重复次数，axis指定被重复的轴，如果未指定，则将数组<code>flatten()</code>后重复。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">x.repeat(<span class="number">3</span>) <span class="comment"># flatten()，因为未指定axis</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">x.repeat(<span class="number">3</span>, axis=<span class="number">0</span>) <span class="comment"># 0轴重复3次</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[0, 1, 2],</span></span><br><span class="line"><span class="string">       [0, 1, 2],</span></span><br><span class="line"><span class="string">       [0, 1, 2],</span></span><br><span class="line"><span class="string">       [3, 4, 5],</span></span><br><span class="line"><span class="string">       [3, 4, 5],</span></span><br><span class="line"><span class="string">       [3, 4, 5]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">x.repeat(<span class="number">3</span>, axis=<span class="number">1</span>) <span class="comment"># 1轴重复3次</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[0, 0, 0, 1, 1, 1, 2, 2, 2],</span></span><br><span class="line"><span class="string">       [3, 3, 3, 4, 4, 4, 5, 5, 5]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br><code>np.ix_(x1,x2,...xn)</code>：将N个一维数组转换成可广播的N个多维数组。多维数组的shape：对角线是每个一维数组的长度，其余全是1。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">z = np.array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># 原始数组shape</span></span><br><span class="line"><span class="string">x.shape -&gt; (2,)</span></span><br><span class="line"><span class="string">y.shape -&gt; (3,)</span></span><br><span class="line"><span class="string">z.shape -&gt; (4,)</span></span><br><span class="line"><span class="string"># 按对角线补 1，第一个数组右边补 1 ，最后一个数组左边补 1 ，其余的两侧补 1 ：</span></span><br><span class="line"><span class="string">x.shape -&gt; (2, 1, 1)</span></span><br><span class="line"><span class="string">y.shape -&gt; (1, 3, 1)</span></span><br><span class="line"><span class="string">z.shape -&gt; (1, 1, 4)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">print(np.ix_(x,y,z))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(array([[[0]],</span></span><br><span class="line"><span class="string">        [[1]]]),</span></span><br><span class="line"><span class="string"> array([[[2],</span></span><br><span class="line"><span class="string">         [3],</span></span><br><span class="line"><span class="string">         [4]]]),</span></span><br><span class="line"><span class="string"> array([[[5, 6, 7, 8]]]))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br><code>np.meshgrid(x1,x2,...xn)</code>：将N个一维数组转换成广播后的N个多维数组。多维数组的shape：<code>(x2长度，x1长度，x3...xn)</code>。可以用于生成N维网格坐标，每个N维数组的坐标一一对应就是网格坐标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">z = np.array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">a = np.meshgrid(x,y,z)</span><br><span class="line">a[<span class="number">0</span>].shape,a[<span class="number">1</span>].shape,a[<span class="number">2</span>].shape</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">((3, 2, 4), (3, 2, 4), (3, 2, 4))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[array([[[0, 0, 0, 0],</span></span><br><span class="line"><span class="string">         [1, 1, 1, 1]],</span></span><br><span class="line"><span class="string">        [[0, 0, 0, 0],</span></span><br><span class="line"><span class="string">         [1, 1, 1, 1]],</span></span><br><span class="line"><span class="string">        [[0, 0, 0, 0],</span></span><br><span class="line"><span class="string">         [1, 1, 1, 1]]]), </span></span><br><span class="line"><span class="string"> array([[[2, 2, 2, 2],</span></span><br><span class="line"><span class="string">         [2, 2, 2, 2]],</span></span><br><span class="line"><span class="string">        [[3, 3, 3, 3],</span></span><br><span class="line"><span class="string">         [3, 3, 3, 3]],</span></span><br><span class="line"><span class="string">        [[4, 4, 4, 4],</span></span><br><span class="line"><span class="string">         [4, 4, 4, 4]]]), </span></span><br><span class="line"><span class="string"> array([[[5, 6, 7, 8],</span></span><br><span class="line"><span class="string">         [5, 6, 7, 8]],</span></span><br><span class="line"><span class="string">        [[5, 6, 7, 8],</span></span><br><span class="line"><span class="string">         [5, 6, 7, 8]],</span></span><br><span class="line"><span class="string">        [[5, 6, 7, 8],</span></span><br><span class="line"><span class="string">         [5, 6, 7, 8]]])]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="数组的运算"><a href="#数组的运算" class="headerlink" title="数组的运算"></a>数组的运算</h3><p>通用函数有两种存在形式： 一元通用函数（unary ufunc）对单个输入操作， 二元通用函数（binary ufunc）对两个输入操作。</p>
<h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><p>NumPy 通用函数使用了 Python 原生的算术运算符，标准的加、减、乘、除、模、取负和 指数运算 都可以使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">4</span>)</span><br><span class="line">print(<span class="string">&quot;x     =&quot;</span>, x)</span><br><span class="line">print(<span class="string">&quot;x + 5 =&quot;</span>, x + <span class="number">5</span>)</span><br><span class="line">print(<span class="string">&quot;x - 5 =&quot;</span>, x - <span class="number">5</span>)</span><br><span class="line">print(<span class="string">&quot;x * 2 =&quot;</span>, x * <span class="number">2</span>)</span><br><span class="line">print(<span class="string">&quot;x / 2 =&quot;</span>, x / <span class="number">2</span>)</span><br><span class="line">print(<span class="string">&quot;x // 2 =&quot;</span>, x // <span class="number">2</span>)  <span class="comment"># 取整运算</span></span><br><span class="line">print(<span class="string">&quot;-x     = &quot;</span>, -x) <span class="comment"># 取反运算</span></span><br><span class="line">print(<span class="string">&quot;x ** 2 = &quot;</span>, x ** <span class="number">2</span>) </span><br><span class="line">print(<span class="string">&quot;x % 2  = &quot;</span>, x % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">x     = [0 1 2 3]</span></span><br><span class="line"><span class="string">x + 5 = [5 6 7 8]</span></span><br><span class="line"><span class="string">x - 5 = [-5 -4 -3 -2]</span></span><br><span class="line"><span class="string">x * 2 = [0 2 4 6]</span></span><br><span class="line"><span class="string">x / 2 = [0.  0.5 1.  1.5]</span></span><br><span class="line"><span class="string">x // 2 = [0 0 1 1]</span></span><br><span class="line"><span class="string">-x     =  [ 0 -1 -2 -3]</span></span><br><span class="line"><span class="string">x ** 2 =  [0 1 4 9]</span></span><br><span class="line"><span class="string">x % 2  =  [0 1 0 1]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>可以任意将这些算术运算符组合使用，但要考虑优先级。</p>
<p>所有这些运算符都是 NumPy 内置 通用函数（ufunc）的简单封装器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">运算符     ufunc函数             描述</span><br><span class="line">+          np.add            加法运算（即 1 + 1 &#x3D; 2）</span><br><span class="line">-          np.subtract       减法运算（即 3 - 2 &#x3D; 1）</span><br><span class="line">-          np.negative       负数运算（即 -2）</span><br><span class="line">*          np.multiply       乘法运算（即 2 * 3 &#x3D; 6）</span><br><span class="line">&#x2F;          np.divide         除法运算（即 3 &#x2F; 2 &#x3D; 1.5）</span><br><span class="line">&#x2F;&#x2F;         np.floor_divide   取整运算（即 3 &#x2F;&#x2F; 2 &#x3D; 1）</span><br><span class="line">**         np.power          指数运算（即 2 ** 3 &#x3D; 8）</span><br><span class="line">%          np.mod            模 &#x2F; 余数（即 9 % 4 &#x3D; 1）</span><br></pre></td></tr></table></figure><br>除了以上有运算符的算术运算，还包括其他数学运算：<br><code>abs/fabs</code>：计算整数、浮点数或者复数（返回的是复数的模）的绝对值。非复数值fabs计算更快。<br><code>sqrt</code>：计算平方根，相当于a**0.5。<br><code>square</code>：计算平方，相当于a**2。<br><code>exp/expm1</code>：计算e的指数$e^x,e^{1+x}$，当x很小时<code>expm1</code>比<code>exp</code>计算更精确。<br><code>log/log1p/log2/log10</code>：计算对数$log_e^x,log_{e}^{1+x},log_{2}^x,log_{10}^x$，当x很小时<code>log1p</code>比<code>log</code>计算更精确。<br><code>ceil</code>：向上取整，大于等于该值的最小整数。<br><code>floor</code>：向下取整，小于等于该值的最大整数。<br><code>rint</code>：将各元素四舍五入到最接近的整数，保留dtype。<br><code>modf</code>：将数组的小数和整数部分以两个独立数组的形式返回。<br><code>sign</code>：计算 $sign(a)$。<br><code>cos/cosh/sin/sinh/tan/tanh</code>：普通和双曲型三角函数。<br><code>arccos/arcsosh/arcsin/arcsinh/arctan/arctanh</code>：反三角函数。</p>
<p>除此之外，通用函数优异来源是子模块 scipy.special，它有更加复杂的运算，比如统计学的<code>gamma(x)</code>Gamma函数、<code>erf(x)</code>误差函数（高斯积分）。</p>
<p>但NumPy的某些通用函数，如np.sin()，支持计算单个数值。但是在单个数值的计算速度上，Python的math.sin()要快得多。两个原因：<br>（1）np.sin()为了同时支持数组和单个数值运算，其C语言的内部实现要比math.sin()复杂。<br>（2）单个数值的计算上，np.sin()返回的是numpy.float64类型，而math.sin()返回的是Python的标准float类型。<br>所以，只是计算单个数值的运算，建议使用Python内置的函数。</p>
<h4 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运算符     ufunc函数            描述</span><br><span class="line">&#x3D;&#x3D;         np.equal            等于</span><br><span class="line">!&#x3D;         np.not_equal        不等于</span><br><span class="line">&lt;          np.less             小于</span><br><span class="line">&lt;&#x3D;         np.less_equal       小于等于</span><br><span class="line">&gt;          np.greater          大于</span><br><span class="line">&gt;&#x3D;         np.greater_equal    大于等于</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">y = np.array([<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">print(<span class="string">&quot;x==y&quot;</span>, x==y)</span><br><span class="line">print(<span class="string">&quot;x!=y&quot;</span>, x!=y)</span><br><span class="line">print(<span class="string">&quot;x&lt;y&quot;</span>, x&lt;y)</span><br><span class="line">print(<span class="string">&quot;x&lt;=y&quot;</span>, x&lt;=y)</span><br><span class="line">print(<span class="string">&quot;x&gt;y&quot;</span>, x&gt;y)</span><br><span class="line">print(<span class="string">&quot;x&gt;=y&quot;</span>, x&gt;=y) </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">x==y [ True False False]</span></span><br><span class="line"><span class="string">x!=y [False  True  True]</span></span><br><span class="line"><span class="string">x&lt;y [False  True False]</span></span><br><span class="line"><span class="string">x&lt;=y [ True  True False]</span></span><br><span class="line"><span class="string">x&gt;y [False False  True]</span></span><br><span class="line"><span class="string">x&gt;=y [ True False  True]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>由于python中的布尔运算使用<code>and/or/not</code>关键字，因此它们无法被重载。NumPy提供的数组布尔运算只能通过通用函数进行，这些函数以<code>logical_</code>开头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ufunc函数            描述</span><br><span class="line">np.logical_and       与</span><br><span class="line">np.logical_or        或</span><br><span class="line">np.logical_not       非</span><br><span class="line">np.logical_xor       异或</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>])</span><br><span class="line">y = np.array([<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>])</span><br><span class="line">print(<span class="string">&quot;与&quot;</span>, np.logical_and(x,y))</span><br><span class="line">print(<span class="string">&quot;或&quot;</span>, np.logical_or(x,y))</span><br><span class="line">print(<span class="string">&quot;非&quot;</span>, np.logical_not(x)) <span class="comment"># 一元函数</span></span><br><span class="line">print(<span class="string">&quot;异或&quot;</span>, np.logical_xor(x,y))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">与 [False  True False]</span></span><br><span class="line"><span class="string">或 [ True  True False]</span></span><br><span class="line"><span class="string">非 [ True False  True]</span></span><br><span class="line"><span class="string">异或 [ True False False]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>NumPy支持位运算符号，且其位运算的通用函数以<code>bitwise_</code>开头。<br>注意，位运算符的优先级 高于 比较运算符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运算符     ufunc函数            描述</span><br><span class="line">&amp;         np.bitwise_and       按位与</span><br><span class="line">|         np.bitwise_or        按位或</span><br><span class="line">~         np.bitwise_not       按位取反</span><br><span class="line">^         np.bitwise_xor       按位异或</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>])</span><br><span class="line">y = np.array([<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>])</span><br><span class="line">print(<span class="string">&quot;x&amp;y&quot;</span>, x&amp;y)</span><br><span class="line">print(<span class="string">&quot;x|y&quot;</span>, x|y)</span><br><span class="line">print(<span class="string">&quot;~x&quot;</span>, ~x) <span class="comment"># 等价于 -(x+1)</span></span><br><span class="line">print(<span class="string">&quot;x^y&quot;</span>, x^y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">x&amp;y [0 2 0]</span></span><br><span class="line"><span class="string">x|y [1 3 0]</span></span><br><span class="line"><span class="string">~x [-1 -3 -1]</span></span><br><span class="line"><span class="string">x^y [1 1 0]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="自定义通用函数"><a href="#自定义通用函数" class="headerlink" title="自定义通用函数"></a>自定义通用函数</h4><p>有时我们要按照自己的需求，对数组中每一个元素进行处理，这就需要自定义通用函数了。</p>
<p><code>np.frompyfunc(func,nin,nout)</code>：生成一个自定义的通用函数，数组中每个元素用func计算。func计算单个元素的函数，nin是func的输入参数的个数，nout是func返回值的个数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x, n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x**n</span><br><span class="line"></span><br><span class="line">my_func = np.frompyfunc(func, <span class="number">2</span>, <span class="number">1</span>) <span class="comment"># 2个输入，1个输出</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">my_func(x, <span class="number">2</span>) <span class="comment"># 计算 x的平方</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([1, 4, 9], dtype=object)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x, n1, n2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x**n1,x**n2</span><br><span class="line"></span><br><span class="line">my_func = np.frompyfunc(func, <span class="number">3</span>, <span class="number">2</span>) <span class="comment"># 3个输入，2个输出</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">my_func(x, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 计算 x的2次方和3次方</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(array([1, 4, 9], dtype=object), array([1, 8, 27], dtype=object))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="通用函数的方法"><a href="#通用函数的方法" class="headerlink" title="通用函数的方法"></a>通用函数的方法</h4><p>通用函数对象本身还有一些方法，这些方法只对于两个输入、一个输出的ufunc函数函数有效。对于其他的ufunc函数对象调用这些方法时，会抛出ValueError异常。</p>
<p>Python中的reduce把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是<code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code>。</p>
<p><code>ufunc.reduce(array,axis=0,dtype=None)</code>：类似于Python的reduce函数，它沿着axis参数指定的轴，对数组进行操作。相当于将ufunc运算符插入到沿着axis轴的所有元素之间。每经过一次reduce，结果数组的维度降低一维。<br><code>ufunc.accumulate(array,axis=0,dtype=None)</code>：它类似于reduce()的计算过程，但是它会<strong>保存所有的中间计算结果</strong>，从而使得<strong>返回数组的形状和输入数组的形状相同</strong>。<br><code>ufunc.outer(A,B)</code>：相当于将ufunc运算符对输入数组A和输入数组B的每一对元素对<code>(a,b)</code>起作用。结果数组维度为A和B维度拼接，设A的shape=(2,3)，B的shape为(1,3)，则结果数组的shape=(2,3,1,3)。<br><code>ufunc.at(a, indices, b=None)</code>：按索引修改数组，重复索引会再次计算，就地修改a。indices索引列表，b操作数。按照索引列表对数组进行ufunc运算，操作数是b。<br><code>ufunc.reduceat(array, indices, axis=0, dtype=None, out=None)</code>：同reduce。但按照指定索引切片（两两一组作为索引切片）进行操作，重复索引会再次计算，非就地修改。</p>
<div class="tabs" id="reduce"><ul class="nav-tabs"><li class="tab active"><a href="#reduce-1">reduce/accumulate</a></li><li class="tab"><a href="#reduce-2">outer</a></li><li class="tab"><a href="#reduce-3">at/reduceat</a></li></ul><div class="tab-content"><div class="tab-pane active" id="reduce-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">              [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">np.add.reduce(x, axis=<span class="number">0</span>) <span class="comment"># 0轴，结果是一行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([5, 7, 9])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.add.reduce(x, axis=<span class="number">1</span>) <span class="comment"># 1轴，结果是一列</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([ 6, 15])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.add.accumulate(x, axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[1, 2, 3],</span></span><br><span class="line"><span class="string">       [5, 7, 9]], dtype=int32)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.add.accumulate(x, axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[ 1,  3,  6],</span></span><br><span class="line"><span class="string">       [ 4,  9, 15]], dtype=int32)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="reduce-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">              [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]) <span class="comment"># (2,3)</span></span><br><span class="line">y = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># (3,)</span></span><br><span class="line"></span><br><span class="line">np.add.outer(x, y).shape</span><br><span class="line">np.add.outer(x, y)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(2, 3, 3)</span></span><br><span class="line"><span class="string">array([[[2, 3, 4],</span></span><br><span class="line"><span class="string">        [3, 4, 5],</span></span><br><span class="line"><span class="string">        [4, 5, 6]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       [[5, 6, 7],</span></span><br><span class="line"><span class="string">        [6, 7, 8],</span></span><br><span class="line"><span class="string">        [7, 8, 9]]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="reduce-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">np.add.at(x, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>], <span class="number">1</span>) <span class="comment"># 重复索引会被再次计算，而且就地修改 x</span></span><br><span class="line">x</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([1, 3, 3, 4, 4, 5, 6, 7])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">np.add.reduceat(x,[<span class="number">0</span>,<span class="number">4</span>, <span class="number">1</span>,<span class="number">5</span>, <span class="number">2</span>,<span class="number">6</span>, <span class="number">3</span>,<span class="number">7</span>]) </span><br><span class="line">np.add.reduceat(x,[<span class="number">0</span>,<span class="number">4</span>, <span class="number">1</span>,<span class="number">5</span>, <span class="number">2</span>,<span class="number">6</span>, <span class="number">3</span>,<span class="number">7</span>])[::<span class="number">2</span>] <span class="comment"># 和 accumulate 类似</span></span><br><span class="line">x <span class="comment"># 非就地修改</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([ 6,  4, 10,  5, 14,  6, 18,  7], dtype=int32)</span></span><br><span class="line"><span class="string">array([ 6, 10, 14, 18], dtype=int32)</span></span><br><span class="line"><span class="string">array([0, 1, 2, 3, 4, 5, 6, 7])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="统计运算"><a href="#统计运算" class="headerlink" title="统计运算"></a>统计运算</h3><h4 id="顺序统计-均值方差"><a href="#顺序统计-均值方差" class="headerlink" title="顺序统计/均值方差"></a>顺序统计/均值方差</h4><p>面对大量的数据时，第一个步通常都是计算相关数据的概括统计值。如均值、标准差、求和、乘积、中位数、最小值和最大值、分位数等等。<br>NumPy中大多数的聚合都有对 NaN 值的安全处理策略（NaN-safe），即计算时<strong>忽略所有的缺失值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ufunc函数         NaN-safe版本         描述</span><br><span class="line">np.sum            np.nansum        计算元素的和</span><br><span class="line">np.prod           np.nanprod       计算元素的积</span><br><span class="line">np.mean           np.nanmean       计算元素的平均值</span><br><span class="line">np.std            np.nanstd        计算元素的标准差</span><br><span class="line">np.var            np.nanvar        计算元素的方差</span><br><span class="line">np.min            np.nanmin        找出最小值</span><br><span class="line">np.max            np.nanmax        找出最大值</span><br><span class="line">np.argmin         np.nanargmin     找出最小值的索引</span><br><span class="line">np.argmax         np.nanargmax     找出最大值的索引</span><br><span class="line">np.median         np.nanmedian     计算元素的中位数</span><br><span class="line">np.percentile     np.nanpercentile 计算基于元素排序的统计值</span><br><span class="line">np.cumsum         np.nancumsum     计算累计求和，保存所有的中间计算结果</span><br><span class="line">np.cumprod        np.nancumprod    计算累计乘积，保存所有的中间计算结果</span><br><span class="line">np.count_nonzero  N&#x2F;A              统计非零（True）元素个数</span><br><span class="line">np.ptp            N&#x2F;A              计算指定轴的最大值减去最小值</span><br><span class="line">np.average        N&#x2F;A              计算元素的加权平均数</span><br><span class="line">np.minimum(x,y)   N&#x2F;A              返回两个数组x和y对应位置的最小值</span><br><span class="line">np.maximum(x,y)   N&#x2F;A              返回两个数组x和y对应位置的最大值</span><br><span class="line">np.any            N&#x2F;A              验证任何一个元素是否为真</span><br><span class="line">np.all            N&#x2F;A              验证所有元素是否为真</span><br></pre></td></tr></table></figure>
<div class="note info"><p>这些聚合函数有两点注意：<br>（1）默认结果是标量，即按多维数组的整体计算；如果指定axis，则按指定的计算得出结果。<br>（2）可以直接写条件表达式（布尔数组作为掩码，在后面会讲）。</p>
</div>
<p>以上聚合函数的通用参数：<br>（1）<code>axis</code>：可以为int或者tuple或者None。None将数组展平，在整个数组上操作。int数组在指定轴线上操作。tuple数组在指定的一组轴线上操作。<br>（2）<code>out</code>：可选的输出位置。必须与期望的结果形状相同。<br>（3）<code>keepdims</code>：如果为True，则结果数组的维度与原数组相同，从而可以与原数组进行广播运算。</p>
<p><code>np.any(x)</code>：只要数组中有一个元素为True（如果数值类型，则为非零，nan也为非零值），则结果就返回True；否则返回False。<br><code>np.all(x)</code>：只有数组中所有元素都为True（如果数值类型，则为非零，nan也为非零值），则结果才返回True；否则返回False。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">0</span>,      <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">              [np.nan, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>,      <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 默认</span></span><br><span class="line">np.<span class="built_in">any</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定axis</span></span><br><span class="line">np.<span class="built_in">any</span>(x,axis=<span class="number">0</span>) <span class="comment">#0轴，结果为一行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;array([ True,  True,  True])&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">np.<span class="built_in">any</span>([x,axis=<span class="number">1</span>) <span class="comment">#1轴，结果为一列</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;array([False,  True,  True])&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y = np.array([[<span class="number">0</span>,      <span class="number">9</span>, <span class="number">0</span>],</span><br><span class="line">              [np.nan, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">              [<span class="number">0</span>,      <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="comment"># 写条件表达式</span></span><br><span class="line">np.<span class="built_in">any</span>(y == <span class="number">9</span>, axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([False,  True, False])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.<span class="built_in">any</span>(y == <span class="number">9</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([ True, False, False])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>偏样本方差biased sample variance。计算公式为（$\bar{x}$ 为均值）：$\text{var=}\frac{1}{N} \sum\limits_{i=1}^{N} (x_i-\bar{x})^2$<br>无偏样本方差unbiased sample variance。计算公式为（$\bar{x}$ 为均值）：$\text{var=}\frac{1}{N-1} \sum\limits_{i=1}^{N} (x_i-\bar{x})^2$<br><code>np.var(a[, axis, dtype, out, ddof, keepdims])</code>：默认ddof=0计算偏样本方差；ddof=1计算无偏样本方差；ddof为其他整数时，分母就是N-ddof。</p>
<h4 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h4><p><code>np.corrcoef(x[, y, rowvar, bias, ddof])</code>: 返回皮尔逊积差相关。<br><code>np.correlate(a, v[, mode])</code>：返回两个一维数组的互相关系数。<br><code>np.cov(m[, y, rowvar, bias, ddof, fweights, ...])</code>：返回协方差矩阵。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">-2.1</span>, <span class="number">-1</span>,  <span class="number">4.3</span>]</span><br><span class="line">y = [<span class="number">3</span>,  <span class="number">1.1</span>,  <span class="number">0.12</span>]</span><br><span class="line">X = np.stack((x, y), axis=<span class="number">0</span>)</span><br><span class="line">X</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[-2.1 , -1.  ,  4.3 ],</span></span><br><span class="line"><span class="string">       [ 3.  ,  1.1 ,  0.12]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.cov(X) <span class="comment"># 等价于 np.cov(x, y)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[11.71      , -4.286     ],</span></span><br><span class="line"><span class="string">       [-4.286     ,  2.14413333]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>对于排序操作，例如，一个简单的选择排序重复寻找列表中的最小值，并且不断交换直到列表是有序的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        swap = i + np.argmin(x[i:])</span><br><span class="line">        (x[i], x[swap]) = (x[swap], x[i])</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">selection_sort(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([1, 2, 3, 4, 5])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>对于一个包含 N 个值的数组来说，它需要做 N 个循环，每个循环中执行最多 N 次比较，以找到交换值，时间复杂度是$O(N^2)$，这完全不行！</p>
<p>幸运的是， Python 包含的很多内置排序函数都比上面例子中的算法高效得多。但 NumPy 的排序函数实际上效率比 Python 更高。</p>
<p><strong>1、Python内置排序算法</strong><br>Python中内置有两个排序：<br><code>L.sort(key=None, reverse=False)</code>：列表排序，就地修改原数据。key函数来实现自定义的排序。reverse=False升序（默认）。<br><code>sorted(iterable, key=None, reverse=False)</code>：可迭代对象排序，返回新列表。key自定义排序函数。reverse=False升序（默认）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>]</span><br><span class="line">l.sort()</span><br><span class="line">l</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[5, 9, -12, -21, 36]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=<span class="built_in">abs</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[5, 9, -12, -21, 36]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br><strong>2、NumPy排序算法</strong><br><code>np.sort(a, axis=-1, kind=&#39;quicksort&#39;, order=None)</code>：返回a在指定轴（默认最后一个轴）上排序后的结果，<strong>并不修改原数组</strong>。<br><code>np.argsort(a, axis=-1, kind=&#39;quicksort&#39;, order=None)</code>：返回a在指定轴上（默认最后一个轴）排序之后的下标（对应于数组划分之前的位置）。<br>（1）axis：axis=None扁平化后排序。默认axis=-1，按最后一个轴最后一排数值排序。<br>（1）kind：字符串指定排序算法，可以为<code>quicksort</code>(快速排序)，<code>mergesort</code>(归并排序)，<code>heapsort</code>(堆排序)，<code>timsort</code>(归并+插入混合排序)。<br>（2）order：在结构化数组排序中，用于设置排序的字段（一个字符串）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>],</span><br><span class="line">              [<span class="number">4</span>, <span class="number">5</span>,  <span class="number">3</span>],</span><br><span class="line">              [<span class="number">3</span>, <span class="number">4</span>,  <span class="number">2</span>]])</span><br><span class="line">x</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[ 1,  0, -1],</span></span><br><span class="line"><span class="string">       [ 4,  5,  3],</span></span><br><span class="line"><span class="string">       [ 3,  4,  2]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.sort(x) <span class="comment"># 最后一个轴是 1 ，等价于np.sort(x, axis=1)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[-1,  0,  1],</span></span><br><span class="line"><span class="string">       [ 3,  4,  5],</span></span><br><span class="line"><span class="string">       [ 2,  3,  4]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.sort(x, axis=<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[ 1,  0, -1],</span></span><br><span class="line"><span class="string">       [ 3,  4,  2],</span></span><br><span class="line"><span class="string">       [ 4,  5,  3]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br><strong>3、部分排序</strong><br>有时候不希望全部排序，只需要进行部分排序。<br><code>np.partition(a, kth, axis=-1, kind=&#39;introselect&#39;, order=None)</code>：它将数组执行划分操作：第 kth 位左侧的数都小于第 kth 位的数；第 kth 位右侧的数都大于等于第 kth 位的数。它返回划分之后的数组，两侧都是无序的。<br><code>np.argpartition(a, kth, axis=-1, kind=&#39;introselect&#39;, order=None)</code>：返回执行划分之后的下标（对应于数组划分之前的位置）。</p>
<p>比如，找出数组中前K小的值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line">np.partition(x, <span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([2, 1, 3, 4, 6, 5, 7])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>比如，计算二维平面有n个随机点，求每个点的最近 k 个点：</p>
<div class="tabs" id="s"><ul class="nav-tabs"><li class="tab active"><a href="#s-1">简略过程</a></li><li class="tab"><a href="#s-2">求距离详细过程</a></li></ul><div class="tab-content"><div class="tab-pane active" id="s-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>) <span class="comment"># 3个点测试</span></span><br><span class="line">x</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[0, 1],</span></span><br><span class="line"><span class="string">       [2, 3],</span></span><br><span class="line"><span class="string">       [4, 5]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 两点间距离的平方等于每个维度的距离差的平方的和</span></span><br><span class="line">dist_sq = np.<span class="built_in">sum</span>((x[:,np.newaxis,:] - x[np.newaxis,:,:]) ** <span class="number">2</span>, axis=<span class="number">-1</span>)</span><br><span class="line">dist_sq </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[ 0,  8, 32],</span></span><br><span class="line"><span class="string">       [ 8,  0,  8],</span></span><br><span class="line"><span class="string">       [32,  8,  0]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 沿着每行进行排序</span></span><br><span class="line">np.argsort(dist_sq, axis=<span class="number">-1</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[0, 1, 2],</span></span><br><span class="line"><span class="string">       [1, 0, 2],</span></span><br><span class="line"><span class="string">       [2, 1, 0]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 仅关心 k 个最近邻，那么唯一需要做的是分隔每一行，这样最小的 k + 1 的平方距离将排在最前面（除去自己）</span></span><br><span class="line">K = <span class="number">1</span></span><br><span class="line">nearest_partition = np.argpartition(dist_sq, K + <span class="number">1</span>, axis=<span class="number">1</span>)</span><br><span class="line">nearest_partition</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[0, 1, 2],</span></span><br><span class="line"><span class="string">       [1, 0, 2],</span></span><br><span class="line"><span class="string">       [2, 1, 0]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">K = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> nearest_partition[i, K:K+<span class="number">1</span>]: <span class="comment"># 出自己外的点</span></span><br><span class="line">    <span class="comment"># 找出每个点的 K 个最近的点</span></span><br><span class="line">    x[j], x[i]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[2, 3]])</span></span><br><span class="line"><span class="string">array([[0, 1]])</span></span><br><span class="line"><span class="string">array([[2, 3]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 将每个点与它的一个最近邻连接</span></span><br><span class="line">K = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x.shape[<span class="number">0</span>]): <span class="comment"># 每个点</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> nearest_partition[i, <span class="number">1</span>:K+<span class="number">1</span>]: <span class="comment"># 每列第一个点排除（自己本身）</span></span><br><span class="line">        print(x[j], x[i])</span><br><span class="line">        <span class="comment"># 画出K近的点，plot线段的坐标用zip方法实现：</span></span><br><span class="line">        <span class="comment">#plt.plot(*zip(x[j], x[i]), color=&#x27;black&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[2 3] [0 1]   # 线段是 最近点[2 3] 到 本点[0 1]</span></span><br><span class="line"><span class="string">[0 1] [2 3]   # 线段是 最近点[0 1] 到 本点[2 3]</span></span><br><span class="line"><span class="string">[2 3] [4 5]   # 线段是 最近点[2 3] 到 本点[4 5]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="s-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">x[:,np.newaxis,:].shape</span><br><span class="line">x[:,np.newaxis,:]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(3, 1, 2)</span></span><br><span class="line"><span class="string">array([[[0, 1]],</span></span><br><span class="line"><span class="string">       [[2, 3]],</span></span><br><span class="line"><span class="string">       [[4, 5]]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">x[np.newaxis,:,:].shape</span><br><span class="line">x[np.newaxis,:,:]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(1, 3, 2)</span></span><br><span class="line"><span class="string">array([[[0, 1],</span></span><br><span class="line"><span class="string">        [2, 3],</span></span><br><span class="line"><span class="string">        [4, 5]]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 广播</span></span><br><span class="line">np.broadcast_arrays(a[:,np.newaxis,:],a[np.newaxis,:,:]) </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[array([[[0, 1],</span></span><br><span class="line"><span class="string">         [0, 1],</span></span><br><span class="line"><span class="string">         [0, 1]],</span></span><br><span class="line"><span class="string">        [[2, 3],</span></span><br><span class="line"><span class="string">         [2, 3],</span></span><br><span class="line"><span class="string">         [2, 3]],</span></span><br><span class="line"><span class="string">        [[4, 5],</span></span><br><span class="line"><span class="string">         [4, 5],</span></span><br><span class="line"><span class="string">         [4, 5]]]), </span></span><br><span class="line"><span class="string"> array([[[0, 1],</span></span><br><span class="line"><span class="string">         [2, 3],</span></span><br><span class="line"><span class="string">         [4, 5]],</span></span><br><span class="line"><span class="string">        [[0, 1],</span></span><br><span class="line"><span class="string">         [2, 3],</span></span><br><span class="line"><span class="string">         [4, 5]],</span></span><br><span class="line"><span class="string">        [[0, 1],</span></span><br><span class="line"><span class="string">         [2, 3],</span></span><br><span class="line"><span class="string">         [4, 5]]])]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">differences = x[:,np.newaxis,:] - x[np.newaxis,:,:]</span><br><span class="line">differences.shape</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[[ 0,  0],</span></span><br><span class="line"><span class="string">        [-2, -2],</span></span><br><span class="line"><span class="string">        [-4, -4]],</span></span><br><span class="line"><span class="string">       [[ 2,  2],</span></span><br><span class="line"><span class="string">        [ 0,  0],</span></span><br><span class="line"><span class="string">        [-2, -2]],</span></span><br><span class="line"><span class="string">       [[ 4,  4],</span></span><br><span class="line"><span class="string">        [ 2,  2],</span></span><br><span class="line"><span class="string">        [ 0,  0]]])</span></span><br><span class="line"><span class="string">(3, 3, 2)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 求出差值的平方</span></span><br><span class="line">sq_differences = differences ** <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[[ 0,  0],</span></span><br><span class="line"><span class="string">        [ 4,  4],</span></span><br><span class="line"><span class="string">        [16, 16]],</span></span><br><span class="line"><span class="string">       [[ 4,  4],</span></span><br><span class="line"><span class="string">        [ 0,  0],</span></span><br><span class="line"><span class="string">        [ 4,  4]],</span></span><br><span class="line"><span class="string">       [[16, 16],</span></span><br><span class="line"><span class="string">        [ 4,  4],</span></span><br><span class="line"><span class="string">        [ 0,  0]]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 将差值求和获得平方距离</span></span><br><span class="line">dist_sq = sq_differences.<span class="built_in">sum</span>(<span class="number">-1</span>)</span><br><span class="line">dist_sq</span><br><span class="line">dist_sq.shape</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([[ 0,  8, 32],</span></span><br><span class="line"><span class="string">       [ 8,  0,  8],</span></span><br><span class="line"><span class="string">       [32,  8,  0]])</span></span><br><span class="line"><span class="string">(3, 3)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div></div>
<p>其他的排序：<br><code>np.lexsort(keys, axis=-1)</code>：按照给出的keys升序排序，返回排序后的索引。<br>（1）如果keys为一维数组的元组，则将这些一维数组当作行向量拼接成二维数组并按照数组来操作。<br>（2）如果keys为数组，则根据数组的最后一个轴的最后一排数值排列，并返回这些轴的排列顺序。如数组a的shape=(4,5)，则根据a最后一个轴的最后一排元素排列。这里axis指定排序的轴。对于argsort，会在最后一个轴的每一排进行排列，并返回一个与a形状相同的数组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>] <span class="comment"># 第一列</span></span><br><span class="line">b = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">0</span>] <span class="comment"># 第二列</span></span><br><span class="line">np.lexsort((b,a)) <span class="comment"># 先按照a排序（排序后下标(0,2,1)），遇到相同的（排序后下标(0,2)），再按照b排序（排序后下标(2,0,1)）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([2, 0, 1], dtype=int64)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br><code>np.searchsorted(a, v, side=&#39;left&#39;, sorter=None)</code>：返回的是v应该插入的位置，要求a是个已排序好的一维数组。本函数尝试将v插入到a中，从而使得数组a维持一个排序好的数组。side指定若发现数值相等时，插入左侧left还是右侧right。<br>（1）如果你想一次插入多个数值，可以将v设置为列表或者数组。<br>（2）如果sorter=None，则要求a已排序好。如果a未排序，则要求传入一个一维数组或者列表，它给出了a的升序排列的下标（通常他就是argsort的结果）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np.searchsorted([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.searchsorted([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">3</span>, side=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.searchsorted([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">-10</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">array([0, 5, 1, 2])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h4><p><code>np.unique(ar, return_index=False, return_inverse=False, return_counts=False)</code>：返回ar中所有不同的值组成的一维数组。如果ar不是一维的，则展平为一维。<br>（1）return_index：如果为True，则同时返回这些独一无二的数值在原始数组中的下标。<br>（2）return_inverse：如果为True，则返回元素数组的值在新返回数组中的下标（从而可以重建元素数组）。<br>（3）return_counts：如果为True，则返回每个独一无二的值在原始数组中出现的次数。</p>
<p><code>np.histogram(a, bins=10, range=None, normed=False, weights=None, density=None)</code>：计算一组数据的直方图。如果a不是一维的，则展平为一维。<br>（1）bins：指定了统计的区间个数（即统计范围的等分数）。可指定统计方法<code>auto</code>,<code>fd</code>,<code>doane</code>,<code>scott</code>,<code>rice</code>,<code>sturges</code>,<code>sqrt</code>，此时统计区间的个数将通过计算自动得出。<br>（2）range：是个长度为2的元组，表示统计范围的最小值和最大值（默认时，表示范围为数据的最小值和最大值）。<br>（3）density：False时，返回a中数据在每个区间的个数；否则返回a中数据在每个区间的频率。normed和density相同，被废弃。<br>（4）weights：设置了a中每个元素的权重，如果设置了该参数，则计数时考虑权重。它返回的是一个元组，第一个元素给出了每个直方图的计数值，第二个元素给出了直方图的统计区间的从左到右的各个闭合点 （比计数值的数量多一个）。<br><code>np.histogram2d(x, y, bins=10, range=None, normed=False, weights=None)</code>：计算两组数据的二维直方图。<br><code>np.histogramdd(sample, bins=10, range=None, normed=False, weights=None)</code>：计算多维数据的直方图。</p>
<p><code>np.bincount(x[, weights, minlength])</code>：计算每个数出现的次数，要求数组中所有元素都是非负的。其返回数组中第i个元素表示：整数i在x中出现的次数。要求x必须一维数组，否则报错。<br>（1）weights：设置了x中每个元素的权重，如果设置了该参数，则计数时考虑权重。<br>（2）minlength：指定结果的一维数组最少多长（如果未指定，则由x中最大的数决定）。</p>
<p><code>np.digitize(x, bins, right=False)</code>：离散化。如果x不是一维的，则展平为一维。它返回一个数组，该数组中元素值给出了x中的每个元素将对应于统计区间的哪个区间。<br>（1）区间由bins这个一维数组指定，它依次给出了统计区间的从左到右的各个闭合点。<br>（2）right为True，则表示统计区间为左开右闭合(]；为False，则表示统计区间为左闭合右开[)。</p>
<h4 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h4><p><code>np.where(condition[, x, y])</code>：它类似于python的<code>x if condition else y</code>。condition/x/y都是数组，要求形状相同或者通过广播之后形状相同，结果数组的形状为广播之后的形状。产生结果的方式为：如果condition某个元素为True或者非零，则对应的结果元素从x中获取；否则对应的结果元素从y中获取。</p>
<p><code>np.select(condlist, choicelist, default=0)</code>：如果分段数量增加，则需要嵌套多层的where，可以使用select代替多次where。<br>（1）condlist为长度为 N 的列表，列表元素为数组，给出了条件数组。<br>（2）choicelist为长度为N的列表，列表元素为数组，给出了结果被选中的候选值。<br>结果筛选规则如下：<br>（1）从condlist左到右扫描，若发现第 i 个元素（是个数组）对应位置为True或者非零，则输出元素来自choicelist 的第 i 个元素（是个数组）。因此若有多个condlist的元素满足，则只会使用第一个遇到的。<br>（2）如果扫描结果是都不满足，则使用default。</p>
<p>采用where/select时，所有的参数需要在调用它们之前完成。在计算时还会产生许多保存中间结果的数组。因此如果输入数组很大，则将会发生大量内存分配和释放。为此numpy提供了piecewise函数：<br><code>np.piecewise(x, condlist, funclist, *args, **kw)</code>：<br>（1）x：为分段函数的自变量取值数组。<br>（2）condlist：为一个列表，列表元素为布尔数组，数组形状和x相同。<br>（3）funclist：为一个列表，列表元素为函数对象。其长度与condlist相同或者比它长1。当condlist[i]对应位置为True时，则该位置处的输出值由funclist[i]来计算。如果funclist长度比condlist长1，则当所有的condlist都是False时，则使用funclist[len(condlist)]来计算。如果有多个符合条件，则使用最后一个遇到的（而不是第一个遇到的）；列表元素可以为数值，表示一个返回为常数值（就是该数值）的函数。<br>（4）args/kw：用于传递给函数对象funclist[i]的额外参数。</p>
<h4 id="内积、外积、张量积"><a href="#内积、外积、张量积" class="headerlink" title="内积、外积、张量积"></a>内积、外积、张量积</h4><p><code>np.dot(a, b, out=None)</code>：计算矩阵的乘积。对于一维数组，他计算的是内积；对于二维数组，他计算的是线性代数中的矩阵乘法。<br><code>np.vdot(a, b)</code>：返回一维向量之间的点积。如果a和b是多维数组，则展平成一维再点积。<br><code>np.inner(a, b)</code>：计算矩阵的内积。对于一维数组，它计算的是向量点积；对于多维数组，则它计算的是：每个数组最后轴作为向量，由此产生的内积。<br><code>np.outer(a, b, out=None)</code>：计算矩阵的外积。它始终接收一维数组。如果是多维数组，则展平成一维数组。<br><code>np.tensordot(a, b, axes=2)</code>：计算张量乘积。axes如果是个二元序列，则第一个元素表示a中的轴，第二个元素表示b中的轴。将这两个轴上元素相乘之后求和。其他轴不变；<br>axes如果是个整数，则表示把a中的后axes个轴和b中的前axes个轴进行乘积之后求和。其他轴不变。<br><code>np.cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None)</code>：计算两个向量之间的叉乘。叉积用于判断两个三维空间的向量是否垂直。要求a和b都是二维向量或者三维向量，否则抛出异常。当然它们也可以是二维向量的数组，或者三维向量的数组，此时一一叉乘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">np.dot是点乘(矩阵乘法)</span><br><span class="line">|A B| . |E F| &#x3D; |A*E+B*G A*F+B*H|</span><br><span class="line">|C D|   |G H|   |C*E+D*G C*F+D*H|</span><br><span class="line"></span><br><span class="line">np.multiply是逐元素乘法</span><br><span class="line">|A B| ⊙ |E F| &#x3D; |A*E B*F|</span><br><span class="line">|C D|   |G H|   |C*G D*H|</span><br></pre></td></tr></table></figure>
<h4 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h4><p><code>np.linalg.inv(a)</code>：获取a的逆矩阵。如果传入的是多个矩阵，则依次计算这些矩阵的逆矩阵。如果a不是方阵，或者a不可逆则抛出异常。<br><code>np.eye(N[, M, k, dtype])</code>：返回一个二维单位矩阵行为N，列为M，对角线元素为1，其余元素为0。M默认等于N。k默认为0表示对角线元素为1（单位矩阵），如为正数则表示对角线上方一格的元素为1（上单位矩阵），如为负数表示对角线下方一格的元素为1（下单位矩阵）。<br><code>np.trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None)</code>：返回对角线的和。如果a是二维的，则直接选取对角线的元素之和（offsert=0），或者对角线右侧偏移offset的元素之和（即选取a[i,i+offset]之和）；如果a不止二维，则由axis1和axis2指定的轴选取了取对角线的矩阵；如果a少于二维，则抛出异常。<br><code>np.linalg.solve(a,b)</code>：计算线性方程的解ax=b，其中a为矩阵，要求为秩不为0的方阵，b为列向量（长度等于方阵大小）；或者a为标量，b也为标量。如果a不是方阵或者a是方阵但是行列式为0，则抛出异常。<br><code>np.linalg.eig(a)</code>：计算矩阵的特征值和右特征向量。如果不是方阵则抛出异常，如果行列式为0则抛出异常。<br><code>np.linalg.svd(a, full_matrices=1, compute_uv=1)</code>：返回u、s、v的元组。对矩阵a进行奇异值分解，将它分解成<code>u*np.diag(s)*v</code>的形式，其中u和v是酉矩阵，s是a的奇异值组成的一维数组。如果不可分解则抛出异常。<br>（1）full_matrics：如果为True，则u形状为(M,M)，v形状为(N,N)；否则u形状为(M,K)，v形状为(K,N)，K=min(M,N)。<br>（2）compute_uv：如果为True则表示要计算u和v。默认为True。<br><code>np.linalg.qr(a, mode=&#39;reduced&#39;)</code>：返回q、r元组。q是正交阵，r是三角阵。</p>
<h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><p>向量与矩阵(机器学习)：<br>0-范数: 矩阵中非0元素的个数。<br>1-范数：矩阵中绝对值的和。<br>2-范数：矩阵所有元素的平方和开方。  </p>
<p><code>np.linalg.norm(x, ord=None, axis=None, keepdims=False)</code>：ord指定几范数，计算方式分向量和矩阵。<br>x为向量时ord：<br>默认：$||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}$<br>0-范数: sum(x != 0)<br>1-范数：sum(abs(x))<br>2-范数：$||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}$</p>
<p>x为矩阵时ord：<br>默认：$||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}$<br>0-范数：没有定义<br>1-范数：max(sum(abs(x), axis=0))<br>2-范数：x*x.T的最大特征值的算术平方根  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵</span></span><br><span class="line">m = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">              [<span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>]])</span><br><span class="line">np.linalg.norm(m) <span class="comment"># 默认公式</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">14.177446878757825</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.linalg.norm(m,<span class="number">1</span>) <span class="comment"># 1-范数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">13.0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">np.linalg.norm(m,<span class="number">2</span>) <span class="comment"># 2-范数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">12.48588389883742</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="Numpy随机函数"><a href="#Numpy随机函数" class="headerlink" title="Numpy随机函数"></a>Numpy随机函数</h2><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p><code>np.random.rand(d0, d1, ..., dn)</code>：指定形状<code>(d0, d1, ..., dn)</code>创建一个随机的ndarray。每个元素值来自于半闭半开区间<code>[0,1)</code>并且服从均匀分布。要求<code>d0, d1, ..., dn</code>为整数。如果未提供参数，则返回一个随机的浮点数而不是ndarray。<br><code>np.random.randn(d0, d1, ..., dn)</code>：指定形状<code>(d0, d1, ..., dn)</code>创建一个随机的ndarray。每个元素值服从正态分布，其中正态分布的期望为0，方差为1。要求<code>d0, d1, ..., dn</code>为整数或者可以转换为整数。如果di为浮点数，则截断成整数。如果未提供参数，则返回一个随机的浮点数而不是ndarray。<br><code>np.random.randint(low[, high, size])</code>：返回一个随机的整数ndarray或者一个随机的整数值。如果high为None，则表示整数值都取自<code>[0,low)</code>且服从离散均匀分布。如果high给出了值，则表示整数值都取自<code>[low,high)</code>且服从离散均匀分布。size是一个整数的元组，指定了输出的ndarray的形状，如果为None则表示输出为单个整数值。<br><code>np.random.random_integers(low[, high, size])</code>：返回一个随机的整数ndarray或者一个随机的整数值。如果high为None，则表示整数值都取自<code>[1,low]</code>且服从离散均匀分布。如果high给出了值，则表示整数值都取自<code>[low,high]</code>且服从离散均匀分布。size是一个整数的元组，指定了输出的ndarray的形状，如果为None则表示输出为单个整数值。<br><code>np.random.random_sample([size])</code>：返回一个随机的浮点ndarray或者一个随机的浮点值，浮点值是<code>[0.0,1.0)</code>之间均匀分布的随机数。size为整数元组或者整数，指定结果ndarray的形状，如果为None则只输出单个浮点数。如果想生成<code>[a,b)</code>之间均匀分布的浮点数，那么你可以用<code>(b-a)*random_sample()+a</code>。如果size有效，它的效果等于<code>np.random.rand(*size)</code>，如果size无效，它的效果等于<code>np.random.rand()</code>。<br><code>np.random.random([size])</code>：等价于<code>np.random.random_sample([size])</code>。<br><code>np.random.ranf([size])</code>：等价于<code>np.random.random_sample([size])</code>。<br><code>np.random.sample([size])</code>：等价于<code>np.random.random_sample([size])</code>。<br><code>np.random.bytes(length)</code>：返回length长度的随机字节串。length指定字节长度。</p>
<p><code>np.random.choice(a[, size, replace, p])</code>：从一维数组中采样产生一组随机数或者一个随机数。<br>（1）a：为一位数组或者int，如果是int则采样数据由<code>np.arange(n)</code>提供，否则采样数据由a提供。<br>（2）size：为整数元组或者整数，指定结果ndarray的形状，如果为None则只输单个值。<br>（3）replace：如果为True则可以重复采样（有放回的采样）；如果为False，则采用不放回的采样。<br>（4）p：为一维数组，用于指定采样数组中每个元素值的采样概率，概率和应为1。如果为None则均匀采样。</p>
<h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><p><code>np.random.shuffle(x)</code>：就地随机混洗x的内容，返回None。如果x是个整数，则重排<code>np.arange(x)</code>；如果x是个数组，则直接进行混洗；如果x是个多维数组则只是混洗它的第0维。<br><code>np.random.permutation(x)</code>：随机重排x，返回重排后的ndarray。如果x是个整数，则重排<code>np.arange(x)</code>；如果x是个数组，则拷贝它然后对拷贝进行混洗；如果x是个多维数组则只是混洗它的第0维。</p>
<h3 id="概率分布函数"><a href="#概率分布函数" class="headerlink" title="概率分布函数"></a>概率分布函数</h3><p>共同参数size：size若非None，则它指定输出ndarray的形状；如果为None，则输出单个值。<br><code>np.random.dirichlet(alpha[, size])</code>：狄利克雷分布，alpha=$\alpha$是个数组。狄利克雷分布为：$p(x) \propto \prod_{i=1}^{k}{x^{\alpha_i-1}_i}$。<br><code>np.random.exponential([scale, size])</code>：指数分布，scale=$\beta$为浮点数。指数分布的概率密度函数为：$f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta})$。<br><code>np.random.geometric(p[, size])</code>：几何分布。其中p是单次试验成功的概率。几何分布为：$f(k) = (1 - p)^{k - 1} p$。<br><code>np.random.laplace([loc, scale, size])</code>：拉普拉斯分布。loc=$\mu$为浮点数，scale=$\lambda$为浮点数。$f(x; \mu, \lambda) = \frac{1}{2\lambda}\exp\left(-\frac{|x - \mu|}{\lambda}\right)$。<br><code>np.random.logistic([loc, scale, size])</code>：逻辑斯谛分布。其中loc=$\mu$为浮点数，scale=$s$为大于0的浮点数。$P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2}$<br><code>np.random.logseries(p[, size])</code>：对数分布，其中p为<code>[0.0,1.0]</code>之间的浮点数。$P(k) = \frac{-p^k}{k \ln(1-p)}$<br><code>np.random.normal([loc, scale, size])</code>:正态分布。其中loc=$\mu$为浮点数，scale=$\sigma$为浮点数。$p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} }$<br><code>np.random.poisson([lam, size])</code>：泊松分布。其中lam=$\lambda$为浮点数或者一个浮点序列，要大于等于0。$f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!}$<br><code>np.random.power(a[, size])</code>：幂级数分布。其中a为大于0的浮点数。$P(x; a) = ax^{a-1}, 0 \le x \le 1, a&gt;0$<br><code>np.random.uniform([low, high, size])</code>：均匀分布。其中low=$a$为浮点数；high=$b$为浮点数。$p(x) = \frac{1}{b - a}$<br><code>np.random.standard_exponential([size])</code>：标准指数分布。其中scale等于1。<br><code>np.random.standard_gamma(shape[, size])</code>：标准伽玛分布，其中scale等于1。<br><code>np.random.standard_normal([size])</code>：标准正态分布，其中mean=0，stdev等于1。<br><code>np.random.lognormal([mean, sigma, size])</code>：对数正态分布。其中mean=$\mu$为浮点数，sigma=$\sigma$为大于0的浮点数。$p(x) = \frac{1}{\sigma x \sqrt{2\pi}}e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})}$<br><code>np.random.hypergeometric(ngood, nbad, nsample[, size])</code>: 超几何分布。其中ngood=$n$为整数或者array_like，必须非负数；nbad=$m$为整数或者array_like，必须非负数，表示坏的选择；nsample=$N$为样本数量。$P(x) = \frac{\binom{m}{n}\binom{N-m}{n-x}}{\binom{N}{n}}, 0 \le x \le m , n+m-N \le x \le n$，P(x)为x成功的概率。<br><code>np.random.gamma(shape[, scale, size])</code>：伽玛分布。其中shape=$k$大于0的标量，表示分布的形状；scale=$\theta$大于0的标量，表示伽玛分布的scale（默认为1）。伽玛分布的概率密度函数为：$p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)}$。<br><code>np.random.f(dfnum, dfden[, size])</code>：F分布。dfnum为浮点数，应该大于0，是分子的自由度；dfden是浮点数，应该大于0，是分母的自由度。详情请参考<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRi1kaXN0cmlidXRpb24=">F-distribution<i class="fa fa-external-link-alt"></i></span>。<br><code>np.random.beta(a, b[, size])</code>：Beta分布。其中a,b都是Beta分布的参数，要求非负浮点数。$f(x; a,b) = \frac{1}{B(\alpha, \beta)} x^{\alpha - 1}(1 - x)^{\beta - 1},B(\alpha, \beta) = \int_0^1 t^{\alpha - 1}(1 - t)^{\beta - 1} dt$。<br><code>np.random.binomial(n, p[, size])</code>：二项分布。其中n,p都是二项分布的参数，要求n为大于等于0的浮点数，如果它为浮点数则截断为整数；p为<code>[0,1]</code>之间的浮点数。$P(N) = \binom{n}{N}p^N(1-p)^{n-N}$。<br><code>np.random.chisquare(df[, size])</code>：卡方分布。其中df为整数，是卡方分布的自由度（若小于等于0则抛出异常）。$p(x) = \frac{(1/2)^{k/2}}{\Gamma(k/2)}x^{k/2 - 1} e^{-x/2},\Gamma(x) = \int_0^{-\infty} t^{x - 1} e^{-t} dt$。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\04\20\Machine Learning\00.ML-机器学习？\" rel="bookmark">ML-机器学习？</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\06\10\Machine Learning\11.ML-数据分析\" rel="bookmark">ML-数据分析</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\09\20\Machine Learning\16.Introduction\" rel="bookmark">Introduction</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\09\28\Machine Learning\20.DimentionReduction\" rel="bookmark">DimentionReduction</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\09\21\Machine Learning\17.MathBasics\" rel="bookmark">MathBasics</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>SoundMemories
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://soundmemories.github.io/2020/04/22/Machine%20Learning/02.ML-NumPy/" title="ML-NumPy">https://soundmemories.github.io/2020/04/22/Machine Learning/02.ML-NumPy/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Machine-Learning/" rel="tag"><i class="fa fa-tag"></i> Machine Learning</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/04/21/Machine%20Learning/01.ML-IPython%E5%92%8CJupyter/" rel="prev" title="ML-IPython和Jupyter">
                  <i class="fa fa-chevron-left"></i> ML-IPython和Jupyter
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/04/25/Machine%20Learning/03.ML-Pandas/" rel="next" title="ML-Pandas">
                  ML-Pandas <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SoundMemories</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>








<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  








    <div class="pjax">
  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://soundmemories.github.io/2020/04/22/Machine%20Learning/02.ML-NumPy/',]
      });
      });
  </script>

    </div>
</body>
</html>
