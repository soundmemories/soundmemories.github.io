<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"soundmemories.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":true,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="基础题557. 反转字符串中的单词 III难度：简单题目链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;reverse-words-in-a-string-iii&#x2F;题目描述：给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。示例 1：输入：s &#x3D; &quot;Let&#39;s take LeetCode contest&quot;">
<meta property="og:type" content="article">
<meta property="og:title" content="算法题">
<meta property="og:url" content="https://soundmemories.github.io/2022/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/index.html">
<meta property="og:site_name" content="SoundMemories">
<meta property="og:description" content="基础题557. 反转字符串中的单词 III难度：简单题目链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;reverse-words-in-a-string-iii&#x2F;题目描述：给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。示例 1：输入：s &#x3D; &quot;Let&#39;s take LeetCode contest&quot;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-30T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-28T08:57:02.557Z">
<meta property="article:author" content="SoundMemories">
<meta property="article:tag" content="Other">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://soundmemories.github.io/2022/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法题 | SoundMemories</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SoundMemories</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
	   
		  
      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">基础题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-III"><span class="nav-number">1.1.</span> <span class="nav-text">557. 反转字符串中的单词 III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#859-%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.</span> <span class="nav-text">859. 亲密字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#020-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">1.3.</span> <span class="nav-text">020. 有效的括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">021. 合并两个有序链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">1290. 二进制链表转整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#082-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="nav-number">1.6.</span> <span class="nav-text">082. 删除排序链表中的重复元素 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">1.7.</span> <span class="nav-text">160. 相交链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-I"><span class="nav-number">1.8.</span> <span class="nav-text">002. 两数相加 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="nav-number">1.9.</span> <span class="nav-text">445. 两数相加 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.10.</span> <span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">1.11.</span> <span class="nav-text">092. 反转链表 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#025-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.12.</span> <span class="nav-text">025. K 个一组翻转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">1.13.</span> <span class="nav-text">138. 复制带随机指针的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">1.14.</span> <span class="nav-text">560. 和为 K 的子数组(前缀和)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F-%E9%80%92%E5%BD%92"><span class="nav-number">1.15.</span> <span class="nav-text">969. 煎饼排序(递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98-%E9%80%92%E5%BD%92"><span class="nav-number">1.16.</span> <span class="nav-text">汉诺塔问题(递归)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0"><span class="nav-number">1.17.</span> <span class="nav-text">204. 计数质数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.18.</span> <span class="nav-text">912. 排序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">1.19.</span> <span class="nav-text">215. 数组中的第K个最大元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.20.</span> <span class="nav-text">148. 排序链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="nav-number">2.1.</span> <span class="nav-text">146. LRU 缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#460-LFU-%E7%BC%93%E5%AD%98"><span class="nav-number">2.2.</span> <span class="nav-text">460. LFU 缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">341. 扁平化嵌套列表迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#855-%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7"><span class="nav-number">2.4.</span> <span class="nav-text">855. 考场就座</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number">3.1.</span> <span class="nav-text">100. 相同的树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.2.</span> <span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.3.</span> <span class="nav-text">617. 合并二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">3.4.</span> <span class="nav-text">104. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.5.</span> <span class="nav-text">110. 平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.6.</span> <span class="nav-text">654. 最大二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">3.7.</span> <span class="nav-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#508-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C"><span class="nav-number">3.8.</span> <span class="nav-text">508. 出现次数最多的子树元素和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-I-II-III"><span class="nav-number">3.9.</span> <span class="nav-text">从上到下打印二叉树 I&#x2F;II&#x2F;III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">3.10.</span> <span class="nav-text">树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">3.11.</span> <span class="nav-text">二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.12.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#098-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.13.</span> <span class="nav-text">098. 验证二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-number">3.14.</span> <span class="nav-text">700. 二叉搜索树中的搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">3.15.</span> <span class="nav-text">701. 二叉搜索树中的插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">3.16.</span> <span class="nav-text">450. 删除二叉搜索树中的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-number">3.17.</span> <span class="nav-text">222. 完全二叉树的节点个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.18.</span> <span class="nav-text">297. 二叉树的序列化与反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#235-236-%E4%BA%8C%E5%8F%89-%E6%90%9C%E7%B4%A2%E6%A0%91-%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">3.19.</span> <span class="nav-text">235&#x2F;236. 二叉(搜索树)的最近公共祖先</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">4.</span> <span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I"><span class="nav-number">4.1.</span> <span class="nav-text">496. 下一个更大元素 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-II"><span class="nav-number">4.2.</span> <span class="nav-text">503. 下一个更大元素 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1019-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">4.3.</span> <span class="nav-text">1019. 链表中的下一个更大节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">4.4.</span> <span class="nav-text">739. 每日温度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#907-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="nav-number">4.5.</span> <span class="nav-text">907. 子数组的最小值之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#402-%E7%A7%BB%E6%8E%89-K-%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="nav-number">4.6.</span> <span class="nav-text">402. 移掉 K 位数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#768-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97-II"><span class="nav-number">4.7.</span> <span class="nav-text">768. 最多能完成排序的块 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#042-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">4.8.</span> <span class="nav-text">042. 接雨水</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#084-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E2%BC%A4%E7%9A%84%E7%9F%A9%E9%98%B5"><span class="nav-number">4.9.</span> <span class="nav-text">084. 柱状图中最⼤的矩阵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">5.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#026-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">5.1.</span> <span class="nav-text">026. 删除有序数组中的重复项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2"><span class="nav-number">5.2.</span> <span class="nav-text">141. 环形链表(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II-%E5%BF%AB%E6%85%A2"><span class="nav-number">5.3.</span> <span class="nav-text">142. 环形链表 II(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2"><span class="nav-number">5.4.</span> <span class="nav-text">234. 回文链表(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2"><span class="nav-number">5.5.</span> <span class="nav-text">143. 重排链表(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E5%BF%AB%E6%85%A2"><span class="nav-number">5.6.</span> <span class="nav-text">019. 删除链表的倒数第N个节点(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%B7%A6%E5%8F%B3"><span class="nav-number">5.7.</span> <span class="nav-text">344. 反转字符串(左右)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%B7%A6%E5%8F%B3"><span class="nav-number">5.8.</span> <span class="nav-text">125. 验证回文串(左右)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%B7%A6%E5%8F%B3"><span class="nav-number">5.9.</span> <span class="nav-text">015. 三数之和(左右)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">6.</span> <span class="nav-text">二分搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">6.1.</span> <span class="nav-text">704. 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#034-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">6.2.</span> <span class="nav-text">034. 查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#875-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82"><span class="nav-number">6.3.</span> <span class="nav-text">875. 爱吃香蕉的珂珂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1011-%E5%9C%A8-D-%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">6.4.</span> <span class="nav-text">1011. 在 D 天内送达包裹的能力</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">7.</span> <span class="nav-text">滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">7.1.</span> <span class="nav-text">003. 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">7.2.</span> <span class="nav-text">567. 字符串的排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">7.3.</span> <span class="nav-text">438. 找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#076-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-number">7.4.</span> <span class="nav-text">076. 最小覆盖子串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">8.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-number">8.1.</span> <span class="nav-text">509. 斐波那契数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">8.2.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-673"><span class="nav-number">8.3.</span> <span class="nav-text">300. 最长递增子序列(673)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98"><span class="nav-number">8.4.</span> <span class="nav-text">354. 俄罗斯套娃信封问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#053-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">8.5.</span> <span class="nav-text">053. 最大子数组和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#070-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">8.6.</span> <span class="nav-text">070. 爬楼梯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">8.7.</span> <span class="nav-text">120. 三角形最小路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">8.8.</span> <span class="nav-text">1143. 最长公共子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#072-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">8.9.</span> <span class="nav-text">072. 编辑距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-647"><span class="nav-number">8.10.</span> <span class="nav-text">005. 最长回文子串(647)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">8.11.</span> <span class="nav-text">516. 最长回文子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1312-%E6%88%90%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0"><span class="nav-number">8.12.</span> <span class="nav-text">1312. 成为回文串的最少插入次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#010-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">8.13.</span> <span class="nav-text">010. 正则表达式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD"><span class="nav-number">8.14.</span> <span class="nav-text">887. 鸡蛋掉落</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#312-%E6%88%B3%E6%B0%94%E7%90%83"><span class="nav-number">8.15.</span> <span class="nav-text">312. 戳气球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">8.16.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">8.17.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="nav-number">8.18.</span> <span class="nav-text">518. 零钱兑换 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">8.19.</span> <span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="nav-number">8.20.</span> <span class="nav-text">213. 打家劫舍 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="nav-number">8.21.</span> <span class="nav-text">337. 打家劫舍 III</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83"><span class="nav-number">9.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">9.1.</span> <span class="nav-text">409. 最长回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#055-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">9.2.</span> <span class="nav-text">055. 跳跃游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#045-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="nav-number">9.3.</span> <span class="nav-text">045. 跳跃游戏 II</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-DFS"><span class="nav-number">10.</span> <span class="nav-text">回溯&#x2F;DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#046-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">10.1.</span> <span class="nav-text">046. 全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#047-%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="nav-number">10.2.</span> <span class="nav-text">047. 全排列 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#078-%E5%AD%90%E9%9B%86"><span class="nav-number">10.3.</span> <span class="nav-text">078. 子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#090-%E5%AD%90%E9%9B%86-II"><span class="nav-number">10.4.</span> <span class="nav-text">090. 子集 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#077-%E7%BB%84%E5%90%88"><span class="nav-number">10.5.</span> <span class="nav-text">077. 组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#039-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">10.6.</span> <span class="nav-text">039. 组合总和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#040-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-number">10.7.</span> <span class="nav-text">040. 组合总和 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#022-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">10.8.</span> <span class="nav-text">022. 括号生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#051-N-%E7%9A%87%E5%90%8E"><span class="nav-number">10.9.</span> <span class="nav-text">051. N 皇后</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS"><span class="nav-number">11.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">11.1.</span> <span class="nav-text">111. 二叉树的最小深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#752-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81"><span class="nav-number">11.2.</span> <span class="nav-text">752. 打开转盘锁</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SoundMemories"
      src="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
  <p class="site-author-name" itemprop="name">SoundMemories</p>
  <div class="site-description" itemprop="description">今日事，今日毕</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvdW5kbWVtb3JpZXM=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soundmemories"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNvdW5kbWVtb3JpZXNAMTYzLmNvbQ==" title="E-Mail → mailto:soundmemories@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2022/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-31 00:00:00" itemprop="dateCreated datePublished" datetime="2022-01-31T00:00:00+08:00">2022-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Other/" itemprop="url" rel="index"><span itemprop="name">Other</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>114k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:44</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h2 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a>557. 反转字符串中的单词 III</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS13b3Jkcy1pbi1hLXN0cmluZy1paWkv">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。<br>示例 1：<br>输入：<code>s = &quot;Let&#39;s take LeetCode contest&quot;</code><br>输出：<code>&quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</code></p>
<p>示例 2:<br>输入： <code>s = &quot;God Ding&quot;</code><br>输出：<code>&quot;doG gniD&quot;</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS13b3Jkcy1pbi1hLXN0cmluZy1paWkvc29sdXRpb24vcHl0aG9uLWZhbi16aHVhbi16aS1mdS1jaHVhbi16aG9uZy1kYW4tY2ktc2ktbHUteGkv">Swants题解<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 按空格切分-&gt;每个字符串反转-&gt;拼接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(word[::<span class="number">-1</span>] <span class="keyword">for</span> word <span class="keyword">in</span> s.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        <span class="comment"># 先反转单词列表 再反转字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s.split(<span class="string">&quot; &quot;</span>)[::<span class="number">-1</span>])[::<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 先反转字符串，再反转单词列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s[::<span class="number">-1</span>].split(<span class="string">&quot; &quot;</span>)[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="859-亲密字符串"><a href="#859-亲密字符串" class="headerlink" title="859. 亲密字符串"></a>859. 亲密字符串</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYnVkZHktc3RyaW5ncy8=">https://leetcode-cn.com/problems/buddy-strings/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<br>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回 <code>true</code> ；否则返回 <code>false</code> 。<br>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 0 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。<br>例如，在 “abcd” 中交换下标 0 和下标 2 的元素可以生成 “cbad” 。</p>
<p>示例 1：<br>输入：<code>s = &quot;ab&quot;, goal = &quot;ba&quot;</code><br>输出：<code>true</code><br>解释：你可以交换 s[0] = ‘a’ 和 s[1] = ‘b’ 生成 “ba”，此时 s 和 goal 相等。</p>
<p><strong>题目解析</strong>：</p>
<ol>
<li>字符串A、B满足条件且长度相等；</li>
<li>A、B字符串相同时，A或B字符串去重后长度比原来小；</li>
<li>A、B字符串不相同的位置字符zip成元组放在列表中，因为只交换一次，所以列表长度必为2，且2个元组为对称关系；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span>(<span class="params">self, A: <span class="built_in">str</span>, B: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># A和B长度必须相等，不相等返回false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(A)!=<span class="built_in">len</span>(B) : <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># A和B相同时，如果A去重后长度比原来小，返回True</span></span><br><span class="line">        <span class="keyword">if</span> A == B <span class="keyword">and</span> <span class="built_in">len</span>(<span class="built_in">set</span>(A)) &lt; <span class="built_in">len</span>(A): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用zip组合A、B中同位置不相等的字符</span></span><br><span class="line">        dif = [(a,b) <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">zip</span>(A,B) <span class="keyword">if</span> a != b]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为只交换一次，所以dif长度只能是2，且2个元组为对称关系</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(dif) == <span class="number">2</span> <span class="keyword">and</span> dif[<span class="number">0</span>] == dif[<span class="number">1</span>][::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="020-有效的括号"><a href="#020-有效的括号" class="headerlink" title="020. 有效的括号"></a>020. 有效的括号</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv">https://leetcode-cn.com/problems/valid-parentheses/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个只包括 <code>(</code>，<code>)</code>，<code>&#123;</code>，<code>&#125;</code>，<code>[</code>，<code>]</code> 的字符串 <code>s</code> ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。<br>示例 1：<br>输入：<code>s = &quot;()[]&#123;&#125;&quot;</code><br>输出：<code>true</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用栈，先进后出的性质，判断括号合法性。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        dic = &#123;<span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>,  <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 左半，入栈</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> dic: stack.append(c)</span><br><span class="line">            <span class="comment"># 右半，出栈</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> dic[stack.pop()] != c: <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="021-合并两个有序链表"><a href="#021-合并两个有序链表" class="headerlink" title="021. 合并两个有序链表"></a>021. 合并两个有序链表</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLXNvcnRlZC1saXN0cy8=">https://leetcode-cn.com/problems/merge-two-sorted-lists/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：将两个<strong>升序链表</strong>合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例 1：<br>输入：<code>l1 = [1,2,4], l2 = [1,3,4]</code><br>输出：<code>[1,1,2,3,4,4]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: Optional[ListNode], list2: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        cur = newlist = ListNode(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        cur.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newlist.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="1290-二进制链表转整数"><a href="#1290-二进制链表转整数" class="headerlink" title="1290. 二进制链表转整数"></a>1290. 二进制链表转整数</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udmVydC1iaW5hcnktbnVtYmVyLWluLWEtbGlua2VkLWxpc3QtdG8taW50ZWdlci8=">https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个单链表的引用结点 <code>head</code>。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。请你返回该链表所表示数字的 <strong>十进制值</strong> 。</p>
<p>示例 1：<br>输入：<code>head = [1,0,1]</code><br>输出：<code>5</code><br>解释：二进制数 (101) 转化为十进制数 (5)</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udmVydC1iaW5hcnktbnVtYmVyLWluLWEtbGlua2VkLWxpc3QtdG8taW50ZWdlci9zb2x1dGlvbi9lci1qaW4temhpLWxpYW4tYmlhby16aHVhbi16aGVuZy1zaHUtYnktbGVldGNvZGUtcy8=">官方题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDecimalValue</span>(<span class="params">self, head: ListNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = head</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur: </span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            # 二进制方法</span></span><br><span class="line"><span class="string">            # 左移n位==乘2^n，| 按位或</span></span><br><span class="line"><span class="string">            ans = ans&lt;&lt;1 | cur.val</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            ans = ans * <span class="number">2</span> + cur.val <span class="comment"># 十进制方法</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="082-删除排序链表中的重复元素-II"><a href="#082-删除排序链表中的重复元素-II" class="headerlink" title="082. 删除排序链表中的重复元素 II"></a>082. 删除排序链表中的重复元素 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtbGlzdC1paS8=">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。<br>示例 1：<br>输入：<code>head = [1,2,3,3,4,4,5]</code><br>输出：<code>[1,2,5]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtbGlzdC1paS9zb2x1dGlvbi84Mi1weXRob25zaHVhbmctemhpLXpoZW4tZmEtYnktbHVsbGFieS8=">Lullaby题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line">        chead = ListNode(<span class="number">0</span>, head) <span class="comment"># 防止head被删除，增加一个哑节点</span></span><br><span class="line"></span><br><span class="line">        pre = chead</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 跳过重复节点，cur停在最后一个重复元素</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.val == cur.<span class="built_in">next</span>.val: cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># pre和cur之间没有重复节点，pre后移</span></span><br><span class="line">            <span class="keyword">if</span> pre.<span class="built_in">next</span> == cur: pre = pre.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># pre和cur之间有重复节点，跳过重复节点</span></span><br><span class="line">            <span class="keyword">else</span>: pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> chead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZXJzZWN0aW9uLW9mLXR3by1saW5rZWQtbGlzdHMv">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。两个链表在节点 <code>c1</code> 开始相交：<code>A=[a1,a2,c1,c2,c3]，B=[b1,b2,b3,c1,c2,c3]</code>，题目数据 <strong>保证</strong> 整个链式结构中<strong>不存在环</strong>。注意，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p>示例 1：<br>输入：<code>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</code><br>输出：<code>Intersected at &#39;8&#39;</code><br>解释：相交节点的值为 <code>8</code> （注意，如果两个链表相交则不能为 <code>0</code>）。<br>从各自的表头开始算起，链表 <code>A</code> 为 <code>[4,1,8,4,5]</code>，链表 <code>B</code> 为 <code>[5,6,1,8,4,5]</code>。<br>在 <code>A</code> 中，相交节点前有 <code>2</code> 个节点；在 <code>B</code> 中，相交节点前有 <code>3</code> 个节点。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZXJzZWN0aW9uLW9mLXR3by1saW5rZWQtbGlzdHMvc29sdXRpb24veGlhbmctamlhby1saWFuLWJpYW8tYnktbGVldGNvZGUtc29sdXRpby1hOGpuLw==">官方题解<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZXJzZWN0aW9uLW9mLXR3by1saW5rZWQtbGlzdHMvc29sdXRpb24vaW50ZXJzZWN0aW9uLW9mLXR3by1saW5rZWQtbGlzdHMtc2h1YW5nLXpoaS16aGVuLWwv">jyd题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type headA: ListNode</span></span><br><span class="line"><span class="string">        :type headB: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ha, hb = headA, headB</span><br><span class="line">        <span class="comment"># 假设ha长m(不相交部分长a)，hb长n(不相交部分长b)，相交部分长度c。</span></span><br><span class="line">        <span class="comment"># 当两指针相遇时停止：此时ha走了a+c+b，hb走了b+c+a。</span></span><br><span class="line">        <span class="keyword">while</span> ha != hb:</span><br><span class="line">            <span class="comment"># a走到尾部，从b头部开始</span></span><br><span class="line">            ha = ha.<span class="built_in">next</span> <span class="keyword">if</span> ha <span class="keyword">else</span> headB</span><br><span class="line">            <span class="comment"># b走到尾部，从a头部开始</span></span><br><span class="line">            hb = hb.<span class="built_in">next</span> <span class="keyword">if</span> hb <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> ha</span><br></pre></td></tr></table></figure></p>
<h2 id="002-两数相加-I"><a href="#002-两数相加-I" class="headerlink" title="002. 两数相加 I"></a>002. 两数相加 I</h2><p><strong>难度</strong>：中等<br><strong>题⽬链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkLXR3by1udW1iZXJzLw==">https://leetcode-cn.com/problems/add-two-numbers/<i class="fa fa-external-link-alt"></i></span><br><strong>题⽬描述</strong>：给出两个 <strong>⾮空</strong> 的链表⽤来表示两个非负的整数。其中，它们各⾃的位数是按照 <strong>逆序</strong> 的⽅式存储的，并且它们的每个节点只能存储 <strong>⼀位</strong> 数字。如果，我们将这两个数相加起来，则会返回⼀个新的链表来表示它们的和您可以假设除了数字 <code>0</code> 之外，这两个数都不会以 <code>0</code> 开头。</p>
<p>示例：<br>输⼊：<code>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code><br>输出：<code>7 -&gt; 0 -&gt; 8</code><br>原因：<code>342 + 465 = 807</code></p>
<a id="more"></a> 
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkLXR3by1udW1iZXJzL3NvbHV0aW9uL2xpYW5nLXNodS14aWFuZy1qaWEtYnktbGVldGNvZGUv">官方题解<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># dummy</span></span><br><span class="line">        dummy = curr = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span> <span class="comment"># 按位相加结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 两链表为空时退出</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> <span class="built_in">sum</span>:</span><br><span class="line">            <span class="comment"># 取相同位的值相加，某一链表当前位为空时用0去计算</span></span><br><span class="line">            <span class="built_in">sum</span> += (l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span>) + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 当前节点值为/10的余数，链表起始为None下一位</span></span><br><span class="line">            curr.<span class="built_in">next</span> = ListNode(<span class="built_in">sum</span> % <span class="number">10</span>)</span><br><span class="line">            curr = curr.<span class="built_in">next</span> <span class="comment"># 移动指针</span></span><br><span class="line">            <span class="comment"># 更新进位值</span></span><br><span class="line">            <span class="built_in">sum</span> //= <span class="number">10</span></span><br><span class="line">            <span class="comment"># 某一链表为空，不next</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkLXR3by1udW1iZXJzLWlpLw==">https://leetcode-cn.com/problems/add-two-numbers-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字<strong>最高位位于链表开始位置</strong>。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 <code>0</code> 之外，这两个数字都不会以零开头。和 <strong>两数相加 I</strong> 区别是数字 <strong>非逆序</strong> 存储。</p>
<p>示例1：<br>输入：<code>l1 = [7,2,4,3], l2 = [5,6,4]</code><br>输出：<code>[7,8,0,7]</code></p>
<p>示例2：<br>输入：<code>l1 = [2,4,3], l2 = [5,6,4]</code><br>输出：<code>[8,0,7]</code></p>
<p>示例3：<br>输入：<code>l1 = [0], l2 = [0]</code><br>输出：<code>[0]</code></p>
<p><strong>题目解析</strong>：</p>
<ol>
<li>在 <strong>2.两数相加</strong> 基础上使用2次反转链表。</li>
<li>使用栈（先进后出） + 头插法。</li>
</ol>
<div class="tabs" id="445"><ul class="nav-tabs"><li class="tab active"><a href="#445-1">反转链表</a></li><li class="tab"><a href="#445-2">栈+头插法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="445-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 如果链表 非逆序，需要先逆序</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head</span>):</span></span><br><span class="line">            cur = head</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">        l1 = reverse(l1)</span><br><span class="line">        l2 = reverse(l2)</span><br><span class="line">        dummy = curr = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span> <span class="comment"># 按位相加结果</span></span><br><span class="line">        <span class="comment"># 两链表为空时退出</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> <span class="built_in">sum</span>:</span><br><span class="line">            <span class="comment"># 取相同位的值相加，某一链表当前位为空时用0去计算</span></span><br><span class="line">            <span class="built_in">sum</span> += (l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span>) + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 当前节点值为/10的余数，链表起始为None下一位</span></span><br><span class="line">            curr.<span class="built_in">next</span> = ListNode(<span class="built_in">sum</span> % <span class="number">10</span>)</span><br><span class="line">            curr = curr.<span class="built_in">next</span> <span class="comment"># 移动指针</span></span><br><span class="line">            <span class="comment"># 更新进位值</span></span><br><span class="line">            <span class="built_in">sum</span> //= <span class="number">10</span></span><br><span class="line">            <span class="comment"># 某一链表为空，不next</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverse(dummy.<span class="built_in">next</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="445-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        a,b = [],[]</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            a.append(l1.val)</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            b.append(l2.val)</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> a <span class="keyword">or</span> b <span class="keyword">or</span> <span class="built_in">sum</span>:</span><br><span class="line">            <span class="built_in">sum</span> += (a.pop() <span class="keyword">if</span> a <span class="keyword">else</span> <span class="number">0</span>) + (b.pop() <span class="keyword">if</span> b <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 头插法</span></span><br><span class="line">            cur = ListNode(<span class="built_in">sum</span> % <span class="number">10</span>)</span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sum</span> //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">https://leetcode-cn.com/problems/reverse-linked-list/<i class="fa fa-external-link-alt"></i></span> ，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmFuLXpodWFuLWxpYW4tYmlhby1sY29mLw==">剑指offer 面试题24<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：<br>输入：<code>head = [1,2,3,4,5]</code><br>输出：<code>[5,4,3,2,1]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC9zb2x1dGlvbi9kb25nLWh1YS15YW4tc2hpLTIwNi1mYW4temh1YW4tbGlhbi1iaWFvLWJ5LXVzZXI3NC8=">wang_ni_ma题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 申请两个节点，pre和 cur，pre指向None</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 记录当前节点的下一个节点</span></span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 然后将当前节点指向pre</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            <span class="comment"># pre和cur节点都前进一位</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></p>
<h2 id="092-反转链表-II"><a href="#092-反转链表-II" class="headerlink" title="092. 反转链表 II"></a>092. 反转链表 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC1paS8=">https://leetcode-cn.com/problems/reverse-linked-list-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 反转后的链表 。<br>示例 1：<br>输入：<code>head = [1,2,3,4,5], left = 2, right = 4</code><br>输出：<code>[1,4,3,2,5]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        遍历到[left, right]的节点，每次都把当前节点插到头部，结束即为 反转后的链表。</span></span><br><span class="line"><span class="string">        pre：left的前一个节点</span></span><br><span class="line"><span class="string">        cur：需要翻转的起始节点</span></span><br><span class="line"><span class="string">        需要反转的次数：right-left</span></span><br><span class="line"><span class="string">        先链接cur和cur.next.next，再将cur.next插入pre后。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = dummy = ListNode(<span class="number">-1</span>, head)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left<span class="number">-1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right-left):</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="025-K-个一组翻转链表"><a href="#025-K-个一组翻转链表" class="headerlink" title="025. K 个一组翻转链表"></a>025. K 个一组翻转链表</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1ub2Rlcy1pbi1rLWdyb3VwLw==">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后<strong>剩余的节点保持原有顺序</strong>。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br>示例 1：<br>输入：<code>head = [1,2,3,4,5], k = 2</code><br>输出：<code>[2,1,4,3,5]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 翻转[head, tail]之间的链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, head: ListNode</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        翻转链表，pre为反转后的头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        长度为k的链表</span></span><br><span class="line"><span class="string">        tail：k翻转前的尾节点</span></span><br><span class="line"><span class="string">        hair：k翻转前的头节点(即k翻转后的尾节点)</span></span><br><span class="line"><span class="string">        pre：k翻转前的头节点前一个节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        tail = pre = dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> tail:</span><br><span class="line">            <span class="comment"># 找到k个节点的结尾</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):  </span><br><span class="line">                <span class="keyword">if</span> tail: tail = tail.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail: <span class="keyword">break</span>  <span class="comment"># k结尾为None，结束循环</span></span><br><span class="line">            <span class="comment"># 先断开</span></span><br><span class="line">            <span class="built_in">next</span> = tail.<span class="built_in">next</span></span><br><span class="line">            tail.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 再翻转，pre为翻转后的尾节点</span></span><br><span class="line">            hair = pre.<span class="built_in">next</span> </span><br><span class="line">            pre.<span class="built_in">next</span> = self.reverse(hair)</span><br><span class="line">            <span class="comment"># 再接回</span></span><br><span class="line">            hair.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 更新下一轮</span></span><br><span class="line">            pre = tail = hair</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a>138. 复制带随机指针的链表</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29weS1saXN0LXdpdGgtcmFuZG9tLXBvaW50ZXIv">https://leetcode-cn.com/problems/copy-list-with-random-pointer/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<br>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。<br>构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong>。<br>例如，如果原链表中有<code>X</code>和<code>Y</code>两个节点，其中<code>X.random -&gt; Y</code>。那么在复制链表中对应的两个节点<code>x</code>和<code>y</code>，同样有<code>x.random -&gt; y</code>。<br>返回复制链表的头节点。<br>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：<code>val</code>：一个表示 <code>Node.val</code> 的整数。<code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>你的代码 只 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<p>示例 1：<br>输入：<code>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</code><br>输出：<code>[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29weS1saXN0LXdpdGgtcmFuZG9tLXBvaW50ZXIvc29sdXRpb24vZnUtemhpLWRhaS1zdWktamktemhpLXpoZW4tZGUtbGlhbi1iaWFvLWJ5LWxlZXRjb2Qv">LeetCode官方题解<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>题目解析</strong>：迭代 + 节点拆分。</p>
<ol>
<li>判断空链表</li>
<li>复制节点+节点值</li>
<li>复制随机指针</li>
<li>拆分<br>时间复杂度$O(n)$，只需遍历3遍链表。<br>空间复杂度$O(1)$。</li>
</ol>
<div class="tabs" id="859"><ul class="nav-tabs"><li class="tab active"><a href="#859-1">3次迭代+拆分</a></li><li class="tab"><a href="#859-2">2次迭代+哈希表</a></li></ul><div class="tab-content"><div class="tab-pane active" id="859-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="comment"># 空链表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 复制节点+节点值</span></span><br><span class="line">        ptr = head</span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line">            node = Node(ptr.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            node.<span class="built_in">next</span> = ptr.<span class="built_in">next</span></span><br><span class="line">            ptr.<span class="built_in">next</span> = node</span><br><span class="line">            ptr = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 复制节点随机指针</span></span><br><span class="line">        ptr = head</span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line">            ptr.<span class="built_in">next</span>.random = ptr.random.<span class="built_in">next</span> <span class="keyword">if</span> ptr.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            ptr = ptr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 拆分节点 A-&gt;A&#x27;-&gt;B-&gt;B&#x27;-&gt;C-&gt;C&#x27; 拆分成 A-&gt;B-&gt;C 和 A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">        old = head  <span class="comment"># A-&gt;B-&gt;C</span></span><br><span class="line">        new = head.<span class="built_in">next</span>  <span class="comment"># A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">        head_new = head.<span class="built_in">next</span>  <span class="comment"># 必须是新的指针</span></span><br><span class="line">        <span class="keyword">while</span> old:</span><br><span class="line">            old.<span class="built_in">next</span> = old.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            new.<span class="built_in">next</span> = new.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">if</span> new.<span class="built_in">next</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            old = old.<span class="built_in">next</span></span><br><span class="line">            new = new.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head_new</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="859-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="comment"># 空链表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># &#123;旧节点:新节点...&#125; 哈希表</span></span><br><span class="line">        cur = head</span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            hash_map[cur] = Node(cur.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据旧节点找新节点，建立连接+复制随机指针</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            hash_map.get(cur).<span class="built_in">next</span> = hash_map.get(cur.<span class="built_in">next</span>)</span><br><span class="line">            hash_map.get(cur).random = hash_map.get(cur.random)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hash_map.get(head)</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="560-和为-K-的子数组-前缀和"><a href="#560-和为-K-的子数组-前缀和" class="headerlink" title="560. 和为 K 的子数组(前缀和)"></a>560. 和为 K 的子数组(前缀和)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3ViYXJyYXktc3VtLWVxdWFscy1rLw==">https://leetcode-cn.com/problems/subarray-sum-equals-k/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 该数组中和为 <code>k</code> 的子数组的个数 。<br>示例 1：<br>输入：<code>nums = [1,1,1], k = 2</code><br>输出：<code>2</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        每次遇到“连续子数组的和”相关问题，都可以考虑前缀和是否能行。</span></span><br><span class="line"><span class="string">        sums比nums长度+1，考虑用sums[i]记录nums[0~i]的和，sums[j]-sums[i-1]得到nums[i~j]的和，</span></span><br><span class="line"><span class="string">        和为k，那么sums[j]-sums[i-1]==k，可得sums[i-1]==sums[j]-k，而sums[j]可由sums[j-1]+nums[i]得来，</span></span><br><span class="line"><span class="string">        可以使用一个变量sumsj记录，而不用数组。</span></span><br><span class="line"><span class="string">        hmap：&#123;前缀和:该前缀和出现次数&#125;</span></span><br><span class="line"><span class="string">        presum：前i个值的和</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hmap = &#123;&#125;</span><br><span class="line">        hmap[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># 前缀和为0，算1次(只有1个元素且值为k)</span></span><br><span class="line">        sumsj, res = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sumsj += nums[i]  <span class="comment"># sums[j]</span></span><br><span class="line">            sumsi_1 = sumsj - k  <span class="comment"># sums[i-1]</span></span><br><span class="line">            <span class="keyword">if</span> sumsi_1 <span class="keyword">in</span> hmap: res += hmap[sumsi_1]</span><br><span class="line">            hmap[sumsj] = hmap.get(sumsj,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="969-煎饼排序-递归"><a href="#969-煎饼排序-递归" class="headerlink" title="969. 煎饼排序(递归)"></a>969. 煎饼排序(递归)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFuY2FrZS1zb3J0aW5nLw==">https://leetcode-cn.com/problems/pancake-sorting/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>s</code> ，请使用 煎饼翻转 完成对数组的排序。一次煎饼翻转：<code>arr = [3,2,1,4]</code> ，选择 <code>k = 3</code> 进行一次煎饼翻转，反转子数组 <code>[3,2,1]</code> ，得到 <code>arr = [1,2,3,4]</code> 。以数组形式返回能使 <code>arr</code> 有序的煎饼翻转操作所对应的 <code>k</code> 值序列。<br>示例 1：<br>输入：<code>[3,2,4,1]</code><br>输出：<code>[4,2,4,3]</code><br>解释：我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。<br>初始状态 arr = [3, 2, 4, 1]<br>第一次翻转后（k = 4）：arr = [1, 4, 2, 3]<br>第二次翻转后（k = 2）：arr = [4, 1, 2, 3]<br>第三次翻转后（k = 4）：arr = [3, 2, 1, 4]<br>第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。 </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFuY2FrZS1zb3J0aW5nL3NvbHV0aW9uLzk2OS1qaWFuLWJpbmctcGFpLXh1LWRpLWd1aS1oZS1kaWUtZGFpLWItdmR2NS8=">倔强渣渣 题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pancakeSort</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        和汉诺塔类似，首先找到最大值i，把i翻转到最底层，这样规模缩减为n-1层，递归即可。</span></span><br><span class="line"><span class="string">        (1) 找到烧饼中最大的那个。</span></span><br><span class="line"><span class="string">        (2) 把这个最大的移到最底下。</span></span><br><span class="line"><span class="string">        (3) 递归调用函数pancakeSort(cakes[:-1])，当n==1时，排序1个烧饼不需要翻转。</span></span><br><span class="line"><span class="string">        需要注意，数组索引从0开始，返回的k是从1开始。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sortcakes</span>(<span class="params">cakes</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cakes)==<span class="number">1</span>: <span class="keyword">return</span></span><br><span class="line">            idx = cakes.index(<span class="built_in">max</span>(cakes))</span><br><span class="line">            k = idx + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第一次翻转，把最大的煎饼翻到最上面</span></span><br><span class="line">            cakes = cakes[:k][::<span class="number">-1</span>] + cakes[k:]</span><br><span class="line">            <span class="comment"># 第二次翻转，将最大的煎饼翻到最下面</span></span><br><span class="line">            cakes = cakes[::<span class="number">-1</span>]</span><br><span class="line">            res.extend([k, <span class="built_in">len</span>(cakes)])</span><br><span class="line">            sortcakes(cakes[:<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        sortcakes(arr)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="汉诺塔问题-递归"><a href="#汉诺塔问题-递归" class="headerlink" title="汉诺塔问题(递归)"></a>汉诺塔问题(递归)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaGFub3RhLWxjY2kv">面试题 08.06. 汉诺塔问题<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。<br>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。<br>你需要原地修改栈。<br>示例1:<br>输入：<code>A = [2, 1, 0], B = [], C = []</code><br>输出：<code>C = [2, 1, 0]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaGFub3RhLWxjY2kvc29sdXRpb24vdHUtamllLXlpLW51by10YS1kZS1ndS1zaGktanUtc2h1by1kYW5nLTY0Z2UtcGFuLXov">Pumpkin题解<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hanota</span>(<span class="params">self, A: List[<span class="built_in">int</span>], B: List[<span class="built_in">int</span>], C: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        定义一个move函数，不断把n-1个盘子移动到C，</span></span><br><span class="line"><span class="string">        n：盘子数</span></span><br><span class="line"><span class="string">        A：起始</span></span><br><span class="line"><span class="string">        B：中间过渡</span></span><br><span class="line"><span class="string">        C：结束</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">n, A, B, C</span>):</span></span><br><span class="line">            <span class="comment"># 只有一个直接移动到C</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                C.append(A.pop())</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 先把A上面n-1个盘子从A移到B(通过C)</span></span><br><span class="line">                move(n<span class="number">-1</span>, A, C, B)  </span><br><span class="line">                <span class="comment"># 将A最后一个移到C</span></span><br><span class="line">                C.append(A.pop())         </span><br><span class="line">                <span class="comment"># 再将B上面n-1个盘子从B移到C(通过A)          </span></span><br><span class="line">                move(n<span class="number">-1</span>,B, A, C) </span><br><span class="line">              </span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        move(n, A, B, C)</span><br></pre></td></tr></table></figure></p>
<h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtcHJpbWVzLw==">https://leetcode-cn.com/problems/count-primes/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定整数 <code>n</code> ，返回 <strong>所有小于非负整数 n 的质数</strong>的数量 。<br>示例 1：<br>输入：<code>n = 10</code><br>输出：<code>4</code><br>解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        质数：也叫素数，只能被 1 和 它本身 整除。</span></span><br><span class="line"><span class="string">        (1) 埃氏筛：如果一个数 x 是质数，那么它的倍数 2x,3x,4x...一定不是质数。</span></span><br><span class="line"><span class="string">        (2) 计算[2~n]的质数个数，只需计算[2~sqrt(n)]即可，之后的数都是镜像，比如 12=3*4,4*3, sqrt(12)为3.46, 从4往后就是前面的镜像了。</span></span><br><span class="line"><span class="string">        (3) 剔除 质数i 的倍数，不需要从头开始，因为在剔除之前的质数倍数时，把i^2前的都算过了。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 最小的质数是 2</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        isPrime = [<span class="literal">True</span>] * n</span><br><span class="line">        isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">False</span>   <span class="comment"># 0和1不是质数，先排除掉</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 埃式筛，把不大于根号 n 的所有 质数i 的倍数剔除</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt(n))+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime[i]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i^<span class="number">2</span>, n, i):</span><br><span class="line">                    isPrime[j] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(isPrime)</span><br></pre></td></tr></table></figure></p>
<h2 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a>912. 排序数组</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS8=">https://leetcode-cn.com/problems/sort-an-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>nums</code>，请你将该数组升序排列。<br>示例 1：<br>输入：<code>nums = [5,2,3,1]</code><br>输出：<code>[1,2,3,5]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS9zb2x1dGlvbi85MTItcGFpLXh1LXNodS16dS1qaS1jaHUtcGFpLXh1LXN1YW4tZmEtMXF0NWYv">郁郁雨 题解<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS9zb2x1dGlvbi9weXRob24zLXN1aS1qaS1rdWFpLXN1LXBhaS14dS1ieS12MTJkZS1hLWN1ZjMv">V12的奥托 快排题解<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS9zb2x1dGlvbi9kb25nLWh1YS1tby1uaS15aS1nZS1wby1kdWktcGFpLXdvLWdhby1sLWk2bXQv">程序厨 堆排序讲解<i class="fa fa-external-link-alt"></i></span>。<br><div class="tabs" id="912"><ul class="nav-tabs"><li class="tab active"><a href="#912-1">快速排序</a></li><li class="tab"><a href="#912-2">堆排序</a></li><li class="tab"><a href="#912-3">归并排序</a></li><li class="tab"><a href="#912-4">冒泡排序</a></li><li class="tab"><a href="#912-5">选择排序</a></li><li class="tab"><a href="#912-6">插入排序</a></li><li class="tab"><a href="#912-7">堆显示</a></li></ul><div class="tab-content"><div class="tab-pane active" id="912-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先随机选择一个值作为轴，比轴小的放左边，比轴大的放到右边，该轴就处于数列的中间位置。</span></span><br><span class="line"><span class="string">        递归地把小于轴值元素的子数列和大于轴值元素的子数列排序。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># def partition(left, right):</span></span><br><span class="line">        <span class="comment">#     index = random.randint(left, right)</span></span><br><span class="line">        <span class="comment">#     # 记录轴，并把轴移动到左侧保存</span></span><br><span class="line">        <span class="comment">#     pivot = nums[index]</span></span><br><span class="line">        <span class="comment">#     nums[index], nums[left] = nums[left], nums[index]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     i, j = left, right</span></span><br><span class="line">        <span class="comment">#     while i &lt; j:</span></span><br><span class="line">        <span class="comment">#         while i &lt; j and nums[j] &gt;= pivot: j -= 1  # 找到右边小于轴的j</span></span><br><span class="line">        <span class="comment">#         while i &lt; j and nums[i] &lt;= pivot: i += 1 # 找到左边大于轴的i</span></span><br><span class="line">        <span class="comment">#         nums[i], nums[j] = nums[j], nums[i]  # 交换</span></span><br><span class="line">        <span class="comment">#     # 结束时左边比轴小，右边比轴大，j==i停在轴应在的位置(左侧最后一位)，和轴交换</span></span><br><span class="line">        <span class="comment">#     nums[left], nums[j] = nums[j], nums[left]</span></span><br><span class="line">        <span class="comment">#     return j  # 返回轴最终位置</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            index = random.randint(left, right)</span><br><span class="line">            <span class="comment"># 记录轴，并把轴移动到右侧保存</span></span><br><span class="line">            pivot = nums[index]</span><br><span class="line">            nums[index], nums[right] = nums[right], nums[index]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 比轴元素小的放在左侧</span></span><br><span class="line">            j = left</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">                    nums[j], nums[i] = nums[i], nums[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最后 j 为轴元素位置(右侧第一位，第一个大于等于轴的值的位置)</span></span><br><span class="line">            nums[right], nums[j] = nums[j], nums[right]</span><br><span class="line">            <span class="keyword">return</span> j  <span class="comment"># 返回轴最终位置</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                mid = partition(left, right)</span><br><span class="line">                quick(left, mid<span class="number">-1</span>)</span><br><span class="line">                quick(mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        quick(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums = [<span class="number">0</span>] + nums  <span class="comment"># 下标为 1~n</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建大顶堆(从最后一个非叶子节点n//2开始-&gt;堆顶)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            self.heap_adjust(n, i, nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 排序：依次将，尾部元素和堆最大值(堆顶nums[1])交换，并调整堆</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            nums[<span class="number">1</span>], nums[j] = nums[j], nums[<span class="number">1</span>] </span><br><span class="line">            <span class="comment"># 交换完，尾部是最大值了，只需调整前面的 nums[1~j-1] 节点   </span></span><br><span class="line">            self.heap_adjust(j<span class="number">-1</span>, <span class="number">1</span>, nums)                 </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">1</span>:]  <span class="comment"># 结束时，nums[1:]小-&gt;大的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_adjust</span>(<span class="params">self, end, index, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        下沉法调整大顶堆</span></span><br><span class="line"><span class="string">        end：大顶堆数组尾部索引</span></span><br><span class="line"><span class="string">        index：当前节点的索引(要调整节点)</span></span><br><span class="line"><span class="string">        nums：大顶堆数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        index左节点索引：2*index</span></span><br><span class="line"><span class="string">        index右节点索引：2*index + 1</span></span><br><span class="line"><span class="string">        节点idx的父节点：idx//2</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            j = <span class="number">2</span> * index  <span class="comment"># 先设定j为index左节点索引</span></span><br><span class="line">            <span class="comment"># 如果左节点存在，j指向左右节点大的</span></span><br><span class="line">            <span class="keyword">if</span> j&lt;=end<span class="number">-1</span> <span class="keyword">and</span> nums[j]&lt;nums[j+<span class="number">1</span>]: </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 验证j合法性，j节点大于index节点，交换</span></span><br><span class="line">            <span class="keyword">if</span> j&lt;=end <span class="keyword">and</span> nums[index]&lt;nums[j]: </span><br><span class="line">                nums[index],nums[j] = nums[j],nums[index]</span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            index = j  <span class="comment"># 继续下沉 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        归并是从中间开始不断分为左右两部分，对左右两部分进行合并排序</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分半</span></span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        left = self.sortArray(nums[:mid])</span><br><span class="line">        right = self.sortArray(nums[mid:])</span><br><span class="line">        <span class="comment"># 合并</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">                res.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后有剩余，直接添加到res中</span></span><br><span class="line">        res += left[i:]</span><br><span class="line">        res += right[j:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-4"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 可优化为n-1，最后一次不用比</span></span><br><span class="line">            is_sorted = <span class="literal">True</span>  <span class="comment"># 当某一轮没有交换过，就已经排序好了</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i<span class="number">-1</span>):  <span class="comment"># 当i==0时，比较n-1次</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                    nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">                    is_sorted = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> is_sorted: <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-5"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        最大值移动到后面/最小值移动到前面，这里选择第二种。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 可优化为n-1，最后一次不用比</span></span><br><span class="line">            min_index = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[min_index]: min_index = j</span><br><span class="line">            nums[i], nums[min_index] = nums[min_index], nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-6"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        类似打扑克牌的时候，每次会把新摸的牌插入到已经排好序的牌里。</span></span><br><span class="line"><span class="string">        (1) 将比当前数大的元素依次后移，然后把当前数放在最后一个比它大的数字的原位置。</span></span><br><span class="line"><span class="string">        (2) 和比当前数大的元素依次交换，直到停止。</span></span><br><span class="line"><span class="string">        以上两种方法都可以。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 第一种</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):  </span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> nums[j<span class="number">-1</span>]&gt;tmp:</span><br><span class="line">                nums[j] = nums[j<span class="number">-1</span>]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[j] = tmp</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二种</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):  </span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> nums[j<span class="number">-1</span>]&gt;nums[j]:</span><br><span class="line">                nums[j<span class="number">-1</span>],nums[j] = nums[j], nums[j<span class="number">-1</span>]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-7"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># unit_width：单元宽度，数据和空格的单位</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ptree</span>(<span class="params">nums,unit_width=<span class="number">2</span></span>):</span></span><br><span class="line">    <span class="comment"># 为了和编号对应，增加一个无用的0在首位</span></span><br><span class="line">    nums.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 数据长度，减1跳过第0位</span></span><br><span class="line">    length = <span class="built_in">len</span>(nums) <span class="number">-1</span> </span><br><span class="line">    <span class="comment"># 树深度</span></span><br><span class="line">    depth = <span class="built_in">int</span>(math.log2(length)) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 按满二叉树算，最深那行个数，投影看就是总体数据个数</span></span><br><span class="line">    width = <span class="number">2</span> ** depth - <span class="number">1</span> </span><br><span class="line">    <span class="comment"># 层，从0开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(depth):</span><br><span class="line">        <span class="comment"># 每层最多几个数。如果层数从1开始：2**(i-1)，从0开始：2**i</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** i):</span><br><span class="line">            <span class="comment"># 当前索引：前i-1层的个数(2**i-1=2**k-1)+当前层第(j+1),最终等于2**i+j</span></span><br><span class="line">            <span class="comment"># 非满叉，判断当前层的节点索引是否超出数组最大索引，超出就结束</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> ** i + j) &gt;= length + <span class="number">1</span>:<span class="keyword">return</span></span><br><span class="line">            <span class="comment"># end是中间的空格(居中打印，后面追加一个单位空格，因为7//2=3,3+3=6,少一个)</span></span><br><span class="line">            print(<span class="string">&quot;&#123;:^&#123;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(nums[<span class="number">2</span> ** i + j],width * unit_width),end=<span class="string">&#x27; &#x27;</span> * unit_width)</span><br><span class="line">        <span class="comment">#每层居中宽度是上一层的一半</span></span><br><span class="line">        width = width // <span class="number">2</span> </span><br><span class="line">        <span class="comment">#每行结束换行</span></span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">30</span>,<span class="number">20</span>,<span class="number">80</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">90</span>]</span><br><span class="line">ptree(nums)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              30                </span></span><br><span class="line"><span class="string">      20              80        </span></span><br><span class="line"><span class="string">  40      50      10      60    </span></span><br><span class="line"><span class="string">70  90  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLWxhcmdlc3QtZWxlbWVudC1pbi1hbi1hcnJheS8=">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。<br>示例 1:<br>输入: <code>[3,2,1,5,6,4] 和 k = 2</code><br>输出: <code>5</code><br>第k大，在 Python 的 heapq 库中有一个 nlargest 方法，具有同样的时间复杂度，能将代码简化到只有一行 <code>heapq.nlargest(k, nums)[-1]</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        快速排序，quick中发现目标位置被排好序，直接返回值。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            index = random.randint(left, right)</span><br><span class="line">            <span class="comment"># 记录基准，并把基准移动到右侧保存</span></span><br><span class="line">            pivot = nums[index]</span><br><span class="line">            nums[index], nums[right] = nums[right], nums[index]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 比轴元素小的放在左侧，最后j为轴元素位置</span></span><br><span class="line">            j = left</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">                    nums[j], nums[i] = nums[i], nums[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 轴元素放入其应在位置</span></span><br><span class="line">            nums[right], nums[j] = nums[j], nums[right]</span><br><span class="line">            <span class="keyword">return</span> j  <span class="comment"># 返回基准最终位置</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span> </span><br><span class="line">            idx = <span class="built_in">len</span>(nums)-k   <span class="comment"># 第k大的下标为n-k</span></span><br><span class="line">            mid = partition(left, right)</span><br><span class="line">            <span class="keyword">if</span> mid == idx: <span class="keyword">return</span> nums[mid]  <span class="comment"># 此时确定好位置的mid为第k大下标，直接返回值。</span></span><br><span class="line">            <span class="keyword">elif</span> mid &gt; idx: <span class="keyword">return</span> quick(left, mid<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">elif</span> mid &lt; idx: <span class="keyword">return</span> quick(mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quick(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1saXN0Lw==">https://leetcode-cn.com/problems/sort-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。<br>示例 1：<br>输入：<code>head = [4,2,1,3]</code><br>输出：<code>[1,2,3,4]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        归并排序</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">        left_end = self.find_mid(head)</span><br><span class="line">        right_head = left_end.<span class="built_in">next</span></span><br><span class="line">        left_end.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(right_head)</span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_mid</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        快慢指针找中点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 奇数：slow停在中间</span></span><br><span class="line">        <span class="comment"># 偶数：slow停在中间偏左</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        021. 合并两个有序链表</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = newlist = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> head1 <span class="keyword">and</span> head2:</span><br><span class="line">            <span class="keyword">if</span> head1.val &lt; head2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = head1</span><br><span class="line">                head1 = head1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = head2</span><br><span class="line">                head2 = head2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        cur.<span class="built_in">next</span> = head1 <span class="keyword">if</span> head1 <span class="keyword">else</span> head2</span><br><span class="line">        <span class="keyword">return</span> newlist.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a>146. LRU 缓存</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbHJ1LWNhY2hlLw==">https://leetcode-cn.com/problems/lru-cache/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：请你设计并实现一个满足  <strong>LRU (最近最少使用)</strong> 缓存 约束的数据结构。<br>实现 <code>LRUCache</code> 类：<br><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存；<br><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。<br><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出 最久</strong>未使用的关键字。<br>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p>示例：<br>输入：<br><code>[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</code><br><code>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</code><br>输出：<code>[null, null, null, 1, null, -1, null, -1, 3, 4]</code><br>解释：<br><code>LRUCache lRUCache = new LRUCache(2);</code><br><code>lRUCache.put(1, 1);</code> // 缓存是 {1=1}<br><code>lRUCache.put(2, 2);</code> // 缓存是 {1=1, 2=2}<br><code>lRUCache.get(1);</code>    // 返回 1<br><code>lRUCache.put(3, 3);</code> // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br><code>lRUCache.get(2);</code>   // 返回 -1 (未找到)<br><code>lRUCache.put(4, 4);</code> // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br><code>lRUCache.get(1);</code>    // 返回 -1 (未找到)<br><code>lRUCache.get(3);</code>    // 返回 3<br><code>lRUCache.get(4);</code>    // 返回 4</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">0</span>, value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    要求 查找、插入、删除(超出容量) 操作时间复杂度为 O(1)，</span></span><br><span class="line"><span class="string">    想到hamp(字典)能快速查找，链表能快速插入、删除————哈希链表(双向)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    为什么用双向链表？因为删除时只给当前节点，不用双向不知道前面节点。</span></span><br><span class="line"><span class="string">    为什么链表存储(key,val)，只存val不行吗？不行，因为容量满了，链表和hmap都要删除节点，而hmap需要key，只能从node中获取。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = <span class="built_in">dict</span>()  <span class="comment"># KN表&#123;key:Node&#125;</span></span><br><span class="line">        <span class="comment"># 使用伪头部和伪尾部节点    </span></span><br><span class="line">        self.head = DLinkedNode()  <span class="comment"># 头部存最近节点</span></span><br><span class="line">        self.tail = DLinkedNode()  <span class="comment"># 尾部为最少使用</span></span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 key 不存在，插入前处理超出容量</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt;= self.capacity:</span><br><span class="line">                <span class="comment"># 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment"># 删除哈希表中对应的项</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 创建一个新的节点</span></span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            <span class="comment"># 添加进哈希表</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="comment"># 添加至双向链表的头部</span></span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加：head后面插入node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = node</span><br><span class="line">        self.head.<span class="built_in">next</span> = node</span><br><span class="line">    <span class="comment"># 删除</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">    <span class="comment"># 删除(超出容量)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="comment"># 更新(node重新放入头部)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self, node</span>):</span> </span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br></pre></td></tr></table></figure>
<h2 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a>460. LFU 缓存</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGZ1LWNhY2hlLw==">https://leetcode-cn.com/problems/lfu-cache/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：请你为 <strong>最不经常使用（LFU）</strong> 缓存算法设计并实现数据结构。实现 LFUCache 类：<br><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象。<br><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。<br><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。<br>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。<br>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 <code>put</code> 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。<br>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</span><br><span class="line">解释：</span><br><span class="line">&#x2F;&#x2F; cnt(x) &#x3D; 键 x 的使用计数</span><br><span class="line">&#x2F;&#x2F; cache&#x3D;[] 将显示最后一次使用的顺序（最左边的元素是最近的）</span><br><span class="line">LFUCache lfu &#x3D; new LFUCache(2);</span><br><span class="line">lfu.put(1, 1);   &#x2F;&#x2F; cache&#x3D;[1,_], cnt(1)&#x3D;1</span><br><span class="line">lfu.put(2, 2);   &#x2F;&#x2F; cache&#x3D;[2,1], cnt(2)&#x3D;1, cnt(1)&#x3D;1</span><br><span class="line">lfu.get(1);      &#x2F;&#x2F; 返回 1</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[1,2], cnt(2)&#x3D;1, cnt(1)&#x3D;2</span><br><span class="line">lfu.put(3, 3);   &#x2F;&#x2F; 去除键 2 ，因为 cnt(2)&#x3D;1 ，使用计数最小</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;1, cnt(1)&#x3D;2</span><br><span class="line">lfu.get(2);      &#x2F;&#x2F; 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      &#x2F;&#x2F; 返回 3</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;2, cnt(1)&#x3D;2</span><br><span class="line">lfu.put(4, 4);   &#x2F;&#x2F; 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[4,3], cnt(4)&#x3D;1, cnt(3)&#x3D;2</span><br><span class="line">lfu.get(1);      &#x2F;&#x2F; 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      &#x2F;&#x2F; 返回 3</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;1, cnt(3)&#x3D;3</span><br><span class="line">lfu.get(4);      &#x2F;&#x2F; 返回 4</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;2, cnt(3)&#x3D;3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LFUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">-1</span>, val=<span class="number">-1</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.freq = <span class="number">1</span>  <span class="comment"># 记录频次</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = Node()</span><br><span class="line">        self.tail = Node()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.size = <span class="number">0</span>  <span class="comment"># 双向链表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加：head后面插入node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = node</span><br><span class="line">        self.head.<span class="built_in">next</span> = node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 删除</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 删除(超出容量)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    KN表：&#123;key:Node&#125;。</span></span><br><span class="line"><span class="string">    FD表：记录freq对应key，key可以有多个，所以用链表，&#123;频次:链表&#125;。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = &#123;&#125;  <span class="comment"># KN表</span></span><br><span class="line">        self.freq = defaultdict(DLinkedList)  <span class="comment"># FD表</span></span><br><span class="line">        self.size = <span class="number">0</span>   <span class="comment"># 元素个数</span></span><br><span class="line">        self.capacity = capacity  <span class="comment"># 容量</span></span><br><span class="line">        self.min_freq = <span class="number">0</span>  <span class="comment"># 记录最低频次，超出容量删除用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            <span class="comment"># 当前key频次+1：更新FK表,先在该频次链表中删除node,</span></span><br><span class="line">            self.freq[node.freq].removeNode(node)</span><br><span class="line">            <span class="comment"># 此频次为最低频次且为该频次链表唯一节点，最低频次也跟着+1</span></span><br><span class="line">            <span class="keyword">if</span> self.min_freq == node.freq <span class="keyword">and</span> self.freq[node.freq].size == <span class="number">0</span>:</span><br><span class="line">                self.min_freq += <span class="number">1</span></span><br><span class="line">            node.freq += <span class="number">1</span>  <span class="comment"># 频次+1</span></span><br><span class="line">            self.freq[node.freq].addToHead(node)  <span class="comment"># 加入新频次的链表</span></span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity == <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># key存在：更新val,freq(KN表,FD表)</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            self.freq[node.freq].removeNode(node)</span><br><span class="line">            <span class="keyword">if</span> self.min_freq == node.freq <span class="keyword">and</span> self.freq[node.freq].size == <span class="number">0</span>:</span><br><span class="line">                self.min_freq += <span class="number">1</span></span><br><span class="line">            node.freq += <span class="number">1</span></span><br><span class="line">            self.freq[node.freq].addToHead(node)</span><br><span class="line">        <span class="comment"># key不存在：插入新key，判断容量是否满了</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 容量满了：删除最低频次链表尾部节点(FD表,KN表)</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt;= self.capacity:</span><br><span class="line">                node = self.freq[self.min_freq].removeTail()</span><br><span class="line">                self.cache.pop(node.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            node = Node(key, value)</span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            self.freq[<span class="number">1</span>].addToHead(node)</span><br><span class="line">            self.min_freq = <span class="number">1</span></span><br><span class="line">            self.size += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="341-扁平化嵌套列表迭代器"><a href="#341-扁平化嵌套列表迭代器" class="headerlink" title="341. 扁平化嵌套列表迭代器"></a>341. 扁平化嵌套列表迭代器</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmxhdHRlbi1uZXN0ZWQtbGlzdC1pdGVyYXRvci8=">https://leetcode-cn.com/problems/flatten-nested-list-iterator/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个嵌套的整数列表 <code>nestedList</code> 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。实现扁平迭代器类 <code>NestedIterator</code> ：<br>（1）<code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> 用嵌套列表 <code>nestedList</code> 初始化迭代器。<br>（2）<code>int next()</code> 返回嵌套列表的下一个整数。<br>（3）<code>boolean hasNext()</code> 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。</p>
<p>示例 1：<br>输入：<code>nestedList = [[1,1],2,[1,1]]</code><br>输出：<code>[1,1,2,1,1]</code><br>解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: <code>[1,1,2,1,1]</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    可使用递归/迭代，这里使用迭代方法：</span></span><br><span class="line"><span class="string">    (1) 使用栈存储nestedList元素。</span></span><br><span class="line"><span class="string">    (2) 每次迭代是惰性的，只出一个元素。</span></span><br><span class="line"><span class="string">    栈是先进后出，而每次要出第一个元素，所以逆序入栈。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nestedList: [NestedInteger]</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化迭代器。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="comment"># 逆序入栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nestedList)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.stack.append(nestedList[i])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回嵌套列表的下一个整数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = self.stack.pop()</span><br><span class="line">        <span class="keyword">return</span> cur.getInteger()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 逆序入栈、出栈，直到第一个元素是整数结束。</span></span><br><span class="line">        <span class="keyword">while</span> self.stack:</span><br><span class="line">            cur = self.stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> cur.isInteger(): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.stack.pop()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cur.getList())<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    self.stack.append(cur.getList()[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="855-考场就座"><a href="#855-考场就座" class="headerlink" title="855. 考场就座"></a>855. 考场就座</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXhhbS1yb29tLw==">https://leetcode-cn.com/problems/exam-room/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：在考场里，一排有 <code>N</code> 个座位，分别编号为 <code>0, 1, 2, ..., N-1</code> 。当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)返回 <code>ExamRoom(int N)</code> 类，它有两个公开的函数：其中，函数 <code>ExamRoom.seat()</code> 会返回一个 <code>int</code> （整型数据），代表学生坐的位置；函数 <code>ExamRoom.leave(int p)</code> 代表坐在座位 <code>p</code> 上的学生现在离开了考场。每次调用 <code>ExamRoom.leave(p)</code> 时都保证有学生坐在座位 <code>p</code> 上。<br>示例：<br>输入：<code>[&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]</code><br>输出：<code>[null,0,9,4,2,null,5]</code><br>解释：<br><code>ExamRoom(10) -&gt; null</code><br><code>seat() -&gt; 0</code>，没有人在考场里，那么学生坐在 0 号座位上。<br><code>seat() -&gt; 9</code>，学生最后坐在 9 号座位上。<br><code>seat() -&gt; 4</code>，学生最后坐在 4 号座位上。<br><code>seat() -&gt; 2</code>，学生最后坐在 2 号座位上。<br><code>leave(4) -&gt; null</code><br><code>seat() -&gt; 5</code>，学生最后坐在 5 号座位上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamRoom</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    N：座位个数</span></span><br><span class="line"><span class="string">    students：学生位置</span></span><br><span class="line"><span class="string">    maxdist：线段最大长度</span></span><br><span class="line"><span class="string">    pos：学生应位置</span></span><br><span class="line"><span class="string">    posi：前一个学生位置</span></span><br><span class="line"><span class="string">    posj：后一个学生位置</span></span><br><span class="line"><span class="string">    d：两个学生之间距离(线段一半长度)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        self.N = N</span><br><span class="line">        self.students = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">seat</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.students: pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxdist, pos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j, posj <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.students):</span><br><span class="line">                <span class="keyword">if</span> j:</span><br><span class="line">                    posi = self.students[j<span class="number">-1</span>]</span><br><span class="line">                    d = (posj - posi) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> d &gt; maxdist: maxdist, pos = d, posi+d</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最后位置作为端点时，距离</span></span><br><span class="line">            d = self.N - <span class="number">1</span> - self.students[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> d &gt; maxdist: pos = self.N - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        bisect.insort(self.students, pos)</span><br><span class="line">        <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leave</span>(<span class="params">self, p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">in</span> self.students:</span><br><span class="line">            self.students.remove(p)</span><br></pre></td></tr></table></figure></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul>
<li>树和图的算法：<ul>
<li>递归：DFS用前序遍历、BFS用层序遍历。常用于简单题。</li>
<li>非递归：DFS用栈、BFS用队列。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 明确当前节点要做的事情，剩下的交给递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root: TreeNode</span>):</span></span><br><span class="line">    <span class="comment"># root要做什么？</span></span><br><span class="line">    <span class="comment"># 剩下交给递归</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    traverse(root.right)</span><br></pre></td></tr></table></figure>
<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2FtZS10cmVlLw==">https://leetcode-cn.com/problems/same-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br>示例 1：<br>输入：<code>p = [1,2,3], q = [1,2,3]</code><br>输出：<code>true</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q <span class="keyword">or</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure></p>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW52ZXJ0LWJpbmFyeS10cmVlLw==">https://leetcode-cn.com/problems/invert-binary-tree/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS1qaW5nLXhpYW5nLWxjb2Yv">剑指 Offer 27. 二叉树的镜像<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。请完成一个函数，输入一个二叉树，该函数输出它的镜像。<br>示例 1：<br>输入：<code>root = [4,2,7,1,3,6,9]</code><br>输出：<code>[4,7,2,9,6,3,1]</code></p>
<div class="tabs" id="226"><ul class="nav-tabs"><li class="tab active"><a href="#226-1">递归</a></li><li class="tab"><a href="#226-2">队列</a></li></ul><div class="tab-content"><div class="tab-pane active" id="226-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从下到上翻转。</span></span><br><span class="line"><span class="string">        既然返回根节点，那么一定是return root，中间要做的是递归子节点翻转，之后再翻转本节点子节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 递归子节点翻转</span></span><br><span class="line">        left = self.invertTree(root.left)</span><br><span class="line">        right = self.invertTree(root.right)</span><br><span class="line">        <span class="comment"># 翻转本节点子节点</span></span><br><span class="line">        root.left, root.right = right, left </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="226-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从上到下翻转。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 每次都从队列中拿第一个节点</span></span><br><span class="line">            tmp = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 如果当前节点的左子树不为空，则放入队列等待后续处理</span></span><br><span class="line">            <span class="keyword">if</span> tmp.left:</span><br><span class="line">                queue.append(tmp.left)</span><br><span class="line">            <span class="comment"># 如果当前节点的右子树不为空，则放入队列等待后续处理	</span></span><br><span class="line">            <span class="keyword">if</span> tmp.right:</span><br><span class="line">                queue.append(tmp.right)</span><br><span class="line">            <span class="comment"># 交换这个节点的左右子树</span></span><br><span class="line">            tmp.left,tmp.right = tmp.right,tmp.left</span><br><span class="line">        <span class="comment"># 返回处理完的根节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLWJpbmFyeS10cmVlcy8=">https://leetcode-cn.com/problems/merge-two-binary-trees/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。注意: 合并过程必须从两个树的根节点开始。</p>
<p>示例 1：<br>输入：<code>root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</code><br>输出：<code>[3,4,5,5,4,null,7]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, root1: TreeNode, root2: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当前节点计算和作为新节点返回，接着计算左、右子节点，两个有一个为空，返回另一个。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1: <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root2: <span class="keyword">return</span> root1</span><br><span class="line"></span><br><span class="line">        sums = TreeNode(root1.val + root2.val)</span><br><span class="line">        sums.left = self.mergeTrees(root1.left, root2.left)</span><br><span class="line">        sums.right = self.mergeTrees(root1.right, root2.right)</span><br><span class="line">        <span class="keyword">return</span> sums</span><br></pre></td></tr></table></figure></p>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。<br>示例：给定二叉树 <code>[3,9,20,null,null,15,7]</code>，返回它的最大深度 3 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当前高度 = max(左,右)+1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">        left_height = self.maxDepth(root.left) </span><br><span class="line">        right_height = self.maxDepth(root.right) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span> </span><br></pre></td></tr></table></figure></p>
<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv">https://leetcode-cn.com/problems/balanced-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。<br>示例 1：<br>输入：<code>root = [3,9,20,null,null,15,7]</code><br>输出：<code>true</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算树的高度，从低-&gt;高计算(从高-&gt;低会多算一次)，所以先递归到底，再计算。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            leftHeight = height(root.left)</span><br><span class="line">            rightHeight = height(root.right)</span><br><span class="line">            <span class="comment"># 左/右不是平衡，返回-1</span></span><br><span class="line">            <span class="keyword">if</span> leftHeight==<span class="number">-1</span> <span class="keyword">or</span> rightHeight==<span class="number">-1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(leftHeight-rightHeight)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1iaW5hcnktdHJlZS8=">https://leetcode-cn.com/problems/maximum-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建：<br>（1）创建一个根节点，其值为 nums 中的最大值。<br>（2）递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>（3）递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> nums == []: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 找出最大值和其索引</span></span><br><span class="line">        max_num = <span class="built_in">max</span>(nums)</span><br><span class="line">        max_index = nums.index(max_num)</span><br><span class="line">        root = TreeNode(max_num) </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        root.left = self.constructMaximumBinaryTree(nums[<span class="number">0</span> : max_index])</span><br><span class="line">        root.right = self.constructMaximumBinaryTree(nums[max_index + <span class="number">1</span> :])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLXNtYWxsZXN0LWVsZW1lbnQtaW4tYS1ic3Qv">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<p>输入：<code>root = [3,1,4,null,2], k = 1</code><br>输出：<code>1</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LWRlLWRpLWtkYS1qaWUtZGlhbi1sY29mLw==">剑指 Offer 54. 二叉搜索树的第k大节点<i class="fa fa-external-link-alt"></i></span>和本题相反，求第K大，中序遍历结果是由小到大，反序由大到小，即求中序遍历倒数第k的值。<br><div class="tabs" id="230"><ul class="nav-tabs"><li class="tab active"><a href="#230-1">K小，中序递归</a></li><li class="tab"><a href="#230-2">K大，中序递归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="230-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: Optional[TreeNode], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        res记录结果，count记录经过节点数目</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.count == <span class="number">0</span>:</span><br><span class="line">                self.res = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line"></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.count = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="230-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        此树的中序遍历倒序的第 k 个节点，</span></span><br><span class="line"><span class="string">        可反着中序遍历，右根左</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            dfs(root.right)  <span class="comment"># 先右</span></span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.count == <span class="number">0</span>:</span><br><span class="line">                self.res = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)  <span class="comment"># 后左</span></span><br><span class="line"></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.count = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="508-出现次数最多的子树元素和"><a href="#508-出现次数最多的子树元素和" class="headerlink" title="508. 出现次数最多的子树元素和"></a>508. 出现次数最多的子树元素和</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbW9zdC1mcmVxdWVudC1zdWJ0cmVlLXN1bS8=">https://leetcode-cn.com/problems/most-frequent-subtree-sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个二叉树的根结点 root ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。<br>示例 1：<br>输入: <code>root = [5,2,-3]</code><br>输出: <code>[2,-3,4]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findFrequentTreeSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        求出二叉树所有子树（包含根节点的树）的元素和，然后求出现次数最多的 元素和 ，且最多出现次数相同的 元素和 都要输出。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 递归计算节点和</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            sums = dfs(node.left) + node.val + dfs(node.right)</span><br><span class="line">            res[sums] = res.get(sums, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> sums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="comment"># 最多出现次数</span></span><br><span class="line">        max_cnt = <span class="built_in">max</span>(res.values())</span><br><span class="line">        <span class="comment"># 最多出现次 对应的 key</span></span><br><span class="line">        <span class="keyword">return</span> [key <span class="keyword">for</span> key, cnt <span class="keyword">in</span> res.items() <span class="keyword">if</span> cnt==max_cnt]   </span><br></pre></td></tr></table></figure></p>
<h2 id="从上到下打印二叉树-I-II-III"><a href="#从上到下打印二叉树-I-II-III" class="headerlink" title="从上到下打印二叉树 I/II/III"></a>从上到下打印二叉树 I/II/III</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uZy1zaGFuZy1kYW8teGlhLWRhLXlpbi1lci1jaGEtc2h1LWxjb2Yv">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/<i class="fa fa-external-link-alt"></i></span>，<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uZy1zaGFuZy1kYW8teGlhLWRhLXlpbi1lci1jaGEtc2h1LWlpLWxjb2Yv">剑指 Offer 32 - II.从上到下打印二叉树 II<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">102. 二叉树的层序遍历<i class="fa fa-external-link-alt"></i></span>相同，<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uZy1zaGFuZy1kYW8teGlhLWRhLXlpbi1lci1jaGEtc2h1LWlpaS1sY29mLw==">剑指 Offer 32 - III. 从上到下打印二叉树 III<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtemlnemFnLWxldmVsLW9yZGVyLXRyYXZlcnNhbC8=">103. 二叉树的锯齿形层序遍历<i class="fa fa-external-link-alt"></i></span>相同。<br><strong>题目描述</strong>：<br><strong>I</strong>：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。<br><strong>II</strong>：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。<br><strong>III</strong>：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。<br><div class="tabs" id="102"><ul class="nav-tabs"><li class="tab active"><a href="#102-1">层序遍历I</a></li><li class="tab"><a href="#102-2">层序遍历II</a></li><li class="tab"><a href="#102-3">层序遍历III</a></li></ul><div class="tab-content"><div class="tab-pane active" id="102-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, q = [], collections.deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="102-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, q = [], collections.deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="102-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先用层序遍历，把每层结果存储，再把奇数行反向输出。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        q = collections.deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):  <span class="comment"># 每层元素存储到tmp，每层tmp存储到res</span></span><br><span class="line">                node = q.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [res[i][::<span class="number">-1</span>]  <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> res[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res))]</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2h1LWRlLXppLWppZS1nb3UtbGNvZi8=">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br>示例 1：<br>输入：<code>A = [1,2,3], B = [3,1]</code><br>输出：<code>false</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span>(<span class="params">self, A: TreeNode, B: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归判断A的当前节点为根，能否构成整个B。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">A, B</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># B到头了，成功</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># A到头了/值不相等，不成功</span></span><br><span class="line">            <span class="keyword">return</span> recur(A.left, B.left) <span class="keyword">and</span> recur(A.right, B.right)  <span class="comment"># AB同时移动</span></span><br><span class="line">        <span class="comment"># AB不为空 且 A的根、左、右作为根，能否构成整个B</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(A <span class="keyword">and</span> B) <span class="keyword">and</span> (recur(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B))</span><br></pre></td></tr></table></figure></p>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LXl1LXNodWFuZy14aWFuZy1saWFuLWJpYW8tbGNvZi8=">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 递归左子树</span></span><br><span class="line">            dfs(cur.left) </span><br><span class="line">            <span class="comment"># 修改节点引用：当前节点前驱、上一节点后继</span></span><br><span class="line">            <span class="keyword">if</span> self.pre:</span><br><span class="line">                cur.left = self.pre</span><br><span class="line">                self.pre.right  = cur </span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 没有pre，为头节点</span></span><br><span class="line">                self.head = cur</span><br><span class="line">            self.pre = cur <span class="comment"># 保存cur为下一节点pre</span></span><br><span class="line">            <span class="comment"># 递归右子树</span></span><br><span class="line">            dfs(cur.right) </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="comment"># 结束时处理head：最后节点的后继为head，head的前驱为最后节点</span></span><br><span class="line">        self.pre.right = self.head</span><br><span class="line">        self.head.left = self.pre</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure></p>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20tcHJlb3JkZXItYW5kLWlub3JkZXItdHJhdmVyc2FsLw==">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。<br>示例 1:<br>输入: <code>preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</code><br>输出: <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前序遍历：第一个为根节点</span></span><br><span class="line"><span class="string">        中序遍历：找到根节点索引k，其左侧为左子树(0~k-1,k个元素)，右侧为右子树(k+1~结尾)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])  <span class="comment"># 创建根节点</span></span><br><span class="line">        k = inorder.index(preorder[<span class="number">0</span>]) <span class="comment"># 找到根节点在index索引，左子树有k个元素</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:k+<span class="number">1</span>], inorder[<span class="number">0</span>:k])  </span><br><span class="line">        root.right = self.buildTree(preorder[k+<span class="number">1</span>:], inorder[k+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="098-验证二叉搜索树"><a href="#098-验证二叉搜索树" class="headerlink" title="098. 验证二叉搜索树"></a>098. 验证二叉搜索树</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWRhdGUtYmluYXJ5LXNlYXJjaC10cmVlLw==">https://leetcode-cn.com/problems/validate-binary-search-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>（1）节点的左子树只包含 <strong>小于</strong> 当前节点的数。<br>（2）节点的右子树只包含 <strong>大于</strong> 当前节点的数。<br>（3）所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>示例 1：<br>输入：<code>root = [2,1,3]</code><br>输出：<code>true</code></p>
<p>示例 2：<br>输入：<code>root = [5,1,4,null,null,3,6]</code><br>输出：<code>false</code><br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 自定义一个带min和max的函数，每次递归判断</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node:TreeNode, <span class="built_in">min</span>:TreeNode, <span class="built_in">max</span>:TreeNode</span>) -&gt; bool:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">min</span> <span class="keyword">and</span> (node.val&lt;=<span class="built_in">min</span>.val): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">max</span> <span class="keyword">and</span> (node.val&gt;=<span class="built_in">max</span>.val): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> helper(node.left, <span class="built_in">min</span>, node) <span class="keyword">and</span> helper(node.right, node, <span class="built_in">max</span>)</span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="literal">None</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2VhcmNoLWluLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>
<p>示例 1:<br>输入：<code>root = [4,2,7,1,3], val = 2</code><br>输出：<code>[2,1,3]</code></p>
<div class="tabs" id="700"><ul class="nav-tabs"><li class="tab active"><a href="#700-1">递归</a></li><li class="tab"><a href="#700-2">迭代</a></li></ul><div class="tab-content"><div class="tab-pane active" id="700-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> val == root.val: <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 根据搜索树左小右大，进行递归</span></span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root.left <span class="keyword">if</span> val &lt; root.val <span class="keyword">else</span> root.right, val)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="700-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> val == root.val:<span class="keyword">return</span> root</span><br><span class="line">            root = root.left <span class="keyword">if</span> val &lt; root.val <span class="keyword">else</span> root.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW5zZXJ0LWludG8tYS1iaW5hcnktc2VhcmNoLXRyZWUv">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p>示例 1：<br>输入：<code>root = [4,2,7,1,3], val = 5</code><br>输出：<code>[4,2,7,1,3,5]</code>/<code>[5,2,7,1,3,4]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val) <span class="comment"># 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span></span><br><span class="line">        <span class="keyword">if</span>  val &gt; root.val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val) <span class="comment"># 递归创建右子树</span></span><br><span class="line">        <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val) <span class="comment"># 递归创建左子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a>450. 删除二叉搜索树中的节点</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGVsZXRlLW5vZGUtaW4tYS1ic3Qv">https://leetcode-cn.com/problems/delete-node-in-a-bst/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉搜索树的根节点 <code>root</code> 和一个值 <code>key</code>，删除二叉搜索树中的 <code>key</code> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。</p>
<p>示例 1:<br>输入：<code>root = [5,3,6,2,4,null,7], key = 3</code><br>输出：<code>[5,4,6,2,null,null,7]</code><br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。另一个正确答案是 <code>[5,2,6,null,4,null,7]</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: Optional[TreeNode], key: <span class="built_in">int</span></span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 找到节点时</span></span><br><span class="line">        <span class="keyword">if</span> key == root.val:</span><br><span class="line">            <span class="comment"># 找到节点时，其有1个/0个子节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left: <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="comment"># 找到节点时，其有2个子节点，可找 左侧最大/右侧最小 作为新节点，这里选右侧最小</span></span><br><span class="line">            minNode = self.getRightMin(root.right)</span><br><span class="line">            root.val = minNode.val</span><br><span class="line">            root.right = self.deleteNode(root.right, minNode.val)</span><br><span class="line">        <span class="comment"># 没找到节点时，递归</span></span><br><span class="line">        <span class="keyword">elif</span> key &gt; root.val:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> key &lt; root.val:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRightMin</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">while</span> node.left: node = node.left</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></p>
<h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtY29tcGxldGUtdHJlZS1ub2Rlcy8=">https://leetcode-cn.com/problems/count-complete-tree-nodes/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~2^h</code> 个节点。<br>示例 1：<br>输入：<code>root = [1,2,3,4,5,6]</code><br>输出：<code>6</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据完全二叉树性质，其有右节点必有左节点(建树时先左后右)，</span></span><br><span class="line"><span class="string">        所以有右节点高度和左节点高度对比，能确定是不是满二叉树。</span></span><br><span class="line"><span class="string">        其次，左侧的递归一定会触发hl == hr而立即返回，不会递归下去，</span></span><br><span class="line"><span class="string">        所以只有右侧会递归，时间复杂度为log(n)。</span></span><br><span class="line"><span class="string">        总体时间复杂度：while的log(n)和递归log(n)，O(log(n)*log(n))。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = r = root</span><br><span class="line">        hl = hr = <span class="number">0</span>  <span class="comment"># 记录左右子树高度</span></span><br><span class="line">        <span class="keyword">while</span> l: </span><br><span class="line">            l = l.left</span><br><span class="line">            hl += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r:</span><br><span class="line">            r = r.right  </span><br><span class="line">            hr += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果左右子树高度相同，说明是一棵满二叉树</span></span><br><span class="line">        <span class="keyword">if</span> hl == hr: <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">2</span>,hl)<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 如果左右子树高度相同，按照普通二叉树逻辑计算</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + self.countNodes(root.left) + self.countNodes(root.right)</span><br></pre></td></tr></table></figure></p>
<h2 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a>297. 二叉树的序列化与反序列化</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2VyaWFsaXplLWFuZC1kZXNlcmlhbGl6ZS1iaW5hcnktdHJlZS8=">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个<strong>字符串</strong>并且将这个<strong>字符串</strong>反序列化为原始的树结构。<br>示例 1：<br>输入：<code>root = [1,2,3,null,null,4,5]</code><br>输出：<code>[1,2,3,null,null,4,5]</code></p>
<p>注意：中序遍历无法反序列化，因为首先要找到根节点，前序遍历首节点、后序遍历尾节点为根节点，而中序遍历列表，无法找到根节点。<br><div class="tabs" id="297"><ul class="nav-tabs"><li class="tab active"><a href="#297-1">前序遍历</a></li><li class="tab"><a href="#297-2">后序遍历</a></li><li class="tab"><a href="#297-3">层序遍历</a></li></ul><div class="tab-content"><div class="tab-pane active" id="297-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根左右，先操作，后左右递归。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ser</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">            <span class="comment"># 根，左，右</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;root.val&#125;</span>,<span class="subst">&#123;ser(root.left)&#125;</span>,<span class="subst">&#123;ser(root.right)&#125;</span>&quot;</span> </span><br><span class="line">        <span class="keyword">return</span> ser(root) </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># [根，左，右]</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">des</span>(<span class="params">nodes</span>):</span></span><br><span class="line">            first = nodes.popleft()   <span class="comment"># 根</span></span><br><span class="line">            <span class="keyword">if</span> first <span class="keyword">and</span> first == <span class="string">&#x27;#&#x27;</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(first))</span><br><span class="line">            root.left = des(nodes)  <span class="comment"># 左</span></span><br><span class="line">            root.right = des(nodes)  <span class="comment"># 右</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        nodes = deque(data.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> des(nodes)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="297-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ser</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">            <span class="comment"># 左，右，根</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;ser(root.left)&#125;</span>,<span class="subst">&#123;ser(root.right)&#125;</span>,<span class="subst">&#123;root.val&#125;</span>&quot;</span> </span><br><span class="line">        <span class="keyword">return</span> ser(root) </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">des</span>(<span class="params">nodes</span>):</span></span><br><span class="line">            <span class="comment"># [左, 右, 根]</span></span><br><span class="line">            first = nodes.pop()  <span class="comment"># 根</span></span><br><span class="line">            <span class="keyword">if</span> first <span class="keyword">and</span> first == <span class="string">&#x27;#&#x27;</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(first))</span><br><span class="line">            root.right = des(nodes)  <span class="comment"># 右</span></span><br><span class="line">            root.left = des(nodes)  <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        nodes = deque(data.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> des(nodes)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="297-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        q = deque([root])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                res.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="built_in">str</span>(cur.val))</span><br><span class="line">            q.append(cur.left)</span><br><span class="line">            q.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(res)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        nodes = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nodes <span class="keyword">or</span> nodes[<span class="number">0</span>]==<span class="string">&#x27;#&#x27;</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(nodes[<span class="number">0</span>])</span><br><span class="line">        q = collections.deque([root])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根，左、右，需同时表示</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nodes), <span class="number">2</span>):  <span class="comment"># 每次添加左右两个子节点</span></span><br><span class="line">            node = q.popleft()</span><br><span class="line">            left = nodes[i]</span><br><span class="line">            right = nodes[i+<span class="number">1</span>]   </span><br><span class="line">            <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">if</span> left != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                node.left = TreeNode(left)</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="comment"># 右</span></span><br><span class="line">            <span class="keyword">if</span> right != <span class="string">&#x27;#&#x27;</span>: </span><br><span class="line">                node.right = TreeNode(right)</span><br><span class="line">                q.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="235-236-二叉-搜索树-的最近公共祖先"><a href="#235-236-二叉-搜索树-的最近公共祖先" class="headerlink" title="235/236. 二叉(搜索树)的最近公共祖先"></a>235/236. 二叉(搜索树)的最近公共祖先</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">235. 二叉搜索树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LWRlLXp1aS1qaW4tZ29uZy1nb25nLXp1LXhpYW4tbGNvZi8=">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>，<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS10cmVlLw==">236. 二叉树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWxjb2Yv">剑指 Offer 68 - II. 二叉树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给定一个二叉(搜索树), 找到该树中两个指定节点的最近公共祖先。最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>二叉树看这个解答：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWxjb2Yvc29sdXRpb24vbWlhbi1zaGktdGktNjgtaWktZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uLTcv">Krahets 题解<i class="fa fa-external-link-alt"></i></span>。<br><div class="tabs" id="235"><ul class="nav-tabs"><li class="tab active"><a href="#235-1">二叉搜索树</a></li><li class="tab"><a href="#235-2">二叉树</a></li></ul><div class="tab-content"><div class="tab-pane active" id="235-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当p和p在一个节点两侧时，此节点为最近公共祖先。</span></span><br><span class="line"><span class="string">        利用二叉搜索树性质，左小右大。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ancestor = root</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; ancestor.val <span class="keyword">and</span> q.val &lt; ancestor.val:</span><br><span class="line">                ancestor = ancestor.left</span><br><span class="line">            <span class="keyword">elif</span> p.val &gt; ancestor.val <span class="keyword">and</span> q.val &gt; ancestor.val:</span><br><span class="line">                ancestor = ancestor.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ancestor</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="235-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1.root为空，说明结束，返回None</span></span><br><span class="line"><span class="string">        2.root为p/q，说明root为最近公共祖先，返回root</span></span><br><span class="line"><span class="string">        left, right：</span></span><br><span class="line"><span class="string">            3.都为空：说明左,右子树都不包含q,p，返回None</span></span><br><span class="line"><span class="string">            4.都不为空：说明p,q在root为根的两侧，返回root</span></span><br><span class="line"><span class="string">            5.有一个为空：说明q,q都在另一个不空的树，返回不空的结果</span></span><br><span class="line"><span class="string">        5中包括了3。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q: <span class="keyword">return</span> root  <span class="comment"># 1,2</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right  <span class="comment"># 5</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left  <span class="comment"># 5</span></span><br><span class="line">        <span class="keyword">return</span> root  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><strong>单调递减栈</strong>：栈底到栈顶（入栈和出栈）是递减的，遇到大的pop栈中小的，再存储大的。从左到右，能得到当前值右侧第一个比其大的值。<br><strong>单调递增栈</strong>：栈底到栈顶（入栈和出栈）是递增的，遇到小的pop栈中大的，再存储小的。从左到右，能得到当前值右侧第一个比其小的值。<br><strong>注意</strong>：有些题解中的单调栈和上面解释<strong>相反</strong>，但本质都是找边界，理解核心最重要。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模板，求nums下一个更大元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums:List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">-1</span>] * n  <span class="comment"># 存放结果</span></span><br><span class="line">        stack = [] <span class="comment"># 单调递减</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算每个位置下一更大元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]]&lt;nums[i]:  <span class="comment"># num不符合单调递减</span></span><br><span class="line">                small = stack.pop()</span><br><span class="line">                res[small] = nums[i]</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLWVsZW1lbnQtaS8=">https://leetcode-cn.com/problems/next-greater-element-i/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <code>0</code> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <code>下一个更大元素</code> 。<br>示例 1：<br>输入：<code>nums1 = [4,1,2], nums2 = [1,3,4,2]</code><br>输出：<code>[-1,3,-1]</code><br>解释：nums1 中每个值的下一个更大元素如下所述：<br>4 ，用加粗斜体标识，<code>nums2 = [1,3,4,2]</code>。不存在下一个更大元素，所以答案是 -1 。<br>1 ，用加粗斜体标识，<code>nums2 = [1,3,4,2]</code>。下一个更大元素是 3 。<br>2 ，用加粗斜体标识，<code>nums2 = [1,3,4,2]</code>。不存在下一个更大元素，所以答案是 -1 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        本质上nums2自己找下一更大元素，最后用nums1匹配。</span></span><br><span class="line"><span class="string">        因为 没有重复元素，可以用哈希表存储结果。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="built_in">dict</span>()  <span class="comment"># 记录nums2元素下一更大值</span></span><br><span class="line">        stack = []  <span class="comment"># 单调递减栈</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="comment"># 不是递减，num为栈中所有元素下一更大值</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>]&lt;num:  </span><br><span class="line">                small = stack.pop()</span><br><span class="line">                res[small] = num</span><br><span class="line">            stack.append(num)</span><br><span class="line">        <span class="comment"># 在nums1中找到res对应的值</span></span><br><span class="line">        <span class="keyword">return</span> [res[num] <span class="keyword">if</span> num <span class="keyword">in</span> res <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure></p>
<h2 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a>503. 下一个更大元素 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLWVsZW1lbnQtaWkv">https://leetcode-cn.com/problems/next-greater-element-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个<strong>循环数组</strong> <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <code>nums</code> 中每个元素的 <strong>下一个更大元素</strong> 。数字 <code>x</code> 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。<br>示例 1:<br>输入: <code>nums = [1,2,1]</code><br>输出: <code>[2,-1,2]</code><br>解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环数组，在计算 nums[i] 时，也要把该序列的前 n-1 个元素考虑进去，</span></span><br><span class="line"><span class="string">        只需在计算下标 i 时，让i走n次，最长是在最后一位，前面走了n次，接下来再走n次，所以最长2n次，</span></span><br><span class="line"><span class="string">        下标按n折半取余就是循环下标。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">-1</span>] * n</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]]&lt;nums[i%n]:</span><br><span class="line">                res[stack.pop()] = nums[i%n]</span><br><span class="line">            stack.append(i%n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a>1019. 链表中的下一个更大节点</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLW5vZGUtaW4tbGlua2VkLWxpc3Qv">https://leetcode-cn.com/problems/next-greater-node-in-linked-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个长度为 <code>n</code> 的链表 <code>head</code>。对于列表中的每个节点，查找下一个 <strong>更大节点</strong> 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 <strong>严格大于</strong> 它的值。返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个节点( 从1开始 )的下一个更大的节点的值。如果第 <code>i</code> 个节点没有下一个更大的节点，设置 <code>answer[i] = 0</code> 。</p>
<p>示例 1：<br>输入：<code>head = [2,1,5]</code><br>输出：<code>[5,5,0]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLW5vZGUtaW4tbGlua2VkLWxpc3Qvc29sdXRpb24vcHl0aG9uLWRhbi1kaWFvLXpoYW4tYnktamFja3dlbmVyLw==">jackvin题解<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLW5vZGUtaW4tbGlua2VkLWxpc3Qvc29sdXRpb24vMTAxOS1saWFuLWJpYW8temhvbmctZGUteGlhLXlpLWdlLWdlbmctZGEtamllLWRpYW4v">tuotuoli题解<i class="fa fa-external-link-alt"></i></span>。</p>
<p><strong>题目解析</strong>：</p>
<ul>
<li>题目是链表，可以转成列表(模拟栈)。</li>
<li><strong>正向思维</strong>：假如列表是<code>[5,4,7,4,3,6]</code>，<strong>正序</strong>入栈是<code>[5,4]</code>这样单调递减的，直到不是单调递减的<code>[7]</code>，表示<code>[7]</code>比栈顶大且索引是最小的，此时pop栈顶<code>[4]</code>, 记录<code>[4]</code>对应索引值结果为<code>[7]</code>，再判断栈顶<code>[5]&lt;=[7]</code>，也pop栈顶<code>[5]</code>, 记录<code>[5]</code>对应索引值结果为<code>[7]</code>，直到 <strong>栈为空</strong> 或 <strong>栈顶&gt;当前值</strong> 再继续把当前值入栈比较。</li>
<li><strong>逆向思维</strong>：列表<strong>逆序</strong>入栈，列表同上，栈起始值应为<code>[0]</code>, <code>[6]</code>为最后一个元素（后面没有比它大的了所以对应位置结果直接写<code>[0]</code>），入栈<code>[0,6]</code>，当遇到<strong>栈顶&gt;当前元素</strong>（<code>[6]&gt;[3]</code>），表示<code>[3]</code>后面第一个大于它的是<code>[6]</code>，此时<code>[3]</code>先入栈，再更新列表<code>[3]</code>为<code>[6]</code>。</li>
</ul>
<div class="tabs" id="1019"><ul class="nav-tabs"><li class="tab active"><a href="#1019-1">正向单调栈</a></li><li class="tab"><a href="#1019-2">逆向单调栈</a></li></ul><div class="tab-content"><div class="tab-pane active" id="1019-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span>(<span class="params">self, head: ListNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = head</span><br><span class="line">        ans = []  <span class="comment"># 存结果</span></span><br><span class="line">        stack = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 当 栈不为空，且 当前节点值&gt;栈最后一个值 时，存储</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">1</span>] &lt; cur.val:</span><br><span class="line">                ans[stack[<span class="number">-1</span>][<span class="number">0</span>]] = cur.val</span><br><span class="line">                stack.pop()</span><br><span class="line">            stack.append((i, cur.val))  <span class="comment"># 入栈(索引, 值)</span></span><br><span class="line">            ans.append(<span class="number">0</span>)  <span class="comment"># 每入栈一个，就在结果中添加一个占位值0</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="1019-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span>(<span class="params">self, head: ListNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 链表转列表，起始栈为[0]，栈存储当前元素之后的元素</span></span><br><span class="line">        vals, stack = [], [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            vals.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 逆序遍历   </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vals)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 栈顶元素&lt;=当前元素，表示栈顶不是要找的元素，pop掉</span></span><br><span class="line">            <span class="keyword">while</span> stack[<span class="number">-1</span>] <span class="keyword">and</span> vals[i] &gt;= stack[<span class="number">-1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="comment"># 栈顶元素&gt;当前元素，表示栈顶是当前元素下一个更大值，先入栈，再更新</span></span><br><span class="line">            stack.append(vals[i])</span><br><span class="line">            vals[i] = stack[<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vals</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGFpbHktdGVtcGVyYXR1cmVzLw==">https://leetcode-cn.com/problems/daily-temperatures/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指在第 <code>i</code> 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p>示例 1:<br>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p>
<p>示例 2:<br>输入: temperatures = [30,40,50,60]<br>输出: [1,1,1,0]</p>
<p>示例 3:<br>输入: temperatures = [30,60,90]<br>输出: [1,1,0]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    栈记录索引pre，遇到第一个温度比其高的索引i，相差天数：i-pre</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[stack[<span class="number">-1</span>]]&lt;temperatures[i]:</span><br><span class="line">                pre = stack.pop()</span><br><span class="line">                res[pre] = i - pre</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure></p>
<h2 id="907-子数组的最小值之和"><a href="#907-子数组的最小值之和" class="headerlink" title="907. 子数组的最小值之和"></a>907. 子数组的最小值之和</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VtLW9mLXN1YmFycmF5LW1pbmltdW1zLw==">https://leetcode-cn.com/problems/sum-of-subarray-minimums/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code> 的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。由于答案可能很大，因此 返回答案模 <code>10^9+7</code> 。<br>示例 1：<br>输入：<code>arr = [3,1,2,4]</code><br>输出：<code>17</code><br>解释：<br>子数组为 <code>[3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]</code>。<br>最小值为 <code>3，1，2，4，1，1，2，1，1，1</code>，和为 <code>17</code>。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VtLW9mLXN1YmFycmF5LW1pbmltdW1zL3NvbHV0aW9uL3hpYW8tYmFpLWxhbmctZG9uZy1odWEteGlhbmctamllLWJhby16aGUtNDg5cS8=">超小白 讲解<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VtLW9mLXN1YmFycmF5LW1pbmltdW1zL3NvbHV0aW9uL3B5dGhvbjMtdG9uZy04NHRpLXp1aS1kYS16aGktZmFuZy10dS1ieS01ZXJzdy8=">Justin Yuan 代码<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubarrayMins</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        arr = [<span class="number">-1</span>] + arr + [<span class="number">-1</span>]  <span class="comment"># 防止左侧越界、防止右侧留存在栈中(栈不为空结束)</span></span><br><span class="line">        stack, res = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="comment"># 确定右边界：当前值作为最小值，右边界就是比其小的（这中间都是比其大的）</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> arr[i]&lt;arr[stack[<span class="number">-1</span>]]:</span><br><span class="line">                cur = stack.pop() <span class="comment"># 当前值索引</span></span><br><span class="line">                <span class="comment"># 下面stack[-1]为左边界，res=当前值*贡献次数(右边界到当前值个数*当前值到左边界个数)</span></span><br><span class="line">                res += arr[cur]*(i-cur)*(cur-stack[<span class="number">-1</span>]) </span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a>402. 移掉 K 位数字</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWstZGlnaXRzLw==">https://leetcode-cn.com/problems/remove-k-digits/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。<br>示例 1 ：<br>输入：<code>num = &quot;1432219&quot;, k = 3</code><br>输出：<code>&quot;1219&quot;</code><br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</p>
<p>示例 2 ：<br>输入：<code>num = &quot;10200&quot;, k = 1</code><br>输出：<code>&quot;200&quot;</code><br>解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<p>示例 3 ：<br>输入：<code>num = &quot;10&quot;, k = 2</code><br>输出：<code>&quot;0&quot;</code><br>解释：从原数字移除所有的数字，剩余为空就是 0 。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWstZGlnaXRzL3NvbHV0aW9uL3lpLXpoYW8tY2hpLWJpYW4tbGkta291LXNpLWRhby10aS1tYS1tYS16YWkteWUtYi01Lw==">fe-lucifer 题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span>(<span class="params">self, num: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        remain = <span class="built_in">len</span>(num)-k</span><br><span class="line">        <span class="comment"># 单调递增栈，遇到小的把大的弹出，弹出个数为k个结束</span></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; digit:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(digit)</span><br><span class="line">        <span class="comment"># 保留栈中前n-k个数，最后结果左边去0即为正常数</span></span><br><span class="line">        <span class="comment"># 如果结果为&#x27;&#x27;，应当返回&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack[:remain]).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="768-最多能完成排序的块-II"><a href="#768-最多能完成排序的块-II" class="headerlink" title="768. 最多能完成排序的块 II"></a>768. 最多能完成排序的块 II</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LWNodW5rcy10by1tYWtlLXNvcnRlZC1paS8=">https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<code>arr</code> 是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。我们最多能将数组分成多少块？</p>
<p>示例 1:<br>输入: <code>arr = [5,4,3,2,1]</code><br>输出: <code>1</code><br>解释: 将数组分成2块或者更多块，都无法得到所需的结果。例如，分成 <code>[5, 4], [3, 2, 1]</code> 的结果是 <code>[4, 5, 1, 2, 3]</code>，这不是有序的数组。 </p>
<p>示例 2:<br>输入: <code>arr = [2,1,3,4,4]</code><br>输出: <code>4</code><br>解释:我们可以把它分成两块，例如 <code>[2, 1], [3, 4, 4]</code>。然而，分成 <code>[2, 1], [3], [4], [4]</code> 可以得到最多的块数。 </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LWNodW5rcy10by1tYWtlLXNvcnRlZC1paS9zb2x1dGlvbi96dWktZHVvLW5lbmctd2FuLWNoZW5nLXBhaS14dS1kZS1rdWFpLWlpLWRlbmctamllLS8=">Krahets 题解<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxChunksToSorted</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="comment"># 栈递增，找到右侧小值时，小值向前推到小于等于它为止(此块最小值&gt;前一个块最大值)</span></span><br><span class="line">            <span class="comment"># stack[-1]为当前块最大值(最后保存此值代表当前块)</span></span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> num &lt; stack[<span class="number">-1</span>]: </span><br><span class="line">                head = stack.pop()</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> num &lt; stack[<span class="number">-1</span>]: stack.pop()</span><br><span class="line">                stack.append(head)</span><br><span class="line">            <span class="keyword">else</span>: stack.append(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack)</span><br></pre></td></tr></table></figure></p>
<h2 id="042-接雨水"><a href="#042-接雨水" class="headerlink" title="042. 接雨水"></a>042. 接雨水</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHJhcHBpbmctcmFpbi13YXRlci8=">https://leetcode-cn.com/problems/trapping-rain-water/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>示例 1：<br>输入：<code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code><br>输出：<code>6</code><br>解释：上面是由数组 <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code> 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<p><strong>题目解析</strong>：</p>
<ul>
<li>雨水量等于 <strong>两边柱子最高高度的最小值-当前柱子高度</strong>，即<code>min(max(left),max(right))-height[i]</code>。</li>
<li>积水只能在低处形成，当后面柱子高度比前面柱子低时，无法接雨水，所以使用<strong>单调递减栈</strong>存储可能储水的柱子，当找到一根比前面高的柱子，就可以计算接到的雨水。</li>
</ul>
<div class="tabs" id="42"><ul class="nav-tabs"><li class="tab active"><a href="#42-1">单调栈</a></li><li class="tab"><a href="#42-2">双指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="42-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height)):</span><br><span class="line">            <span class="comment"># 栈不为空 + (当前高度&gt;前一个高度)</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i]&gt;height[stack[<span class="number">-1</span>]]:</span><br><span class="line">                <span class="comment"># 3个值计算一次：</span></span><br><span class="line">                <span class="comment"># 当前值(右侧最高处)+栈倒数第一个(最矮的地方)+栈倒数第二个(左侧最高处)</span></span><br><span class="line">                top = stack.pop()  <span class="comment"># 最矮的地方</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:<span class="keyword">break</span>  <span class="comment"># 栈可能只有一个值，此时不用计算</span></span><br><span class="line">                left = stack[<span class="number">-1</span>]  <span class="comment"># 左侧最高处</span></span><br><span class="line">                <span class="comment"># 宽度 = 高索引-低索引-1</span></span><br><span class="line">                currWidth = i - left - <span class="number">1</span>  </span><br><span class="line">                <span class="comment"># 高度 = min(左侧最高处,右侧最高处)-最矮的地方</span></span><br><span class="line">                currHeight = <span class="built_in">min</span>(height[left], height[i]) - height[top] </span><br><span class="line">                ans += currWidth * currHeight  <span class="comment"># 累加雨水</span></span><br><span class="line">            stack.append(i)  <span class="comment"># 添加当前值索引</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="42-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        left, right：左右索引。</span></span><br><span class="line"><span class="string">        leftMax, rightMax：height[0~left]最高值，height[right~n-1]最高值。</span></span><br><span class="line"><span class="string">        ans：接雨水总量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">        leftMax = rightMax = <span class="number">0</span>  <span class="comment"># 存储左、右两侧最高值，当成左边界和右边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 更新左右两侧最高值</span></span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, height[left])</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax, height[right])</span><br><span class="line">            <span class="comment"># 当前左高度&lt;右高度，从左-&gt;右累加(按左柱子高度接雨水)</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                ans += leftMax - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 否则，从右-&gt;左累加(按右柱子高度接雨水)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += rightMax - height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="084-柱状图中最⼤的矩阵"><a href="#084-柱状图中最⼤的矩阵" class="headerlink" title="084. 柱状图中最⼤的矩阵"></a>084. 柱状图中最⼤的矩阵</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtLw==">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定 <code>n</code> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p>示例 1:<br>输入：<code>heights = [2,1,5,6,2,3]</code><br>输出：<code>10</code><br>解释：最大的矩形为图中红色区域，面积为 10</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtL3NvbHV0aW9uLzg0LXpodS16aHVhbmctdHUtemhvbmctenVpLWRhLWRlLWp1LXhpbmctZHVvLWNob25nLw==">力扣加加题解<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8temhhbi04NHpodS16aHUtMDN3My8=">编程狂想曲 动画演示<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目解析</strong>：我们需要找到<strong>左右两侧最近的高度小于 当前柱子高度 的柱子</strong>，这是当前柱子能向左右扩张的边界(能计算宽度)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]  <span class="comment"># 加2个哨兵，防止stack[-1]越界、栈不为空结束</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="comment"># 找到栈顶柱子为高的右边界(比栈顶矮的为边界)      </span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]]&gt;heights[i]:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                <span class="comment"># 此时，stack[-1]为栈顶柱子tmp左边界</span></span><br><span class="line">                <span class="comment"># 面积 = max(上次最大面积, 当前柱子为高的面积: (右边界-左边界-1) * (当前柱子高))</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, (i-stack[<span class="number">-1</span>]<span class="number">-1</span>) * heights[tmp])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">链表有4种类型：</span><br><span class="line">- 判断链表中是否含有环？</span><br><span class="line">    - 141. 环形链表</span><br><span class="line">- 已知链表中有环，返回这个环的起始位置。</span><br><span class="line">    - 142. 环形链表 II</span><br><span class="line">- 寻找无环单链表中点。</span><br><span class="line">    - 234. 回文链表</span><br><span class="line">    - 143. 重排链表</span><br><span class="line">- 寻找单链表的倒数第k个元素。</span><br><span class="line">    - 19. 删除链表的倒数第N个节点</span><br><span class="line"></span><br><span class="line">字符串有4种类型：</span><br><span class="line">- 二分搜索(可算成一大类，单独列出)</span><br><span class="line">- n数之和</span><br><span class="line">- 反转数组</span><br><span class="line">- 滑动窗口(可算成一大类，单独列出)</span><br></pre></td></tr></table></figure>
<h2 id="026-删除有序数组中的重复项"><a href="#026-删除有序数组中的重复项" class="headerlink" title="026. 删除有序数组中的重复项"></a>026. 删除有序数组中的重复项</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtYXJyYXkv">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。将最终结果插入 nums 的前 k 个位置后返回 k 。<strong>不要使用额外的空间</strong>，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br>示例 1：<br>输入：<code>nums = [1,1,2]</code><br>输出：<code>2, nums = [1,2,_]</code><br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除数组重复元素，且要O(1)空间复杂度，那么可考虑把要删除的元素移动到尾部，然后pop。</span></span><br><span class="line"><span class="string">        快慢指针：slow位置为存储下一个不重复元素，fast找到一个不重复元素就填到slow位置，并让slow前进一步，</span></span><br><span class="line"><span class="string">                  这样fast走完，nums[0~slow-1]就是不重复元素。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        slow = fast = <span class="number">1</span>  <span class="comment"># 保持 相对顺序，从1开始</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[fast<span class="number">-1</span>]:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow  <span class="comment"># 长度为slow</span></span><br></pre></td></tr></table></figure></p>
<h2 id="141-环形链表-快慢"><a href="#141-环形链表-快慢" class="headerlink" title="141. 环形链表(快慢)"></a>141. 环形链表(快慢)</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv">https://leetcode-cn.com/problems/linked-list-cycle/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。<br>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p>示例 1：<br>输入：<code>head = [3,2,0,-4], pos = 1</code><br>输出：<code>true</code><br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUvc29sdXRpb24vaHVhbi14aW5nLWxpYW4tYmlhby1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">官方题解<i class="fa fa-external-link-alt"></i></span>。</p>
<p><strong>方法一：哈希表法</strong></p>
<ul>
<li>时间复杂度：$O(n)$，对于含有 <code>n</code> 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 $O(1)$ 的时间。</li>
<li>空间复杂度：$O(n)$，空间取决于添加到哈希表中的元素数目，最多可以添加 <code>n</code> 个元素。</li>
</ul>
<p><strong>方法二：快慢双指针法</strong></p>
<ul>
<li>时间复杂度：$O(n)$，让我们将 <code>n</code> 设为链表中结点的总数。为了分析时间复杂度，我们分别考虑下面两种情况：<ul>
<li>链表中不存在环：快指针将会首先到达尾部，其时间取决于列表的长度，也就是 $O(n)$ 。</li>
<li>链表中存在环：我们将慢指针的移动过程划分为 <code>非环部分</code> 与 <code>环形部分</code> 两个阶段：<ol>
<li>慢指针在走完<code>非环部分</code>阶段后将进入<code>环形部分</code>：此时，快指针已经进入环中 $\text{迭代次数} = \text{非环部分长度} = n$。</li>
<li>两个指针都在环形区域中：考虑两个在环形赛道上的运动员，快跑者每次移动两步而慢跑者每次只移动一步，其速度的差值为 1，因此需要经过 $\dfrac{\text{二者之间距离}}{\text{速度差值}}$ 次循环后，快跑者可以追上慢跑者。这个距离几乎就是 $\text{环形部分长度 k}$ ，且速度差值为 $1$ ，我们得出这样的结论 $\text{迭代次数} \approx \text{环形部分长度 k}$。因此，在最糟糕的情形下，时间复杂度为 $O(n+k)$，即 $O(n)$ 。</li>
</ol>
</li>
</ul>
</li>
<li>空间复杂度：只使用了慢指针和快指针两个结点，所以空间复杂度为 $O(1)$。</li>
</ul>
<div class="tabs" id="141"><ul class="nav-tabs"><li class="tab active"><a href="#141-1">快慢双指针</a></li><li class="tab"><a href="#141-2">哈希表</a></li></ul><div class="tab-content"><div class="tab-pane active" id="141-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        这里while循环：</span></span><br><span class="line"><span class="string">        1. fast and fast.next：</span></span><br><span class="line"><span class="string">            - 长度为奇数：slow停在中间位置</span></span><br><span class="line"><span class="string">            - 长度为偶数：slow停在中间偏右位置</span></span><br><span class="line"><span class="string">        1. fast.next and fast.next.next：</span></span><br><span class="line"><span class="string">            - 长度为奇数：slow停在中间位置</span></span><br><span class="line"><span class="string">            - 长度为偶数：slow停在中间偏左位置</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># if not head: return False</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="comment"># 快指针结束在None点，此时不是环</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:  <span class="comment"># while fast.next and fast.next.next:</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="141-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dictx = &#123;&#125;</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> dictx:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            dictx[cur] = <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="142-环形链表-II-快慢"><a href="#142-环形链表-II-快慢" class="headerlink" title="142. 环形链表 II(快慢)"></a>142. 环形链表 II(快慢)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkv">https://leetcode-cn.com/problems/linked-list-cycle-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<br>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 -1，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p>示例 1：<br>输入：<code>head = [3,2,0,-4], pos = 1</code><br>输出：返回索引为 <code>1</code> 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkvc29sdXRpb24vaHVhbi14aW5nLWxpYW4tYmlhby1paS1ieS1sZWV0Y29kZS8=">官方题解<i class="fa fa-external-link-alt"></i></span>。<br><strong>方法一：哈希表法</strong></p>
<ul>
<li>时间复杂度：$O(n)$<blockquote>
<p>不管是成环还是不成环的输入，算法肯定都只会访问每个节点一次。对于非成环列表这是显而易见的，因为第 <code>n</code> 个节点指向 <code>null</code> ，这会让循环退出。对于循环列表， <code>if</code> 条件满足时会导致函数的退出，因为它指向了某个已经访问过的节点。两种情况下，访问的节点数最多都是 <code>n</code> 个，所以运行时间跟节点数目成线性关系。</p>
</blockquote>
</li>
<li>空间复杂度：$O(n)$<blockquote>
<p>不管成环或者不成环的输入，我们都需要将每个节点插入 <code>Set</code> 中一次。两者唯一的区别是最后访问的节点后是 <code>null</code> 还是一个已经访问过的节点。因此，由于 <code>Set</code> 包含 <code>n</code> 个不同的节点，所需空间与节点数目也是线性关系的。</p>
</blockquote>
</li>
</ul>
<p><strong>方法二：Floyd 算法（快慢指针法）</strong><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkvZGlzY3Vzcy80NDgzMw==">LostSummer233 题解<i class="fa fa-external-link-alt"></i></span>。</p>
<div class="tabs" id="142"><ul class="nav-tabs"><li class="tab active"><a href="#142-1">快慢指针</a></li><li class="tab"><a href="#142-2">哈希表</a></li></ul><div class="tab-content"><div class="tab-pane active" id="142-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="comment"># while-else语法：while条件不满足执行else，while里面遇到break，跳出while-else语句。</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 此时slow走了k步(head-&gt;slow)，fast走了2k步(slow-&gt;fast也为k步，即环为k步)</span></span><br><span class="line">            <span class="comment"># </span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:<span class="keyword">break</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> <span class="comment"># 不是环，结束</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 假设chead-&gt;slow为m步，那么head-&gt;chead为k-m步，因为环为k步，所以fast-&gt;chead也为k-m步</span></span><br><span class="line">        <span class="comment"># 即，head和fast同速走到相遇，此时就是chead了！</span></span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="142-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.add(node)</span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="234-回文链表-快慢"><a href="#234-回文链表-快慢" class="headerlink" title="234. 回文链表(快慢)"></a>234. 回文链表(快慢)</h2><p><strong>难度</strong>：简单<br><strong>题⽬链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1saW5rZWQtbGlzdC8=">https://leetcode-cn.com/problems/palindrome-linked-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<p>示例1:<br>1-&gt;2-&gt;2-&gt;1<br>输入：head = [1,2,2,1]<br>输出：true</p>
<p>示例2:<br>1-&gt;2<br>输入：head = [1,2]<br>输出：false</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1saW5rZWQtbGlzdC8=">面试题 02.06<i class="fa fa-external-link-alt"></i></span>相同。<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1saW5rZWQtbGlzdC9zb2x1dGlvbi9odWktd2VuLWxpYW4tYmlhby1ieS1sZWV0Y29kZS8=">官方题解<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1saW5rZWQtbGlzdC9zb2x1dGlvbi9kb25nLWh1YS15YW4tc2hpLTIzNC1odWktd2VuLWxpYW4tYmlhby1ieS11c2VyNzQzOS8=">wangnima题解<i class="fa fa-external-link-alt"></i></span>，官方题解代码更工程漂亮，wangnima的讲解更细。</p>
<p>时间复杂度$O(n)$。<br>空间复杂度$O(1)$。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        first_end = self.end_of_first(head)</span><br><span class="line">        second_start = self.reverse_list(first_end.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断是否回文</span></span><br><span class="line">        <span class="comment"># res = True</span></span><br><span class="line">        first = head</span><br><span class="line">        second = second_start</span><br><span class="line">        <span class="keyword">while</span> first <span class="keyword">and</span> second: <span class="comment">#while res and second:</span></span><br><span class="line">            <span class="keyword">if</span> first.val != second.val: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment">#res = False</span></span><br><span class="line">            first = first.<span class="built_in">next</span></span><br><span class="line">            second = second.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 还原链表并返回结果</span></span><br><span class="line">        <span class="comment"># first_end.next = self.reverse_list(second_start)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="comment">#res</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        cur = head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end_of_first</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        # 奇数：slow停在中间(slow需要再向前走一步，才为second头节点)</span></span><br><span class="line"><span class="string">        # 偶数：slow停在中间偏右(slow为second头节点)</span></span><br><span class="line"><span class="string">        while fast and fast.next:</span></span><br><span class="line"><span class="string">            ...</span></span><br><span class="line"><span class="string">        # 偶数时，fast停在None</span></span><br><span class="line"><span class="string">        # 奇数时，fast停在非None，slow需要走一步</span></span><br><span class="line"><span class="string">        if fast: slow = slow.next</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow,fast = head,head</span><br><span class="line">        <span class="comment"># 奇数：slow停在中间</span></span><br><span class="line">        <span class="comment"># 偶数：slow停在中间偏左</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></p>
<h2 id="143-重排链表-快慢"><a href="#143-重排链表-快慢" class="headerlink" title="143. 重排链表(快慢)"></a>143. 重排链表(快慢)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVvcmRlci1saXN0Lw==">https://leetcode-cn.com/problems/reorder-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 下标表示为：<code>0,1...n-1,n</code>，请将其重新排列后变为：<code>0,n,1,n-1...</code>，不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1：<br>输入：<code>head = [1,2,3,4]</code><br>输出：<code>[1,4,2,3]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVvcmRlci1saXN0L3NvbHV0aW9uL3hpYW5nLXhpLXRvbmctc3UtZGUtc2ktbHUtZmVuLXhpLWR1by1qaWUtZmEtYnktMzQv">windiang题解<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目解析</strong>：<strong>寻找链表中点 + 链表逆序 + 合并链表</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        mid = self.middleNode(head)</span><br><span class="line">        l1 = head</span><br><span class="line">        l2 = self.reverseList(mid.<span class="built_in">next</span>)</span><br><span class="line">        mid.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># l1结尾置None</span></span><br><span class="line">        <span class="comment"># l1从head开始，l2从后半反转后pre开始</span></span><br><span class="line">        self.mergeList(l1, l2)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="comment"># 偶数：slow停在中间节点偏左</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeList</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>):</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            l1_tmp = l1.<span class="built_in">next</span></span><br><span class="line">            l2_tmp = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            l1.<span class="built_in">next</span> = l2</span><br><span class="line">            l1 = l1_tmp</span><br><span class="line"></span><br><span class="line">            l2.<span class="built_in">next</span> = l1</span><br><span class="line">            l2 = l2_tmp</span><br></pre></td></tr></table></figure></p>
<h2 id="019-删除链表的倒数第N个节点-快慢"><a href="#019-删除链表的倒数第N个节点-快慢" class="headerlink" title="019. 删除链表的倒数第N个节点(快慢)"></a>019. 删除链表的倒数第N个节点(快慢)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLW50aC1ub2RlLWZyb20tZW5kLW9mLWxpc3Qv">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。<br>示例 1：<br>输入：<code>head = [1,2,3,4,5], n = 2</code><br>输出：<code>[1,2,3,5]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLW50aC1ub2RlLWZyb20tZW5kLW9mLWxpc3Qvc29sdXRpb24vc2hhbi1jaHUtbGlhbi1iaWFvLWRlLWRhby1zaHUtZGktbmdlLWppZS1kaWFuLWJ5LWwv">官方题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 正常遍历，fast到None时，slow为要删除节点</span></span><br><span class="line">        <span class="comment"># head前加一个节点，这样在fast到None时，slow下一个节点为要删除节点</span></span><br><span class="line">        dhead = ListNode(<span class="number">-1</span>, head) </span><br><span class="line">        slow = dhead</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="comment"># fast先走n步</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 同步走到fast为None结束，此时slow下一个节点为要删除节点</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 删除slow下一个节点</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dhead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="344-反转字符串-左右"><a href="#344-反转字符串-左右" class="headerlink" title="344. 反转字符串(左右)"></a>344. 反转字符串(左右)</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1zdHJpbmcv">https://leetcode-cn.com/problems/reverse-string/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 <code>O(1)</code> 的额外空间解决这一问题。<br>示例 1：<br>输入：<code>s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</code><br>输出：<code>[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: List[<span class="built_in">str</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            s[r],s[l] = s[l],s[r]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>
<h2 id="125-验证回文串-左右"><a href="#125-验证回文串-左右" class="headerlink" title="125. 验证回文串(左右)"></a>125. 验证回文串(左右)</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFsaW5kcm9tZS8=">https://leetcode-cn.com/problems/valid-palindrome/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述：</strong>给定一个字符串，验证它是否是回文串，只考虑<strong>字母</strong>和<strong>数字</strong>字符，可以<strong>忽略</strong>字母的<strong>大小写</strong>。说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例 1:<br>输入: <code>&quot;A man, a plan, a canal: Panama&quot;</code><br>输出: <code>true</code><br>解释：<code>&quot;amanaplanacanalpanama&quot;</code> 是回文串</p>
<p>示例 2:<br>输入: <code>&quot;race a car&quot;</code><br>输出: <code>false</code><br>解释：<code>&quot;raceacar&quot;</code> 不是回文串</p>
<p><strong>题目解析</strong>：核心是比较reversed string 和 原本的 string 是否相等。<br><div class="tabs" id="125"><ul class="nav-tabs"><li class="tab active"><a href="#125-1">双指针</a></li><li class="tab"><a href="#125-2">字符串处理</a></li><li class="tab"><a href="#125-3">正则</a></li></ul><div class="tab-content"><div class="tab-pane active" id="125-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># left,right跳过非字母数字</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalnum():left += <span class="number">1</span>     </span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalnum():right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> s[left].lower() != s[right].lower(): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                left, right = left+<span class="number">1</span>, right<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="125-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self,s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sgood = <span class="string">&quot;&quot;</span>.join(ch.lower() <span class="keyword">for</span> ch <span class="keyword">in</span> s <span class="keyword">if</span> ch.isalnum())</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="125-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re.sub()用法：https://www.jianshu.com/p/8c1d1a38f9b9</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        newString = re.sub(<span class="string">&quot;[^0-9a-zA-Z]+&quot;</span>, <span class="string">&quot;&quot;</span>, s)</span><br><span class="line">        <span class="keyword">return</span> newString.lower() == newString.lower()[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="015-三数之和-左右"><a href="#015-三数之和-左右" class="headerlink" title="015. 三数之和(左右)"></a>015. 三数之和(左右)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS8=">https://leetcode-cn.com/problems/3sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题⽬描述</strong>：给你一个包含<code>n</code>个整数的数组<code>nums</code>，判断<code>nums</code>中是否存在三个元素<code>a，b，c</code> ，使得<code>a + b + c = 0</code>？请你找出所有和为0且不重复的三元组。注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：<br>输入：<code>nums = [-1,0,1,2,-1,-4]</code><br>输出：<code>[[-1,-1,2],[-1,0,1]]</code></p>
<p><strong>题目解析</strong>：</p>
<ol>
<li>数组长度n，若 <code>n==[]</code> 或 <code>n&lt;3</code>，返回 <code>[]</code> ;</li>
<li>对数组进行排序;</li>
<li>遍历数组( <code>i==n-1</code> 停止)：<ul>
<li><code>nums[i]&gt;0</code> ：直接返回结果（因为已排序，所以后面无小于 <code>num[i]</code> 的数）；</li>
<li>跳过与 <code>nums[i]</code> 相同的元素;</li>
<li>左指针 <code>l=i+1</code>，右指针 <code>r=n-1</code>，当 <code>l&lt;r</code> 时执行循环：<ul>
<li><code>tmp = nums[i] + nums[l] + nums[r]</code>；</li>
<li>当 <code>tmp&gt;0</code> ：说明 <code>nums[r]</code> 太大， <code>r</code> 左移;</li>
<li>当 <code>tmp&lt;0</code> ：说明 <code>nums[l]</code> 太小， <code>l</code> 右移;</li>
<li>当 <code>tmp=0</code> ：存入结果中，并判断此时 <code>nums[l]</code> 和 <code>nums[r]</code> 是否与下一位置值重复，重复值剔除（因为已排序，只需和下一位置比较）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>复杂度分析</strong>：<br>（1）时间复杂度：排序$O(nlogn)$，遍历数组$O(n)$，双指针遍历$O(n)$，总体：$O(nlogn)+O(n)*O(n) -&gt; O(n^2)$。<br>（2）空间复杂度：$O(1)$。</p>
<div class="tabs" id="015"><ul class="nav-tabs"><li class="tab active"><a href="#015-1">模板</a></li><li class="tab"><a href="#015-2">题解</a></li></ul><div class="tab-content"><div class="tab-pane active" id="015-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以把0换成target，当成模板用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># if (not nums or n&lt;3):return []</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># if nums[i] &gt; 0: return res  # nums[i]&gt;0直接结束</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:<span class="keyword">continue</span>  <span class="comment"># 去重(需要和上⼀次枚举的数不相同)</span></span><br><span class="line">            l, r = i+<span class="number">1</span>, n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;r:  <span class="comment"># 左右循环计算</span></span><br><span class="line">                sums = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> sums &gt; <span class="number">0</span>: r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sums &lt; <span class="number">0</span>: l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 3个数和为0，加入res</span></span><br><span class="line">                    res.append([nums[i],nums[l],nums[r]])</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> nums[l]==nums[l<span class="number">-1</span>]:l += <span class="number">1</span> <span class="comment"># nums[l]去重</span></span><br><span class="line">                    <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> nums[r]==nums[r+<span class="number">1</span>]:r -= <span class="number">1</span> <span class="comment"># nums[r]去重</span></span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="015-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三个循环，其中第二和第三是并列的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举 first</span></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> first&gt;<span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first<span class="number">-1</span>]:<span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 枚举 third 对应的指针初始指向数组的最右端</span></span><br><span class="line">            third = n - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 枚举 second</span></span><br><span class="line">            <span class="keyword">for</span> second <span class="keyword">in</span> <span class="built_in">range</span>(first+<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># b的值需要和上一次的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> second&gt;first+<span class="number">1</span> <span class="keyword">and</span> nums[second] == nums[second<span class="number">-1</span>]:<span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 需要保证 second 的指针在 third 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> second&lt;third <span class="keyword">and</span> nums[second]+nums[third]+nums[first] &gt; <span class="number">0</span>:third -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果指针重合，随着 second 后续的增加</span></span><br><span class="line">                <span class="comment"># 就不会有满足 first+second+third=0 并且 second&lt;third 的 third 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> second == third:<span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[second]+nums[third]+nums[first] == <span class="number">0</span>:</span><br><span class="line">                    ans.append([nums[first], nums[second], nums[third]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div></div></div>
<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">二分搜索**边界**细节：</span><br><span class="line">1. mid加1还是减1?</span><br><span class="line">    - [left,right]：nums[mid]&#x3D;&#x3D;target时，left&#x2F;right &#x3D; mid +&#x2F;- 1</span><br><span class="line">    - [left,right)：nums[mid]&#x3D;&#x3D;target时，left&#x2F;right &#x3D; mid</span><br><span class="line">2. while用不用加&#x3D;? </span><br><span class="line">    - [left,right]：初始[0,n-1]，加&#x3D;，会判断left&#x3D;&#x3D;right时的mid，结束时left&gt;right。</span><br><span class="line">        - 求target左边界：right不断缩小，直到left&gt;right，返回left。检查left&gt;n?</span><br><span class="line">        - 求target右边界：left不断增大，直到left&gt;right，返回right。检查right&lt;0?</span><br><span class="line">    - [left,right)：初始[0,n]，不加&#x3D;，不会判断left&#x3D;&#x3D;right的mid，结束时left&#x3D;&#x3D;right。</span><br><span class="line">建议使用第一种方法做二分搜索，便于记忆。</span><br></pre></td></tr></table></figure>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC8=">https://leetcode-cn.com/problems/binary-search/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p>示例 1:<br>输入: <code>nums = [-1,0,3,5,9,12], target = 9</code><br>输出: <code>4</code><br>解释: 9 出现在 nums 中并且下标为 4</p>
<p>示例 2:<br>输入: <code>nums = [-1,0,3,5,9,12], target = 2</code><br>输出: <code>-1</code><br>解释: 2 不存在 nums 中因此返回 -1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建议不用else，用elif把条件都写出来，容易纠错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 需要判断当前值，所以有=</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 奇数：mid停在中间</span></span><br><span class="line">            <span class="comment"># 偶数：mid停在中间偏左</span></span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            num = nums[mid]</span><br><span class="line">            <span class="keyword">if</span> num == target: <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> num &lt; target: left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &gt; target: right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="034-查找元素的第一个和最后一个位置"><a href="#034-查找元素的第一个和最后一个位置" class="headerlink" title="034. 查找元素的第一个和最后一个位置"></a>034. 查找元素的第一个和最后一个位置</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1maXJzdC1hbmQtbGFzdC1wb3NpdGlvbi1vZi1lbGVtZW50LWluLXNvcnRlZC1hcnJheS8=">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个<strong>按照升序排列</strong>的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的<strong>开始位置</strong>和<strong>结束位置</strong>。如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>示例 1：<br>输入：<code>nums = [5,7,7,8,8,10], target = 8</code><br>输出：<code>[3,4]</code></p>
<p>示例 2：<br>输入：<code>nums = [5,7,7,8,8,10], target = 6</code><br>输出：<code>[-1,-1]</code></p>
<p>示例 3：<br>输入：<code>nums = [], target = 0</code><br>输出：<code>[-1,-1]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1maXJzdC1hbmQtbGFzdC1wb3NpdGlvbi1vZi1lbGVtZW50LWluLXNvcnRlZC1hcnJheS9zb2x1dGlvbi9sYW4taG9uZy1odWEtZmVuLWZhLWRhbi1tby1iYW4tbWlhby1zaGEtZTdyNDAv">随心源 题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        left = self.binarySearchLeft(nums, target)</span><br><span class="line">        right = self.binarySearchRight(nums, target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [left, right]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearchLeft</span>(<span class="params">self, nums:List[<span class="built_in">int</span>], target:<span class="built_in">int</span></span>)-&gt;List[int]:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 需要判断当前值，所以有=，结束时left停在左边界</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 奇数：mid停在中间</span></span><br><span class="line">            <span class="comment"># 偶数：mid停在中间偏左</span></span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            num = nums[mid]</span><br><span class="line">            <span class="keyword">if</span> num == target: right = mid - <span class="number">1</span> <span class="comment"># 收缩右侧边界</span></span><br><span class="line">            <span class="keyword">elif</span> num &lt; target: left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &gt; target: right = mid - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 检测left越界</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearchRight</span>(<span class="params">self, nums:List[<span class="built_in">int</span>], target:<span class="built_in">int</span></span>)-&gt;List[int]:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 需要判断当前值，所以有=，结束时right停在右边界</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 奇数：mid停在中间</span></span><br><span class="line">            <span class="comment"># 偶数：mid停在中间偏左</span></span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            num = nums[mid]</span><br><span class="line">            <span class="keyword">if</span> num == target: left = mid + <span class="number">1</span> <span class="comment"># 收缩左侧边界</span></span><br><span class="line">            <span class="keyword">elif</span> num &lt; target: left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &gt; target: right = mid - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 检测right越界</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> nums[right] != target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure></p>
<h2 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a>875. 爱吃香蕉的珂珂</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva29rby1lYXRpbmctYmFuYW5hcy8=">https://leetcode-cn.com/problems/koko-eating-bananas/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（k 为整数）。<br>示例 1：<br>输入：<code>piles = [3,6,7,11], h = 8</code><br>输出：<code>4</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span>(<span class="params">self, piles: List[<span class="built_in">int</span>], h: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        正常考虑速度 K 由 [1~max(piles)] 选择，因为要最小速度，所以取能吃完的速度最小值k。</span></span><br><span class="line"><span class="string">        二分查找：类似寻找左侧边界。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">k</span>):</span></span><br><span class="line">            <span class="comment"># 能否以速度 k 吃完香蕉(吃完香蕉总用时不超过H)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(ceil(p/k) <span class="keyword">for</span> p <span class="keyword">in</span> piles) &lt;= h</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">1</span>, <span class="built_in">max</span>(piles)</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            <span class="keyword">if</span> canFinish(mid):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 本题可不用检验边界</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="built_in">max</span>(piles) <span class="keyword">or</span> <span class="keyword">not</span> canFinish(left): <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p>
<h2 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a>1011. 在 D 天内送达包裹的能力</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2FwYWNpdHktdG8tc2hpcC1wYWNrYWdlcy13aXRoaW4tZC1kYXlzLw==">https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：传送带上的包裹必须在 <code>days</code> 天内从一个港口运送到另一个港口。传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。返回能在 <code>days</code> 天内将传送带上的所有包裹<strong>按顺序</strong>送达的船的最低运载能力。<br>示例 1：<br>输入：<code>weights = [1,2,3,4,5,6,7,8,9,10], days = 5</code><br>输出：<code>15</code><br>解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：<br>第 1 天：1, 2, 3, 4, 5<br>第 2 天：6, 7<br>第 3 天：8<br>第 4 天：9<br>第 5 天：10<br>请注意，<strong>货物必须按照给定的顺序装运</strong>，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shipWithinDays</span>(<span class="params">self, weights: List[<span class="built_in">int</span>], days: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        和吃香蕉一样，先确定最小载重值的范围[max(weights), sum(weights)]，在这个范围内二分搜索。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">k</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            能否以载重 k 运完货物(运完货物总天数不超过days)</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># need 为需要运送的天数</span></span><br><span class="line">            <span class="comment"># cur 为当前这一天已经运送的包裹重量之和</span></span><br><span class="line">            need, cur = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> weight <span class="keyword">in</span> weights:</span><br><span class="line">                <span class="comment"># 当前货物超载，结束当天装载，放入下一天</span></span><br><span class="line">                <span class="keyword">if</span> cur + weight &gt; k: </span><br><span class="line">                    need += <span class="number">1</span></span><br><span class="line">                    cur = <span class="number">0</span></span><br><span class="line">                cur += weight</span><br><span class="line">            <span class="keyword">return</span> need &lt;= days</span><br><span class="line">        </span><br><span class="line">        left, right = <span class="built_in">max</span>(weights), <span class="built_in">sum</span>(weights)</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            <span class="keyword">if</span> canFinish(mid):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 本题可不用检验边界</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="built_in">sum</span>(weights) <span class="keyword">or</span> <span class="keyword">not</span> canFinish(left): <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模板：s中找包含t</span></span><br><span class="line">need, window = &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">    s[c] = s.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment"># valid:每满足need的一项的频数，就+1。</span></span><br><span class="line"><span class="comment"># valid==len(need)时表明window完全覆盖了子串t</span></span><br><span class="line">valid = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">    ch = s[right]</span><br><span class="line">    right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ch <span class="keyword">in</span> need:</span><br><span class="line">        window[ch] = window.get(ch, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> need[ch] == window[ch]:</span><br><span class="line">            valid += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> 收缩结束条件:</span><br><span class="line">        <span class="comment"># 判断符合条件/更新结果变量</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 不符合条件/更新完变量，缩小窗口</span></span><br><span class="line">        d = s[left]</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> d <span class="keyword">in</span> need:     </span><br><span class="line">            <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                valid -= <span class="number">1</span></span><br><span class="line">            window[d] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> 结果</span><br></pre></td></tr></table></figure>
<h2 id="003-无重复字符的最长子串"><a href="#003-无重复字符的最长子串" class="headerlink" title="003. 无重复字符的最长子串"></a>003. 无重复字符的最长子串</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<br>示例 1:<br>输入: <code>s = &quot;abcabcbb&quot;</code><br>输出: <code>3</code><br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:<br>输入: <code>s = &quot;bbbbb&quot;</code><br>输出: <code>1</code><br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:<br>输入: <code>s = &quot;pwwkew&quot;</code><br>输出: <code>3</code><br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 <strong>子串</strong> 的长度，”pwke” 是一个<strong>子序列</strong>，不是子串。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy9zb2x1dGlvbi9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzLWItMi8=">Ikaruga 图画<i class="fa fa-external-link-alt"></i></span>。</p>
<div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><a href="#3-1">模板</a></li><li class="tab"><a href="#3-2">for循环</a></li></ul><div class="tab-content"><div class="tab-pane active" id="3-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        mlen, left, right = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">        maps = &#123;&#125; <span class="comment"># 无重复字符:出现次数</span></span><br><span class="line">        <span class="comment"># 区间[left, right)</span></span><br><span class="line">        <span class="comment"># 窗口无重复字符，right右移，更新mlen</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s): </span><br><span class="line">            ch = s[right]</span><br><span class="line">            maps[ch] = maps.get(ch,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> maps[ch] &gt; <span class="number">1</span>: <span class="comment"># 窗口中有重复字符，left右移</span></span><br><span class="line">                chl = s[left]</span><br><span class="line">                maps[d] = maps.get(d, <span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            mlen = <span class="built_in">max</span>(mlen, right-left)</span><br><span class="line">        <span class="keyword">return</span> mlen</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="3-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 最大长度，左边界</span></span><br><span class="line">        mlen, left = <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">        maps = &#123;&#125; <span class="comment"># 存储无重复字符</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)): <span class="comment"># right为右边界</span></span><br><span class="line">            <span class="comment"># right字符在窗口中出现过，left右移一位。始终保证窗口为无重复字串</span></span><br><span class="line">            left = <span class="built_in">max</span>(left, maps.get(s[right],<span class="number">-1</span>)+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 无重复长度=right-left+1，即窗口[left, right]</span></span><br><span class="line">            mlen = <span class="built_in">max</span>(mlen, right-left+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 更新maps</span></span><br><span class="line">            maps[s[right]] = right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mlen</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb24taW4tc3RyaW5nLw==">https://leetcode-cn.com/problems/permutation-in-string/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code>；否则，返回 <code>false</code>。换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>
<p>示例 1：<br>输入：<code>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</code><br>输出：<code>true</code><br>解释：s2 包含 s1 的排列之一 (“ba”).</p>
<p>示例 2：<br>输入：<code>s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</code><br>输出：<code>false</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># need: 需要凑齐的字符</span></span><br><span class="line">        <span class="comment"># window: 记录窗口中的字符</span></span><br><span class="line">        need, window = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s1:</span><br><span class="line">            need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 区间[left, right)</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># valid:每满足need的一项的频数，就+1。</span></span><br><span class="line">        <span class="comment"># valid==len(need)时表明window完全覆盖了子串s1</span></span><br><span class="line">        valid = <span class="number">0</span>     </span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s2):</span><br><span class="line">            ch = s2[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 需要当前字符，更新窗口字符、数量</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> need:         </span><br><span class="line">                window[ch] = window.get(ch, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[ch] == need[ch]:</span><br><span class="line">                    valid += <span class="number">1</span></span><br><span class="line">            <span class="comment"># window长度和s1相等时，判断符合条件、优化left</span></span><br><span class="line">            <span class="keyword">while</span> right-left &gt;= <span class="built_in">len</span>(s1):</span><br><span class="line">                <span class="comment"># 判断符合条件</span></span><br><span class="line">                <span class="keyword">if</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 不符合条件，缩小窗口</span></span><br><span class="line">                d = s2[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:     </span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                        valid -= <span class="number">1</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1hbGwtYW5hZ3JhbXMtaW4tYS1zdHJpbmcv">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>示例 1:<br>输入: <code>s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</code><br>输出: <code>[0,6]</code><br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p>
<p>示例 2:<br>输入: <code>s = &quot;abab&quot;, p = &quot;ab&quot;</code><br>输出: <code>[0,1,2]</code><br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        need, window = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> p:</span><br><span class="line">            need[c] = need.get(c,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ch = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> need:</span><br><span class="line">                window[ch] = window.get(ch,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[ch] == need[ch]:valid += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right-left &gt;= <span class="built_in">len</span>(p):</span><br><span class="line">                <span class="keyword">if</span> valid == <span class="built_in">len</span>(need):res.append(left)</span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:valid -= <span class="number">1</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res     </span><br></pre></td></tr></table></figure></p>
<h2 id="076-最小覆盖子串"><a href="#076-最小覆盖子串" class="headerlink" title="076. 最小覆盖子串"></a>076. 最小覆盖子串</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS13aW5kb3ctc3Vic3RyaW5nLw==">https://leetcode-cn.com/problems/minimum-window-substring/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。<br>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：<br>输入：<code>s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</code><br>输出：<code>&quot;BANC&quot;</code></p>
<p>示例 2:<br>输入: <code>s = &quot;a&quot;, t = &quot;aa&quot;</code><br>输出: <code>&quot;&quot;</code><br>解释: <code>t</code> 中两个字符 <code>&#39;a&#39;</code> 均应包含在 <code>s</code> 的子串中，因此没有符合条件的子字符串，返回空字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="comment"># need: 需要凑齐的字符</span></span><br><span class="line">        <span class="comment"># window: 记录窗口中的字符</span></span><br><span class="line">        need, window = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span>    <span class="comment"># need = &#123;字符:出现次数&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 区间[left, right)</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># valid: window满足need字符数量，valid==len(need)时表明window完全覆盖了子串t</span></span><br><span class="line">        valid = <span class="number">0</span>     </span><br><span class="line">        <span class="comment"># 最小覆盖子串起始位置、长度(初始大于len(s)都行)</span></span><br><span class="line">        start, min_len = <span class="number">0</span>, <span class="built_in">len</span>(s)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 需要当前字符，更新窗口字符、数量</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need:         </span><br><span class="line">                window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                    valid += <span class="number">1</span></span><br><span class="line">            <span class="comment"># window必须完全覆盖子串t时，优化left</span></span><br><span class="line">            <span class="keyword">while</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">                <span class="comment"># 更新字串起始位置、长度</span></span><br><span class="line">                <span class="keyword">if</span> right-left &lt; min_len:   </span><br><span class="line">                    start = left</span><br><span class="line">                    min_len = right-left</span><br><span class="line">                <span class="comment"># 将要移除的字符</span></span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># d在need中出现，更新窗口window，更新该字符满足条件-&gt;不满足</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:     </span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                        valid -= <span class="number">1</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start+min_len] <span class="keyword">if</span> length != <span class="built_in">len</span>(s)+<span class="number">1</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>动态规划</strong>：用于<strong>求最值</strong>类题目，解决穷举方法中<strong>重复</strong>计算的问题，一般要留一个“<strong>备忘录</strong>”(DP table)优化重复计算，在此基础上使用“<strong>最优子结构</strong>”就是完整的动态规划。遇到此类问题思考方式：<strong>穷举-&gt;最简单情况、状态、选择、dp数组(备忘录)-&gt;状态转移方程</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">状态：dp[状态]</span><br><span class="line">    只涉及一个字符串：dp[i]表示以s[i]结尾的最长...</span><br><span class="line">    涉及两个字符串：dp加空串，dp[i][j]表示以s1[i-1]、s2[j-1]结尾的最长...(dp索引i指向的字符等于s1[i-1])</span><br><span class="line">选择：不同选择，影响当前状态存储的结果</span><br><span class="line">dp数组：根据选择、状态，找到子状态变到现状态公式，一般都是max</span><br><span class="line"></span><br><span class="line">状态压缩：前提是，当前状态，只依赖前几个状态，那么只用一维数组记录前几个状态，特殊的可用变量记录。将二维压缩为一维。</span><br></pre></td></tr></table></figure></p>
<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p>先来看看什么是<strong>重叠子问题</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，</span></span><br><span class="line"><span class="string">后面的每一项数字都是前面两项数字的和。也就是：</span></span><br><span class="line"><span class="string">F(0) = 0，F(1) = 1</span></span><br><span class="line"><span class="string">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span><br><span class="line"><span class="string">给定 n ，请计算 F(n) 。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例 1：</span></span><br><span class="line"><span class="string">输入：n = 2</span></span><br><span class="line"><span class="string">输出：1</span></span><br><span class="line"><span class="string">解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 暴力递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n ==<span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.fib(n<span class="number">-1</span>) + self.fib(n<span class="number">-2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归中的重复子问题：计算f(20)时，需要f(19)和f(18)，计算f(19)时需要f(18)和f(17)，f(18)被多计算了一次！</span></span><br><span class="line"><span class="string">递归时间复杂度：O(2^n)，指数级复杂度。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">每次计算出子问题答案，存入“备忘录”，每遇到一个问题先去“备忘录”查看，以前计算过的，直接把答案拿来用。</span></span><br><span class="line"><span class="string">可以使用数组、哈希表(字典)作为“备忘录”。</span></span><br><span class="line"><span class="string">时间复杂度：每个子问题计算一次，O(n)。</span></span><br><span class="line"><span class="string">动态规划：自底向上。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">3</span>)  <span class="comment"># 初始位置 0、1、2</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"><span class="comment"># 优化动态规划</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">技巧”状态压缩“：斐波那契计算n时，只需要n-1和n-2，所以“备忘录”存当前n的前两个就行。</span></span><br><span class="line"><span class="string">时间复杂度：降至O(1)。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span> :<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        pre, cur = <span class="number">1</span>, <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># pre：n-1 </span></span><br><span class="line">            <span class="comment"># cur：n-2</span></span><br><span class="line">            <span class="built_in">sum</span> = pre + cur</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure></p>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2Uv">https://leetcode-cn.com/problems/coin-change/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。<br>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。<br>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：<br>输入：<code>coins = [1, 2, 5], amount = 11</code><br>输出：<code>3</code><br>解释：11 = 5 + 5 + 1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">amount最少的硬币个数可以由 “amount-1 + 一个硬币” 得到。</span></span><br><span class="line"><span class="string">状态：amount</span></span><br><span class="line"><span class="string">选择：硬币种类，每种选/不选</span></span><br><span class="line"><span class="string">dp数组：dp[amount]，先判断amount能不能用当前硬币凑，再确定：</span></span><br><span class="line"><span class="string">       (1) 选：dp[i-coin]+1</span></span><br><span class="line"><span class="string">       (2) 不选：dp[amount]不变</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 外层for遍历所有状态</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 内层for遍历所有选择)，最小值</span></span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> coin &gt; i : <span class="keyword">continue</span>  <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 外层for遍历所有选择</span></span><br><span class="line"><span class="string">for coin in coins:</span></span><br><span class="line"><span class="string">    # 内层for遍历所有(有效)状态时，最小值</span></span><br><span class="line"><span class="string">    for i in range(coin, amount+1):</span></span><br><span class="line"><span class="string">        dp[i] = min(dp[i], dp[i-coin]+1)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="300-最长递增子序列-673"><a href="#300-最长递增子序列-673" class="headerlink" title="300. 最长递增子序列(673)"></a>300. 最长递增子序列(673)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlLw==">https://leetcode-cn.com/problems/longest-increasing-subsequence/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>nums</code> ，找到其中最<strong>长严格递增子序列</strong>的长度。<strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>子串</strong>：必须是连续的块。<strong>子序列</strong>：可以是非连续的块。</p>
<p>示例 1：<br>输入：<code>nums = [10,9,2,5,3,7,101,18]</code><br>输出：<code>4</code><br>解释：最长递增子序列是 <code>[2,3,7,101]</code>，因此长度为 <code>4</code> 。</p>
<div class="tabs" id="300"><ul class="nav-tabs"><li class="tab active"><a href="#300-1">最长递增子序列</a></li><li class="tab"><a href="#300-2">673.最长递增子序列个数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="300-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：nums[i]结尾，最长递增子序列长度</span></span><br><span class="line"><span class="string">        选择：nums[j], j为比nums[i]小的值在nums的索引</span></span><br><span class="line"><span class="string">        dp数组：dp[i] = max(dp[i], dp[j]+1)，返回max(dp)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            dp.append(<span class="number">1</span>)  <span class="comment"># 初始值为1，最长递增子序列只有自己</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="300-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加一个dp数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：</span></span><br><span class="line"><span class="string">            dp[i]：到nums[i]为止的最长递增子序列长度</span></span><br><span class="line"><span class="string">            count[i]：到nums[i]为止的最长递增子序列个数</span></span><br><span class="line"><span class="string">        选择：</span></span><br><span class="line"><span class="string">            如果dp[j]+1 &gt; dp[i],说明最长递增子序列的长度增加了,dp[i] = dp[j]+1,长度增加,重新计数 cnt[i] = cnt[j]</span></span><br><span class="line"><span class="string">            如果dp[j]+1 == dp[i],说明最长递增子序列的长度没增加,但出现了长度一样的情况,数量增加 cnt[i] += cnt[j]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cnt, dp = [], []</span><br><span class="line">        max_num = max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            dp.append(<span class="number">1</span>)</span><br><span class="line">            cnt.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j]&lt;nums[i]:</span><br><span class="line">                    <span class="keyword">if</span> dp[j] + <span class="number">1</span> &gt; dp[i]:</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">                        cnt[i] = cnt[j]  <span class="comment"># 重置计数</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[j] + <span class="number">1</span> == dp[i]:</span><br><span class="line">                        cnt[i] += cnt[j]  <span class="comment"># 当前最长递增子序列个数 = 所有满足条件子序列个数和</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; max_len:</span><br><span class="line">                max_len = dp[i]</span><br><span class="line">                max_num = cnt[i]  <span class="comment"># 重置计数</span></span><br><span class="line">            <span class="keyword">elif</span> dp[i] == max_len:</span><br><span class="line">                max_num += cnt[i]</span><br><span class="line">        <span class="keyword">return</span> max_num</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a>354. 俄罗斯套娃信封问题</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcnVzc2lhbi1kb2xsLWVudmVsb3Blcy8=">https://leetcode-cn.com/problems/russian-doll-envelopes/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个<strong>二维整数数组</strong> <code>envelopes</code> ，其中 <code>envelopes[i] = [wi, hi]</code> ，表示第 <code>i</code> 个信封的宽度和高度。<br>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<br>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。<br>注意：不允许旋转信封。</p>
<p>示例 1：<br>输入：<code>envelopes = [[5,4],[6,4],[6,7],[2,3]]</code><br>输出：<code>3</code><br>解释：最多信封的个数为 3, 组合为: <code>[2,3] =&gt; [5,4] =&gt; [6,7]</code>。</p>
<p>二分法比较烧脑，可看<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcnVzc2lhbi1kb2xsLWVudmVsb3Blcy9zb2x1dGlvbi9qaW4temhpLXRhby13YS10dS1qaWUtZ3VvLWNoZW5nLWJ5LXphb3poLXJ1YmYv">zaozhe 题解<i class="fa fa-external-link-alt"></i></span>详细解释。<br><div class="tabs" id="354"><ul class="nav-tabs"><li class="tab active"><a href="#354-1">动态规划</a></li><li class="tab"><a href="#354-2">二分搜索+动态规划</a></li></ul><div class="tab-content"><div class="tab-pane active" id="354-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超出时间限制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i] envelopes[i]为最大信封，套娃信封个数</span></span><br><span class="line"><span class="string">        选择：所有比envelopes[i]小的信封</span></span><br><span class="line"><span class="string">        先对信封排序：按宽度由小-&gt;大，宽相等的按高度由大-&gt;小，最后只需对高度求最长递增子序列</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 宽度由小-&gt;大，宽相等的按高度由大-&gt;小</span></span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(envelopes)):</span><br><span class="line">            dp.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> envelopes[j][<span class="number">1</span>] &lt; envelopes[i][<span class="number">1</span>]: </span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="354-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i]表示当最长序列长度为i时最外面一层信封的最小h</span></span><br><span class="line"><span class="string">        选择：所有比envelopes[i]小的信封</span></span><br><span class="line"><span class="string">        先对信封排序：按宽度由小-&gt;大，宽相等的按高度由大-&gt;小，最后只需对高度求最长递增子序列</span></span><br><span class="line"><span class="string">        dp值是严格单调递增的，因为越长的子序列的末尾元素显然越大。</span></span><br><span class="line"><span class="string">        当h_i大于dp中的最大值，说明可以添加h_i组成更长的序列</span></span><br><span class="line"><span class="string">        否则把h_i当作最外层最小h，替换掉首个比h_i大的h：</span></span><br><span class="line"><span class="string">            从dp中找出比h_i小的最大元素dp[index]，使 dp[index]&lt; h_i &lt;dp[index+1]</span></span><br><span class="line"><span class="string">            那么h_i可以接在dp[index]后面，形成长度为 index+1 序列，更新 dp[index+1]=h_i</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 宽度由小-&gt;大，宽相等的按高度由大-&gt;小</span></span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        dp = [envelopes[<span class="number">0</span>][<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(envelopes)):</span><br><span class="line">            <span class="comment"># 3.8新增语法，:=表示先赋值给中间变量num，再去判断</span></span><br><span class="line">            <span class="keyword">if</span> (num := envelopes[i][<span class="number">1</span>]) &gt; dp[<span class="number">-1</span>]:</span><br><span class="line">                dp.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 二分查找：(dp必须已排序)在dp数组中插入num，返回插入位置(有重复插入左侧)</span></span><br><span class="line">                index = bisect.bisect_left(dp, num)  <span class="comment"># 这里插入位置默认为index+1了</span></span><br><span class="line">                dp[index] = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(dp)</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="053-最大子数组和"><a href="#053-最大子数组和" class="headerlink" title="053. 最大子数组和"></a>053. 最大子数组和</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=">https://leetcode-cn.com/problems/maximum-subarray/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>nums</code> ，请你找出一个具有<code>最大和的连续子数组</code>（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong> 是数组中的一个<strong>连续</strong>部分。<br>示例 1：<br>输入：<code>nums = [-2,1,-3,4,-1,2,1,-5,4]</code><br>输出：<code>6</code><br>解释：连续子数组 <code>[4,-1,2,1]</code> 的和最大，为 6 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：d[i] nums[i]结尾子数组最大和</span></span><br><span class="line"><span class="string">        选择：连续数组，只能选nums[i-1]对应的dp[i-1]</span></span><br><span class="line"><span class="string">        dp数组：dp[i] = max(nums[i], dp[i-1]+nums[i])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        状态压缩：dp[i] 仅和 dp[i-1] 相关，用pre记录dp[i-1]，cur记录dp[i]，代码中还可再省略cur</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># dp = [0] * len(nums)</span></span><br><span class="line">        <span class="comment"># dp[0] = nums[0]</span></span><br><span class="line">        <span class="comment"># for i in range(1, len(nums)):</span></span><br><span class="line">        <span class="comment">#     dp[i] = max(nums[i], dp[i-1]+nums[i])</span></span><br><span class="line">        <span class="comment"># return max(dp)</span></span><br><span class="line"></span><br><span class="line">        maxsums = nums[<span class="number">0</span>]</span><br><span class="line">        pre = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            pre = <span class="built_in">max</span>(pre+nums[i], nums[i])</span><br><span class="line">            maxsums = <span class="built_in">max</span>(pre, maxsums)</span><br><span class="line">        <span class="keyword">return</span> maxsums</span><br></pre></td></tr></table></figure>
<h2 id="070-爬楼梯"><a href="#070-爬楼梯" class="headerlink" title="070. 爬楼梯"></a>070. 爬楼梯</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==">https://leetcode-cn.com/problems/climbing-stairs/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcWluZy13YS10aWFvLXRhaS1qaWUtd2VuLXRpLWxjb2Yv">面试题10- II.青蛙跳台阶问题<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdGhyZWUtc3RlcHMtcHJvYmxlbS1sY2NpLw==">面试题 08.01. 三步问题<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>示例 1：<br>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。（1）1 阶 + 1 阶 （2） 2 阶</p>
<div class="tabs" id="070"><ul class="nav-tabs"><li class="tab active"><a href="#070-1">爬楼梯</a></li><li class="tab"><a href="#070-2">三步问题</a></li></ul><div class="tab-content"><div class="tab-pane active" id="070-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i]表示到i阶时，有多少种方法。</span></span><br><span class="line"><span class="string">        初始状态：空台阶dp[0]=1，1阶dp[1]=1</span></span><br><span class="line"><span class="string">        选择：跨1阶/2阶</span></span><br><span class="line"><span class="string">        dp数组：计算dp[i]时，等于跨1阶/2阶方法和。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>) </span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="070-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waysToStep</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i]表示到i阶时，有多少种方法。</span></span><br><span class="line"><span class="string">        初始状态：空台阶dp[0]=1，1阶dp[1]=1，2阶dp[2]=2</span></span><br><span class="line"><span class="string">        选择：跨1阶/2阶/3阶</span></span><br><span class="line"><span class="string">        dp数组：计算dp[i]时，等于跨1阶/2阶/3阶方法和。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = (dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>] + dp[i<span class="number">-3</span>]) % <span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">return</span> dp[n] </span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a>120. 三角形最小路径和</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHJpYW5nbGUv">https://leetcode-cn.com/problems/triangle/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个三角形 triangle ，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<p>输入：<code>triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</code><br>输出：<code>11</code><br>解释：自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示到位置[i][j]最小路径和。</span></span><br><span class="line"><span class="string">初始状态：左侧、右侧，都只有一种走法</span></span><br><span class="line"><span class="string">        左侧：dp[i][0] = dp[i-1][0] + triangle[i][0]</span></span><br><span class="line"><span class="string">        右侧：dp[i][i] = dp[i-1][i-1] + triangle[i][i]</span></span><br><span class="line"><span class="string">选择：ij遍历</span></span><br><span class="line"><span class="string">dp数组：计算dp[i][j]时，dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(triangle)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) + triangle[i][j]</span><br><span class="line">            dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>] + triangle[i][i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[n<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv">https://leetcode-cn.com/problems/longest-common-subsequence/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的 <strong>最长公共子序列</strong> 的长度。如果不存在 公共子序列 ，返回 <code>0</code> 。一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p>示例 1：<br>输入：<code>text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;</code><br>输出：<code>3</code><br>解释：最长公共子序列是 “ace” ，它的长度为 3 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示text1[0~i-1]和text2[0~j-1]两个字符串 最长公共子序列 的长度</span></span><br><span class="line"><span class="string">     text1和text2长度为m和n，为了初始化dp表，dp表在text1和text2开头加个空表示空串，dp需要存储m+1和j+1个，下标为[0~m][0~n]</span></span><br><span class="line"><span class="string">     dp[0][.]和dp[.][0]都有一个为空串，所以lcs赋初值0</span></span><br><span class="line"><span class="string">     text1和text2字符索引为[0~m-1][0~n-1]，对应dp表索引为[1~m][1~n]</span></span><br><span class="line"><span class="string">选择：计算text1[i]和text2[j]时，有两种选择：</span></span><br><span class="line"><span class="string">       text1[i]==text2[j]：该字符一定在公共子序列中</span></span><br><span class="line"><span class="string">       text1[i]!=text2[j]：至少一个(text1[i]或text2[j])不在公共子序列中</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># dp长度和text1、text2长度不同：text1和text2字符索引为[0~m-1][0~n-1]，对应dp表索引为[1~m][1~n]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]:  <span class="comment"># dp的i对应text的i-1</span></span><br><span class="line">                    <span class="comment"># 取 左上 公共子序列 的长度 + 1</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>  </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 取 左、上 公共子序列 的长度 最大值</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure></p>
<h2 id="072-编辑距离"><a href="#072-编辑距离" class="headerlink" title="072. 编辑距离"></a>072. 编辑距离</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZWRpdC1kaXN0YW5jZS8=">https://leetcode-cn.com/problems/edit-distance/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的<strong>最少操作数</strong>。<br>你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p>
<p>示例 1：<br>输入：<code>word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</code><br>输出：<code>3</code><br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
<p>示例 2：<br>输入：<code>word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</code><br>输出：<code>5</code><br>解释：<br>intention -&gt; inention (删除 ‘t’)<br>inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br>enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br>exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br>exection -&gt; execution (插入 ‘u’)</p>
<div class="tabs" id="72"><ul class="nav-tabs"><li class="tab active"><a href="#72-1">动态规划</a></li><li class="tab"><a href="#72-2">状态压缩</a></li></ul><div class="tab-content"><div class="tab-pane active" id="72-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i][j]表示word1的前i个字符和word2的前j个字符的编辑距离。最终结果dp[m][n]。</span></span><br><span class="line"><span class="string">        初始状态：dp的i==0、j==0加空串，dp[i][0]初始值为i(j为空串,距离为i)，dp[0][j]初始值为j(i为空串,距离为j)。</span></span><br><span class="line"><span class="string">        选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">        dp数组：判断s[i]是否等于s[j]情况：</span></span><br><span class="line"><span class="string">            (1) 两个字符相等：跳过，不编辑。</span></span><br><span class="line"><span class="string">            (2) 两个字符不相等：</span></span><br><span class="line"><span class="string">                (1) s1[i]到s2[j-1]距离 + s[i]插入s[j], dp[i][j-1] + 1。</span></span><br><span class="line"><span class="string">                (2) s1[i-1]到s2[j]距离 + s[i]字符删除, dp[i-1][j] + 1。    </span></span><br><span class="line"><span class="string">                (3) s1[i-1]到s2[j-1]距离 + s[i]替换为s[j], dp[i-1][j-1] + 1。   </span></span><br><span class="line"><span class="string">        需要左、上、左上位置信息，最终结果dp[m][n]，所以正着(i从上-&gt;下,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(word1)</span><br><span class="line">        n = <span class="built_in">len</span>(word2)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> m * n == <span class="number">0</span>: <span class="keyword">return</span> m + n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># DP 数组</span></span><br><span class="line">        dp = [ [<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>): dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>): dp[<span class="number">0</span>][j] = j</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                left = dp[i][j<span class="number">-1</span>] + <span class="number">1</span>  <span class="comment"># s1[i] -&gt; s2[j-1] -&gt; 插入</span></span><br><span class="line">                up = dp[i<span class="number">-1</span>][j] + <span class="number">1</span>  <span class="comment"># s1[i-1] -&gt; s2[j] -&gt; s1[i]删除</span></span><br><span class="line">                left_up = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>  <span class="comment"># s1[i-1] -&gt; s2[j-1] -&gt; 替换</span></span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]  <span class="comment"># 跳过</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(left, up, left_up)  <span class="comment"># 三种选择，取编辑距离最小的</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="72-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示word1的前i个字符和word2的前j个字符的编辑距离。</span></span><br><span class="line"><span class="string">状态压缩：用一维数组,表示原来二维数组中的一行,然后我们就反复覆盖里面的值。计算s[j]时：</span></span><br><span class="line"><span class="string">          dp[j-1]: 当前左边的元素(dp[i][j-1])</span></span><br><span class="line"><span class="string">          dp[j]: 没覆盖前的值，代表当前上边的元素(dp[i-1][j])</span></span><br><span class="line"><span class="string">          next: 在计算给s[j+1]用，代表s[j+1]左上的元素(dp[i-1][j-1])</span></span><br><span class="line"><span class="string">          pre：s[j+1]时使用，记录上次循环next中存储的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = <span class="built_in">list</span>(<span class="built_in">range</span>(n+<span class="number">1</span>)) <span class="comment"># dp[0]行初始值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            pre = dp[<span class="number">0</span>]  <span class="comment"># i次循环的左上初值</span></span><br><span class="line">            dp[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="built_in">next</span> = dp[j]  <span class="comment"># 记录下来，作为s[j+1]的左上</span></span><br><span class="line">                left = dp[j<span class="number">-1</span>] + <span class="number">1</span>  <span class="comment"># s1[i] -&gt; s2[j-1] -&gt; 插入</span></span><br><span class="line">                up = dp[j] + <span class="number">1</span>  <span class="comment"># s1[i-1] -&gt; s2[j] -&gt; s1[i]删除</span></span><br><span class="line">                left_up = pre + <span class="number">1</span>  <span class="comment"># s1[i-1] -&gt; s2[j-1] -&gt; 替换</span></span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[j] = pre  <span class="comment"># 跳过</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(left, up, left_up)  </span><br><span class="line">                pre = <span class="built_in">next</span>  <span class="comment"># 用于下次循环</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="005-最长回文子串-647"><a href="#005-最长回文子串-647" class="headerlink" title="005. 最长回文子串(647)"></a>005. 最长回文子串(647)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21pYy1zdWJzdHJpbmcv">https://leetcode-cn.com/problems/longest-palindromic-substring/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>示例 1：<br>输入：<code>s = &quot;babad&quot;</code><br>输出：<code>&quot;bab&quot;</code><br>解释：”aba” 同样是符合题意的答案。</p>
<div class="tabs" id="5"><ul class="nav-tabs"><li class="tab active"><a href="#5-1">动态规划</a></li><li class="tab"><a href="#5-2">中心扩展</a></li><li class="tab"><a href="#5-3">647. 回文子串</a></li></ul><div class="tab-content"><div class="tab-pane active" id="5-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示s[i~j]是否为回文字符串。</span></span><br><span class="line"><span class="string">初始状态：不需要加空串。只有一个字符(i==j)时结果为True; i&gt;j越界没有字符，结果为False。最终结束在dp[0][n-1]。</span></span><br><span class="line"><span class="string">选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">dp数组：假如知道&quot;bcb&quot;，就可以求&quot;abcba&quot;，先看&quot;bcb&quot;的是否为回文串，再判断s[i]是否等于s[j]情况：</span></span><br><span class="line"><span class="string">            只有一个字符：dp[i][i] = True</span></span><br><span class="line"><span class="string">            两个字符相等：</span></span><br><span class="line"><span class="string">                        只有两个字符：dp[i][j] = True</span></span><br><span class="line"><span class="string">                        三个及以上字符：dp[i][j] = dp[i+1][j-1]</span></span><br><span class="line"><span class="string">            两个字符不相等：dp[i][j] = False</span></span><br><span class="line"><span class="string">        需要左下位置信息，最终结果dp[0][n-1]，所以斜着(左上-&gt;右下)或反着(i从下-&gt;上,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        max_len = <span class="number">1</span></span><br><span class="line">        begin = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span>  <span class="comment"># 只有一个字符(i==j)时结果为True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> j-i &lt;= <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j - i + <span class="number">1</span> &gt; max_len:</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    begin = i</span><br><span class="line">        <span class="keyword">return</span> s[begin:begin + max_len]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="5-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    以每个字符为中心，向两边扩展。这里有两种情况，回文串为奇数、偶数，所以扩展的中心可以有字符，也可以为空。</span></span><br><span class="line"><span class="string">    时间复杂度：O(n^2)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span>(<span class="params">self, s, left, right</span>):</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回回文串 [左边界,右边界]</span></span><br><span class="line">        <span class="keyword">return</span> left+<span class="number">1</span>, right<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            left1, right1 = self.expandAroundCenter(s, i, i)  <span class="comment"># 奇数回文串，中心为s[i]</span></span><br><span class="line">            left2, right2 = self.expandAroundCenter(s, i, i+<span class="number">1</span>)  <span class="comment"># 偶数回文串，中心为s[i]和s[i+1]</span></span><br><span class="line">            <span class="comment"># 计算两种回文串长度，若比记录的长就更新</span></span><br><span class="line">            <span class="keyword">if</span> right1-left1 &gt; end-start:</span><br><span class="line">                start, end = left1, right1</span><br><span class="line">            <span class="keyword">if</span> right2-left2 &gt; end-start:</span><br><span class="line">                start, end = left2, right2</span><br><span class="line">        <span class="keyword">return</span> s[start: end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="5-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示s[i~j]是否为回文字符串。只需要在dp[i][j]为True时累加。</span></span><br><span class="line"><span class="string">初始状态：不需要加空串。只有一个字符(i==j)时结果为True; i&gt;j越界没有字符，结果为False。最终结束在dp[0][n-1]。</span></span><br><span class="line"><span class="string">选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">dp数组：假如知道&quot;bcb&quot;，就可以求&quot;abcba&quot;，先看&quot;bcb&quot;的是否为回文串，再判断s[i]是否等于s[j]情况：</span></span><br><span class="line"><span class="string">            只有一个字符：dp[i][i] = True</span></span><br><span class="line"><span class="string">            两个字符相等：</span></span><br><span class="line"><span class="string">                        只有两个字符：dp[i][j] = True</span></span><br><span class="line"><span class="string">                        三个及以上字符：dp[i][j] = dp[i+1][j-1]，只有在dp[i+1][j-1]为True时才累加。</span></span><br><span class="line"><span class="string">            两个字符不相等：dp[i][j] = False</span></span><br><span class="line"><span class="string">        需要左下位置信息，最终结果dp[0][n-1]，所以斜着(左上-&gt;右下)或反着(i从下-&gt;上,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(s)):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j-i &lt;= <span class="number">1</span>: <span class="comment"># 只有两个字符</span></span><br><span class="line">                        result += <span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>]: <span class="comment"># 三个及以上字符，且dp[i+1][j-1]==True</span></span><br><span class="line">                        result += <span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21pYy1zdWJzZXF1ZW5jZS8=">https://leetcode-cn.com/problems/longest-palindromic-subsequence/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。<br>示例 1：<br>输入：<code>s = &quot;bbbab&quot;</code><br>输出：<code>4</code><br>解释：一个可能的最长回文子序列为 “bbbb” 。</p>
<p>示例 2：<br>输入：<code>s = &quot;cbbd&quot;</code><br>输出：<code>2</code><br>解释：一个可能的最长回文子序列为 “bb” 。</p>
<p>这里注意<strong>回文子串</strong>、<strong>回文子序列</strong>区别：<br>（1）<strong>回文子串</strong>：dp存储True、False判断，这样可保证新串是连续的；<br>（2）<strong>回文子序列</strong>：dp存储长度，这样在新序列中可以继承子序列长度，新序列可以非连续的。<br><div class="tabs" id="516"><ul class="nav-tabs"><li class="tab active"><a href="#516-1">动态规划</a></li><li class="tab"><a href="#516-2">状态压缩</a></li></ul><div class="tab-content"><div class="tab-pane active" id="516-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示s[i~j]中，最长回文子序列长度。最终结果dp[0][n-1]。</span></span><br><span class="line"><span class="string">初始状态：不需要加空串。只有一个字符(i==j)时结果为1; i&gt;j越界没有字符，结果为0。</span></span><br><span class="line"><span class="string">选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">dp数组：假如知道&quot;bcb&quot;，就可以求&quot;abcba&quot;，只需&quot;bcb&quot;的最长回文序列长度，判断s[i]是否等于s[j]情况：</span></span><br><span class="line"><span class="string">            两个字符相等：两个字符都加入回文序列，int(s[i]==s[j])*2。</span></span><br><span class="line"><span class="string">            两个字符不相等：两个字符单独加入回文序列，取长的那个，max(dp[i+1][j], dp[i][j-1])。</span></span><br><span class="line"><span class="string">        需要左下、左、下，三个位置信息，最终结果dp[0][n-1]，所以斜着(左上-&gt;右下)或反着(i从下-&gt;上,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i][i] = <span class="number">1</span>  <span class="comment"># 只有一个字符(i==j)时结果为1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>  <span class="comment"># 左下</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>])  <span class="comment"># 下、左</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="516-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">去掉[i]这个维度，只用[j]。计算s[j]时：</span></span><br><span class="line"><span class="string">    dp[j-1]: 当前左边的元素(dp[i][j-1])</span></span><br><span class="line"><span class="string">    dp[j]: 没覆盖前的值，代表当前下边的元素(dp[i+1][j])</span></span><br><span class="line"><span class="string">    next: 在计算给s[j+1]用，代表s[j+1]左下的元素(dp[i+1][j-1])</span></span><br><span class="line"><span class="string">    pre：s[j+1]时使用，记录上次循环next中存储的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [<span class="number">0</span>] * n </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            pre = <span class="number">0</span>  <span class="comment"># i次循环的左下初值   </span></span><br><span class="line">            dp[i] = <span class="number">1</span>  <span class="comment"># 只有一个字符(i==j)时结果为1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="built_in">next</span> = dp[j]</span><br><span class="line">                left = dp[j<span class="number">-1</span>]</span><br><span class="line">                down = dp[j]</span><br><span class="line">                left_down = pre</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[j] = left_down + <span class="number">2</span>  <span class="comment"># </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(down, left)  <span class="comment"># 下、左</span></span><br><span class="line">                pre = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="1312-成为回文串的最少插入次数"><a href="#1312-成为回文串的最少插入次数" class="headerlink" title="1312. 成为回文串的最少插入次数"></a>1312. 成为回文串的最少插入次数</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1pbnNlcnRpb24tc3RlcHMtdG8tbWFrZS1hLXN0cmluZy1wYWxpbmRyb21lLw==">https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。「回文串」是正读和反读都相同的字符串。</p>
<p>示例 1：<br>输入：<code>s = &quot;zzazz&quot;</code><br>输出：<code>0</code><br>解释：字符串 “zzazz” 已经是回文串了，所以不需要做任何插入操作。</p>
<p>示例 2：<br>输入：<code>s = &quot;leetcode&quot;</code><br>输出：<code>5</code><br>解释：插入 5 个字符后字符串变为 “leetcodocteel” 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minInsertions</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示字符串s[i~j]，成为回文串的最少插入次数。 最终求dp[0][n-1]大小。</span></span><br><span class="line"><span class="string">初始状态：当i==j时，只有一个字符已经是回文串，插入次数为0，dp[i][j]=0</span></span><br><span class="line"><span class="string">选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">dp数组：知道dp[i+1][j-1]，求dp[i][j]? dp[i+1][j-1]已经是回文串了，只需看s[i]和s[j]字符：</span></span><br><span class="line"><span class="string">        (1) 两个字符相等：不需要插入，dp[i][j]=dp[i+1][j-1]。</span></span><br><span class="line"><span class="string">        (2) 两个字符不相等：需要插入</span></span><br><span class="line"><span class="string">            (1) 两个字符都插入：s[i]插入到s[j]右侧，s[j]插入到s[i]右侧，s[i~j]必为回文串。dp[i+1][j-1]+2</span></span><br><span class="line"><span class="string">            (2) 只插入一个字符：比如&#x27;aa&#x27;左侧/右侧插入&#x27;a&#x27;；选择最小的那个。min(dp[i+1][j], dp[i][j-1]) + 1</span></span><br><span class="line"><span class="string">            其中&quot;只插入一个字符&quot;包括了&quot;两个字符都插入&quot;的情况，代码中可省略&quot;两个字符都插入&quot;。</span></span><br><span class="line"><span class="string">        需要左下、左、下，三个位置信息，最终结果dp[0][n-1]，所以斜着(左上-&gt;右下)或反着(i从下-&gt;上,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># dp已经初始化, i从n-2开始</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] <span class="comment"># 跳过</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 左插入s[j]字符(dp[i+1][j])，右插入s[i]字符(dp[i][j-1])</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j]) + <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="010-正则表达式匹配"><a href="#010-正则表达式匹配" class="headerlink" title="010. 正则表达式匹配"></a>010. 正则表达式匹配</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVndWxhci1leHByZXNzaW9uLW1hdGNoaW5nLw==">https://leetcode-cn.com/problems/regular-expression-matching/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>.</code> 和 <code>*</code> 的正则表达式匹配。<code>.</code> 匹配任意单个字符。<code>*</code> 匹配零个或多个前面的那一个元素。所谓匹配，是要涵盖 整个 字符串 <code>s</code> 的，而不是部分字符串。</p>
<p>本题较为复杂，可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVndWxhci1leHByZXNzaW9uLW1hdGNoaW5nL3NvbHV0aW9uL2h1aS1zdS1oZS1kb25nLXRhaS1ndWktaHVhLWJ5LW1sLXppbWluZ21lbmcv">腐烂的橘子 题解<i class="fa fa-external-link-alt"></i></span>中的解释。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示s[0~i-1]和p[0~j-1]是否匹配，这里行列添加空串，所以dp的i,j的字符，对应s的i-1,j-1字符。</span></span><br><span class="line"><span class="string">初始状态：行列加空串，只有dp[0][0] = True。</span></span><br><span class="line"><span class="string">选择：i和j向后扩展，结果为dp[m][n]。</span></span><br><span class="line"><span class="string">dp数组：计算dp[i][j]时，判断当前两个字符s[i-1]和p[j-1]情况：</span></span><br><span class="line"><span class="string">        (1) 如果p[j-1]为&#x27;.&#x27;/字符：</span></span><br><span class="line"><span class="string">            (1) s[i-1] != p[j-1]：无法继续匹配，False</span></span><br><span class="line"><span class="string">            (2) s[i-1] == p[j-1]：取决于dp[i-1][j-1]是否匹配</span></span><br><span class="line"><span class="string">        (2) 如果p[j-1]为&#x27;*&#x27;，看p[j-2]和s[i-1]：</span></span><br><span class="line"><span class="string">            (1) s[i-1] == p[j-2]：&#x27;*&#x27;可匹配多次/0次(dp[i-1][j]/dp[i][j-2])</span></span><br><span class="line"><span class="string">            (2) s[i-1] != p[j-2]：&#x27;*&#x27;只能匹配0次, s[j-2]和s[j-1]都去掉，所以是dp[i][j-2]。</span></span><br><span class="line"><span class="string">p[j-1]为&#x27;*&#x27;时，为什么看p[j-2]和s[i-1]？因为此时p[j-1]是和p[j-2]为一体的了并且以p[j-2]的字符为主。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="built_in">len</span>(p) == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment">#当S为空，P不空，要看P是否为 a*b*这种结构</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] <span class="keyword">or</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> p[j<span class="number">-2</span>] == s[i<span class="number">-1</span>] <span class="keyword">or</span> p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j] <span class="keyword">or</span> dp[i][j<span class="number">-1</span>] <span class="keyword">or</span> dp[i][j<span class="number">-2</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure></p>
<h2 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a>887. 鸡蛋掉落</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VwZXItZWdnLWRyb3Av">https://leetcode-cn.com/problems/super-egg-drop/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。已知存在楼层 <code>f</code> ，满足 <code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。给定 <code>k</code> 个鸡蛋，楼层数 <code>n</code>，请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作(扔鸡蛋)次数</strong> 是多少？ 换句话说，<strong>最坏</strong>情况下，<strong>至少</strong>扔几次蛋，才能确定楼层 <code>f</code> ？<strong>最坏</strong>：仍蛋的次数，在最坏情况下，是最少的。</p>
<p>示例 1：<br>输入：<code>k = 1, n = 2</code><br>输出：<code>2</code><br>解释：鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。<br>如果它没碎，那么肯定能得出 f = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提示：如果不加鸡蛋数量限制，可用二分搜索得到最小操作次数。本题用动态规划。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：“dp[n][k]=m 表示有k个蛋，共n层楼，最小操作次数m”，转换下思维：</span></span><br><span class="line"><span class="string">      “dp[m][k]=n 表示有k个蛋，最多仍m次，能确定f所在的最高楼层数n”；</span></span><br><span class="line"><span class="string">       确定m的上限，一定是 &lt;=n 的(线性扫描)。</span></span><br><span class="line"><span class="string">初始状态：只能仍1次，不管蛋多少个，最高确定1层楼；</span></span><br><span class="line"><span class="string">          只有1个蛋，最高确定层数等于仍的次数。</span></span><br><span class="line"><span class="string">选择：无论在哪层仍蛋，只有2种结果：碎了测楼下，没碎测楼上。所以不需要考虑选择在哪仍蛋。</span></span><br><span class="line"><span class="string">dp表：无论楼上楼下，总楼层数 = 楼上的楼层数 + 楼下的楼层数 + 1(当前楼层)</span></span><br><span class="line"><span class="string">      蛋没碎：当前楼层上方可以有 dp[m-1][k] 层。</span></span><br><span class="line"><span class="string">      蛋碎：当前楼层下方可以有 dp[m-1][k-1] 层。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(k+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 只能仍1次，不管蛋多少个，最高确定1层楼。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        m = <span class="number">-1</span>  <span class="comment"># 存储最终结果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):  <span class="comment"># 次数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">1</span>):  <span class="comment"># 蛋数</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i<span class="number">-1</span>][j] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>] </span><br><span class="line">            <span class="keyword">if</span> dp[i][k] &gt;= n: <span class="comment"># 首次达到目标楼层数，取出最小操作次数m</span></span><br><span class="line">                m = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>
<h2 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a>312. 戳气球</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYnVyc3QtYmFsbG9vbnMv">https://leetcode-cn.com/problems/burst-balloons/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：有 <code>n</code> 个气球，编号为 <code>0</code> 到 <code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code> 相邻的两个气球的序号。如果 <code>i - 1</code> 或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。求所能获得硬币的最大数量。</p>
<p>示例 1：<br>输入：<code>nums = [3,1,5,8]</code><br>输出：<code>167</code><br>解释：<br><code>nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []</code><br><code>coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">在nums两边加上值为1的虚拟气球，nums长度为len(nums)+2。</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示i~j之间(nums[i+1~j-1])气球被戳破后，最大硬币数量。求dp[0][n+1]值。</span></span><br><span class="line"><span class="string">初始状态：当 j &lt;= i+1 时，区间中没有气球，硬币值为0。</span></span><br><span class="line"><span class="string">选择：设k为i~j之间最后被戳破的气球，那么k的选择可以是i~j之间任意一个。</span></span><br><span class="line"><span class="string">dp数组：dp[i][j] = dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j]</span></span><br><span class="line"><span class="string">        dp[i][k]：表示i~k之间求被戳破的硬币值。</span></span><br><span class="line"><span class="string">        dp[k][j]：表示k~j之间求被戳破的硬币值。</span></span><br><span class="line"><span class="string">        nums[i]*nums[k]*nums[j]：表示k在i~j之间，最后被戳破的硬币值。</span></span><br><span class="line"><span class="string">最终求dp[0][n+1]，所以倒着遍历/斜着遍历，这里选择倒着遍历(i从下-&gt;上，j从左-&gt;右)。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">2</span>)]</span><br><span class="line">        nums = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):      <span class="comment"># n-1 -&gt; 0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">2</span>, n+<span class="number">2</span>):   <span class="comment"># i+2 -&gt; n+1</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, j):   <span class="comment"># i+1 &lt;= k &lt;= j-1</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(</span><br><span class="line">                                    dp[i][j],</span><br><span class="line">                                    dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j]</span><br><span class="line">                               )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><strong>题目描述</strong>：给你一个可装载重量为 <code>W</code> 的背包和 <code>N</code> 个物品，每个物品有重量和价值两个属性。其中第 <code>i</code> 个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack</span>(<span class="params">W: <span class="built_in">int</span>, N: <span class="built_in">int</span>, wt: List[<span class="built_in">int</span>], val: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">提示：背包问题的典型套路是，状态的定义！</span></span><br><span class="line"><span class="string">状态：dp[i][w]表示前 i 个物品，背包载重为 w，最多装的价值。求dp[N][W]值。</span></span><br><span class="line"><span class="string">初始状态：dp[0][..] = 0、dp[..][0] = 0</span></span><br><span class="line"><span class="string">选择：当前物品，能装/不能装。</span></span><br><span class="line"><span class="string">dp数组：当前物品 i：</span></span><br><span class="line"><span class="string">       (1) 能装进背包：装/不装 择优，dp[i][w] = max(dp[i-1][w-wt[i-1]] + val[i-1], dp[i-1][w])</span></span><br><span class="line"><span class="string">       (2) 不能装进背包：dp[i][w] = dp[i-1][w]</span></span><br><span class="line"><span class="string">       i从1开始，对应wt和val是从0开始。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):  <span class="comment"># 物品</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W+<span class="number">1</span>):  <span class="comment"># 载重</span></span><br><span class="line">            <span class="keyword">if</span> w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>:  <span class="comment"># 不能装，只有不装这一种结果</span></span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 能装，装/不装 择优</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][w-wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], dp[i<span class="number">-1</span>][w])</span><br><span class="line">    <span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure></p>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWVxdWFsLXN1YnNldC1zdW0v">https://leetcode-cn.com/problems/partition-equal-subset-sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>示例 1：<br>输入：<code>nums = [1,5,11,5]</code><br>输出：<code>true</code><br>解释：数组可以分割成 <code>[1, 5, 5]</code> 和 <code>[11]</code> 。</p>
<p>示例 2：<br>输入：<code>nums = [1,2,3,5]</code><br>输出：<code>false</code><br>解释：数组不能分割成两个元素和相等的子集。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">转化为背包问题：既然要分2个和相等的子集，那么一个子集的和就是nums的和sum除以2，问题转化为：</span></span><br><span class="line"><span class="string">“载重为sum/2的背包，N个物品，每个物品重量为nums[i]，问是否存在一种装法，能恰好将背包装满？”</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示前 i 个物品，载重为 j 时，能不能将背包装满(True/False)。求dp[len(nums)][sum/2]的值。</span></span><br><span class="line"><span class="string">初始状态：dp[0][..] = False、dp[..][0] = True</span></span><br><span class="line"><span class="string">选择：当前物品，能装/不能装。</span></span><br><span class="line"><span class="string">dp数组：当前物品 i：</span></span><br><span class="line"><span class="string">       (1) 能装进背包：装/不装 择优，dp[i][j] = dp[i-1][j-nums[i-1]] or dp[i-1][j]</span></span><br><span class="line"><span class="string">       (2) 不能装进背包：dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="string">       i从1开始，对应nums是从0开始。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 和为奇数时不能分</span></span><br><span class="line">            </span><br><span class="line">        target = total // <span class="number">2</span></span><br><span class="line">        maxNum = <span class="built_in">max</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> maxNum &gt; target: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 最大值大于目标值，不可能分成2个目标值</span></span><br><span class="line">            </span><br><span class="line">        dp = [[<span class="literal">False</span>] * (target+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># target为0，相当于装满了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j-nums[i<span class="number">-1</span>] &lt; <span class="number">0</span>:  <span class="comment"># 不能装</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]] <span class="keyword">or</span> dp[i<span class="number">-1</span>][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][target]</span><br></pre></td></tr></table></figure></p>
<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2UtMi8=">https://leetcode-cn.com/problems/coin-change-2/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。请你计算并返回可以<strong>凑成总金额的硬币组合数</strong>。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。</p>
<p>示例 1：<br>输入：<code>amount = 5, coins = [1, 2, 5]</code><br>输出：<code>4</code><br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p>
<div class="tabs" id="518"><ul class="nav-tabs"><li class="tab active"><a href="#518-1">动态规划</a></li><li class="tab"><a href="#518-2">状态压缩</a></li></ul><div class="tab-content"><div class="tab-pane active" id="518-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">转化为背包问题：“载重为amount的背包，N个物品(coins个数)，每个物品重量为coins[i]，每个物品的数量无限，</span></span><br><span class="line"><span class="string">                 问是存在几种装法，能恰好将背包装满？”</span></span><br><span class="line"><span class="string">                 因为物品的数量无限，所以又叫完全背包问题。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">增加空状态，dp[i]对应coins[i-1]。</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示只用前 i 个物品(包括i)，载重为 j 时，能恰好成功的装法有多少。求dp[N][amount]值。</span></span><br><span class="line"><span class="string">初始状态：空物品为0种装法(dp[0][..]=0)，空包为1种装法(dp[..][0]=1)</span></span><br><span class="line"><span class="string">选择：能装/不能装</span></span><br><span class="line"><span class="string">dp数组：当前第 i 个物品：</span></span><br><span class="line"><span class="string">        (1) 装进：那么取前 i 个物品，凑出j-coins[i-1]。dp[i][j] = dp[i][j-coins[i-1]]</span></span><br><span class="line"><span class="string">        (2) 不装进：那么取前 i-1 个物品，凑出j。dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="string">        要求的是总共有多少装法，最终的dp[i][j]是上面两种选择结果的和。dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]  <span class="comment"># 空物品为0种装法</span></span><br><span class="line">        <span class="comment"># 初始状态,空包为1种装法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):  <span class="comment"># 前i个物品</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):  <span class="comment"># 载重j</span></span><br><span class="line">                <span class="keyword">if</span> j-coins[i<span class="number">-1</span>]&gt;=<span class="number">0</span>:  <span class="comment"># 能装</span></span><br><span class="line">                    dp[i][j] = dp[i][j-coins[i<span class="number">-1</span>]] + dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 不能装</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[n][amount]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="518-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态压缩：注意到 i 只与当前i行和i-1行有关，可压缩维度i，dp只记录j。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [<span class="number">0</span>]*(amount+<span class="number">1</span>)   <span class="comment"># 空物品为0种装法</span></span><br><span class="line">        <span class="comment"># 初始状态,空包为1种装法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):  <span class="comment"># 前i个物品</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):  <span class="comment"># 载重j</span></span><br><span class="line">                <span class="keyword">if</span> j-coins[i<span class="number">-1</span>]&gt;=<span class="number">0</span>:  <span class="comment"># 能装</span></span><br><span class="line">                    dp[j] = dp[j-coins[i<span class="number">-1</span>]] + dp[j]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLw==">https://leetcode-cn.com/problems/house-robber/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvR3UwYzJULw==">剑指 Offer II 089. 房屋偷盗<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。<br>示例 1：<br>输入：<code>[1,2,3,1]</code><br>输出：<code>4</code><br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<div class="tabs" id="198"><ul class="nav-tabs"><li class="tab active"><a href="#198-1">动态规划</a></li><li class="tab"><a href="#198-2">状态压缩</a></li></ul><div class="tab-content"><div class="tab-pane active" id="198-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：从前向后偷，dp[i]表示偷到 i 间时，最多偷的钱。</span></span><br><span class="line"><span class="string">选择：当前 i 间：</span></span><br><span class="line"><span class="string">     (1) 偷：dp[i] = nums[i] + dp[i-2]</span></span><br><span class="line"><span class="string">     (2) 不偷：dp[i] = dp[i-1]</span></span><br><span class="line"><span class="string">     取结果最大的。</span></span><br><span class="line"><span class="string">初始状态：dp[0] = nums[0]，dp[1] = max(dp[0], nums[1]+0)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]+<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i]+dp[i<span class="number">-2</span>], dp[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i]表示从第 i 间房开始，能偷多少。求dp[0]</span></span><br><span class="line"><span class="string">初始状态：跳过最后一间房子，结束dp[n] = 0</span></span><br><span class="line"><span class="string">选择：偷/不偷</span></span><br><span class="line"><span class="string">dp数组：当前第 i 间房子开始：</span></span><br><span class="line"><span class="string">        (1) 偷：dp[i] = nums[i] + dp[i+2]</span></span><br><span class="line"><span class="string">        (2) 不偷：dp[i] = dp[i+1]</span></span><br><span class="line"><span class="string">        取结果最大的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">2</span>)</span><br><span class="line">        dp[n] = <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i]+dp[i+<span class="number">2</span>], dp[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="198-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意到dp[i]只和dp[i-1]、dp[i-2]有关，用常量记录。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">         <span class="comment"># dp1记录dp[i-2]、dp2记录dp[i]和dp[i-1](dp2更新前的值)</span></span><br><span class="line">        dp1, dp2 = nums[<span class="number">0</span>], <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]+<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp1, dp2 = dp2, <span class="built_in">max</span>(nums[i]+dp1, dp2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意到dp[i]只和dp[i+1]、dp[i+2]有关，用常量记录。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 记录dp[i+1]、dp[i+2]</span></span><br><span class="line">        dp1, dp2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dpi = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dpi = <span class="built_in">max</span>(nums[i]+dp2, dp1)</span><br><span class="line">            dp2 = dp1</span><br><span class="line">            dp1 = dpi  <span class="comment"># 当前计算的 i，为下一轮 i-1 时刻的 i+1</span></span><br><span class="line">        <span class="keyword">return</span> dpi</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpLw==">https://leetcode-cn.com/problems/house-robber-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。<br>示例 1：<br>输入：<code>nums = [2,3,2]</code><br>输出：<code>3</code><br>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">第一间和最后一间不能同时取钱，有三种结果：</span></span><br><span class="line"><span class="string">(1) 第一间和最后一间都不取</span></span><br><span class="line"><span class="string">(2) 第一间到倒数第二间之间取(取第一间就不能取最后一间)，robRange(0, n-2)</span></span><br><span class="line"><span class="string">(3) 第二间到最后一间之间取(取最后一间就不能取第一间)，robRange(1, n-1)</span></span><br><span class="line"><span class="string">结果为这三种情况获得的最多钱，注意(2)(3)情况已经包含了第一种情况，可不写(1)。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">robRange</span>(<span class="params">start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">            dp1 = nums[start]</span><br><span class="line">            dp2 = <span class="built_in">max</span>(nums[start], nums[start+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start+<span class="number">2</span>, end+<span class="number">1</span>):</span><br><span class="line">                dp1, dp2 = dp2, <span class="built_in">max</span>(nums[i]+dp1, dp2)</span><br><span class="line">            <span class="keyword">return</span> dp2</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]+<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="built_in">max</span>(robRange(<span class="number">0</span>, n<span class="number">-2</span>), robRange(<span class="number">1</span>, n<span class="number">-1</span>))</span><br></pre></td></tr></table></figure></p>
<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a>337. 打家劫舍 III</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpaS8=">https://leetcode-cn.com/problems/house-robber-iii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为<code>root</code> 。除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警</strong>。定二叉树的 <code>root</code> 。返回 <strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额 。</p>
<p>示例 1:<br>输入: <code>root = [3,2,3,null,3,null,1]</code><br>输出: <code>7</code><br>解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</p>
<p>示例 2:<br>输入: <code>root = [3,4,5,1,3,null,1]</code><br>输出: <code>9</code><br>解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</p>
<div class="tabs" id="337"><ul class="nav-tabs"><li class="tab active"><a href="#337-1">动态规划</a></li><li class="tab"><a href="#337-2">递归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="337-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line">hamp = <span class="built_in">dict</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当前节点 i：</span></span><br><span class="line"><span class="string">        (1) 偷：i.left.left/right, i.right.left/right</span></span><br><span class="line"><span class="string">        (2) 不偷：i.left/right</span></span><br><span class="line"><span class="string">        注意，节点可能为空的情况。</span></span><br><span class="line"><span class="string">        定义一个hmap记录重叠部分。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">in</span> hamp: <span class="keyword">return</span> hamp[root]</span><br><span class="line">        <span class="comment"># 偷</span></span><br><span class="line">        do_it = root.val + (self.rob(root.left.left)+self.rob(root.left.right) <span class="keyword">if</span> root.left <span class="keyword">else</span> <span class="number">0</span>) \</span><br><span class="line">                         + (self.rob(root.right.left)+self.rob(root.right.right) <span class="keyword">if</span> root.right <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 不偷</span></span><br><span class="line">        not_do = self.rob(root.left) + self.rob(root.right)</span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">max</span>(do_it, not_do)  <span class="comment"># 选择收益最大的</span></span><br><span class="line">        hamp[root] = res <span class="comment"># 更新hamp</span></span><br><span class="line">        print(root.val, do_it, not_do, hamp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="337-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 当前节点选择 [不偷,偷] 得到的最大金额。</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">node</span>):</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># 左孩子和右孩子最优情况</span></span><br><span class="line">                left = DFS(node.left)</span><br><span class="line">                right = DFS(node.right)</span><br><span class="line">                <span class="comment"># 当前节点不偷（可偷子节点）</span></span><br><span class="line">                <span class="comment"># 当前节点偷（当前节点值+子节点不偷的值(left[0]+right[0])）]</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">max</span>(left)+<span class="built_in">max</span>(right), node.val+left[<span class="number">0</span>]+right[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># 返回小偷盗取金额的最大值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(DFS(root))</span><br></pre></td></tr></table></figure></div></div></div>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>贪心算法是一种特殊的动态规划，拥有一些特殊性质，可以<strong>进一步降低动态规划的时间复杂度</strong>。</p>
<h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21lLw==">https://leetcode-cn.com/problems/longest-palindrome/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个包含大写字母和小写字母的字符串 <code>s</code> ，返回 通过这些字母构造成的 <strong>最长的回文串</strong> 。在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。<br>示例 1:<br>输入:<code>s = &quot;abccccdd&quot;</code><br>输出:<code>7</code><br>解释: 我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">回文串长度为奇数，除中心字符外，两侧字符串相同；长度为偶数，两侧字符串相同。</span></span><br><span class="line"><span class="string">奇数时，只有中间字符为1次，其余字符为偶数次；偶数时，所有字符为偶数次。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">构建时，每个字符使用偶数次，若剩余字符，选一个放中间。</span></span><br><span class="line"><span class="string">每个字符可放 count(ch) // 2 * 2 次，遇到第一个奇数ch，放入ans作为中间字符(ans变为奇数)，之后奇数字符不再放入。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        count = collections.Counter(s)</span><br><span class="line">        <span class="keyword">for</span> cnt <span class="keyword">in</span> count.values():</span><br><span class="line">            ans += cnt // <span class="number">2</span> * <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> ans % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> cnt % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="055-跳跃游戏"><a href="#055-跳跃游戏" class="headerlink" title="055. 跳跃游戏"></a>055. 跳跃游戏</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLw==">https://leetcode-cn.com/problems/jump-game/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个非负整数数组 nums ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。<br>示例 1：<br>输入：<code>nums = [2,3,1,1,4]</code><br>输出：<code>true</code><br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        rightmost：当前 i 位置，最远能跳到的位置max(rightmost, i+nums[i])。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n, rightmost = <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            rightmost = <span class="built_in">max</span>(rightmost, i+nums[i])</span><br><span class="line">            <span class="comment"># 最远到 i 位置，会卡住跳不动了</span></span><br><span class="line">            <span class="keyword">if</span> rightmost &lt;= i: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> rightmost &gt;= n<span class="number">-1</span>  <span class="comment"># 能跳到边界</span></span><br></pre></td></tr></table></figure></p>
<h2 id="045-跳跃游戏-II"><a href="#045-跳跃游戏-II" class="headerlink" title="045. 跳跃游戏 II"></a>045. 跳跃游戏 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLWlpLw==">https://leetcode-cn.com/problems/jump-game-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。<br>示例 1:<br>输入: <code>nums = [2,3,1,1,4]</code><br>输出: <code>2</code><br>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        maxPos：从索引 i~end 起跳，最远能到的距离。</span></span><br><span class="line"><span class="string">        end：在索引 i，最多能跳到索引 end。</span></span><br><span class="line"><span class="string">        step：记录跳跃次数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        maxPos, end, step = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>):  <span class="comment"># 可不访问最后一个元素</span></span><br><span class="line">            maxPos = <span class="built_in">max</span>(maxPos, i+nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                end = maxPos</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure></p>
<h1 id="回溯-DFS"><a href="#回溯-DFS" class="headerlink" title="回溯/DFS"></a>回溯/DFS</h1><p><strong>回溯</strong>：也是解决穷举问题，相比动态规划更简单直接。回溯本质是一个决策树的遍历过程：<br>（1）路径：已经做出的选择。<br>（2）选择列表：你当前可以做的选择。<br>（3）结束条件：到达决策底层，无法再做选择的条件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">res = []  <span class="comment"># 存储所有路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        res.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        将 选择 从 选择列表 中移除</span><br><span class="line">        路径.append(选择)</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        路径.remove(选择)</span><br><span class="line">        将 选择 恢复到 选择列表 </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 也可也加判断，过滤掉不合法选择</span></span><br><span class="line">    <span class="comment"># 这样就省去了“将 选择 从 选择列表 中移除/恢复”操作</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        <span class="keyword">if</span> 选择 <span class="keyword">in</span> 路径: <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        路径.append(选择)</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        路径.remove(选择)</span><br></pre></td></tr></table></figure></p>
<h2 id="046-全排列"><a href="#046-全排列" class="headerlink" title="046. 全排列"></a>046. 全排列</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLw==">https://leetcode-cn.com/problems/permutations/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个<strong>不含重复数字</strong>的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。<br>示例 1：<br>输入：<code>nums = [1,2,3]</code><br>输出：<code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        路径：记录在track中</span></span><br><span class="line"><span class="string">        选择列表：nums中不存在于track的元素</span></span><br><span class="line"><span class="string">        结束条件：nums中所有元素全在track中出现</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">track</span>):</span></span><br><span class="line">            <span class="comment"># 结束条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track)==<span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(track[:]) <span class="comment"># 必须使用切片，不然存入的只是指针</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 排除不合法选择</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment"># 进入下一层决策树</span></span><br><span class="line">                backtrack(track)</span><br><span class="line">                <span class="comment"># 取消选择</span></span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        backtrack(track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="047-全排列-II"><a href="#047-全排列-II" class="headerlink" title="047. 全排列 II"></a>047. 全排列 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLWlpLw==">https://leetcode-cn.com/problems/permutations-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有<strong>不重复</strong>的全排列。<br>示例 1：<br>输入：<code>nums = [1,1,2]</code><br>输出：<code>[[1,1,2],[1,2,1],[2,1,1]]</code><br><div class="tabs" id="47"><ul class="nav-tabs"><li class="tab active"><a href="#47-1">回溯</a></li><li class="tab"><a href="#47-2">方便理解</a></li></ul><div class="tab-content"><div class="tab-pane active" id="47-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为保证不重复：</span></span><br><span class="line"><span class="string">        (1) 排序，使重复值相邻</span></span><br><span class="line"><span class="string">        (2) 定义visited，标记对应位置nums[i]是否使用</span></span><br><span class="line"><span class="string">        (3) 一定要按顺序生成，比如[1,2,2]:</span></span><br><span class="line"><span class="string">            应该从 [填入,未填入,未填入]-&gt;[填入,填入,未填入]-&gt;[填入,填入,填入]</span></span><br><span class="line"><span class="string">            避免从 [填入,未填入,未填入]-&gt;[填入,未填入,填入]-&gt;[填入,填入,填入]</span></span><br><span class="line"><span class="string">            也就是，nums[i]和nums[i-1]相同，且nums[i-1]未被使用过，应该剪掉这个(因为会和nums[i-1]使用的重复)。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">track, visited</span>):</span></span><br><span class="line">            <span class="keyword">if</span> n==<span class="built_in">len</span>(track):</span><br><span class="line">                res.append(track[:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 不能使用重复位置的值</span></span><br><span class="line">                <span class="keyword">if</span> visited[i] == <span class="number">1</span>: <span class="keyword">continue</span>  </span><br><span class="line">                <span class="comment"># 按顺序生成，遇到重复剪掉</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> visited[i<span class="number">-1</span>]==<span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">               </span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                visited[i] = <span class="number">1</span></span><br><span class="line">                backtrack(track, visited)</span><br><span class="line">                track.pop()</span><br><span class="line">                visited[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        visited = [<span class="number">0</span>] * n  <span class="comment"># 标记nums[i]使用/未使用</span></span><br><span class="line">        nums.sort()  <span class="comment"># 需要排序</span></span><br><span class="line">        </span><br><span class="line">        backtrack(track, visited)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="47-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        每次要把当前元素去除，使用剩余元素ns组成路径，</span></span><br><span class="line"><span class="string">        ns的切片操作耗费时间长(每次生成新列表)。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">ns, track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="built_in">len</span>(track) <span class="keyword">and</span> track <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                res.append(track[:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ns)):</span><br><span class="line">                track.append(ns[i])</span><br><span class="line">                <span class="comment"># 去除当前元素</span></span><br><span class="line">                backtrack(ns[:i]+ns[i+<span class="number">1</span>:], track)   </span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        nums.sort()  <span class="comment"># 需要排序</span></span><br><span class="line">        backtrack(nums, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="078-子集"><a href="#078-子集" class="headerlink" title="078. 子集"></a>078. 子集</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3Vic2V0cy8=">https://leetcode-cn.com/problems/subsets/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。<br>示例 1：<br>输入：<code>nums = [1,2,3]</code><br>输出：<code>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code><br><div class="tabs" id="78"><ul class="nav-tabs"><li class="tab active"><a href="#78-1">回溯</a></li><li class="tab"><a href="#78-2">迭代</a></li></ul><div class="tab-content"><div class="tab-pane active" id="78-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, track</span>):</span></span><br><span class="line">            res.append(track[:])  <span class="comment"># 存储当前路径</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res = []  <span class="comment"># 所有路径(track)</span></span><br><span class="line">        track = []  <span class="comment"># 当前路径   </span></span><br><span class="line">        backtrack(<span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="78-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = [[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res = res + [[i] + num <span class="keyword">for</span> num <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="090-子集-II"><a href="#090-子集-II" class="headerlink" title="090. 子集 II"></a>090. 子集 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3Vic2V0cy1paS8=">https://leetcode-cn.com/problems/subsets-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。<br>示例 1：<br>输入：<code>nums = [1,2,2]</code><br>输出：<code>[[],[1],[1,2],[1,2,2],[2],[2,2]]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, track</span>):</span>  </span><br><span class="line">            <span class="keyword">if</span> track <span class="keyword">not</span> <span class="keyword">in</span> res:  <span class="comment"># 不重复才放入</span></span><br><span class="line">                res.append(track[:])  <span class="comment"># 存储当前路径</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res = []  <span class="comment"># 所有路径(track)</span></span><br><span class="line">        track = []  <span class="comment"># 当前路径  </span></span><br><span class="line">        nums.sort() <span class="comment"># 必须排序好</span></span><br><span class="line">        backtrack(<span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="077-组合"><a href="#077-组合" class="headerlink" title="077. 组合"></a>077. 组合</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb25zLw==">https://leetcode-cn.com/problems/combinations/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。你可以按 任何顺序 返回答案。<br>示例 1：<br>输入：<code>n = 4, k = 2</code><br>输出：<code>[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track)==k:  <span class="comment"># 注意满足k才存储</span></span><br><span class="line">                res.append(track[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        backtrack(<span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="039-组合总和"><a href="#039-组合总和" class="headerlink" title="039. 组合总和"></a>039. 组合总和</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3VtLw==">https://leetcode-cn.com/problems/combination-sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<code>candidates</code> 中的 同一个 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>示例 1：<br>输入：<code>candidates = [2,3,6,7], target = 7</code><br>输出：<code>[[2,2,3],[7]]</code><br>解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, target, track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:   <span class="comment"># target减为0结束</span></span><br><span class="line">                res.append(track[:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                <span class="comment"># 去掉非法选择</span></span><br><span class="line">                <span class="keyword">if</span> candidates[i] &gt; target: <span class="keyword">break</span>  </span><br><span class="line">                track.append(candidates[i])</span><br><span class="line">                <span class="comment"># 可重复选取，candidates从 i 开始</span></span><br><span class="line">                backtrack(i, target-candidates[i], track)</span><br><span class="line">                track.pop()</span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        n = <span class="built_in">len</span>(candidates)</span><br><span class="line">        candidates.sort()  <span class="comment"># 排序</span></span><br><span class="line">        backtrack(<span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="040-组合总和-II"><a href="#040-组合总和-II" class="headerlink" title="040. 组合总和 II"></a>040. 组合总和 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3VtLWlpLw==">https://leetcode-cn.com/problems/combination-sum-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。注意：解集不能包含重复的组合。<br>示例 1:<br>输入: <code>candidates = [10,1,2,7,6,1,5], target = 8</code><br>输出: <code>[[1,1,6],[1,2,5],[1,7],[2,6]]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, target, track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:   <span class="comment"># target减为0结束</span></span><br><span class="line">                res.append(track[:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                <span class="comment"># 去掉非法选择</span></span><br><span class="line">                <span class="keyword">if</span> candidates[i] &gt; target: <span class="keyword">break</span>  </span><br><span class="line">                <span class="comment"># 前面已经按顺序生成了，i&gt;start时遇到和前面相同元素要剪掉</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;start <span class="keyword">and</span> candidates[i]==candidates[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                track.append(candidates[i])</span><br><span class="line">                <span class="comment"># 不可重复选取，candidates从 i+1 开始</span></span><br><span class="line">                backtrack(i+<span class="number">1</span>, target-candidates[i], track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        n = <span class="built_in">len</span>(candidates)</span><br><span class="line">        candidates.sort()  <span class="comment"># 排序</span></span><br><span class="line">        backtrack(<span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="022-括号生成"><a href="#022-括号生成" class="headerlink" title="022. 括号生成"></a>022. 括号生成</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ2VuZXJhdGUtcGFyZW50aGVzZXMv">https://leetcode-cn.com/problems/generate-parentheses/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。<br>示例 1：<br>输入：<code>n = 3</code><br>输出：<code>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        考虑 2n 个括号(n个左,n个右)，合法的有多少？</span></span><br><span class="line"><span class="string">        合法就是保证：</span></span><br><span class="line"><span class="string">        (1) 左括号数量&lt;=n。</span></span><br><span class="line"><span class="string">        (2) 右括号数量&lt;=左括号数量。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">left, right, track</span>):</span></span><br><span class="line">            <span class="comment"># 恰好用完，存储+结束</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track)==<span class="number">2</span>*n:</span><br><span class="line">                res.append(<span class="string">&#x27;&#x27;</span>.join(track))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:</span><br><span class="line">                <span class="comment"># 尝试添加一个左括号</span></span><br><span class="line">                track.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                backtrack(left+<span class="number">1</span>, right, track)</span><br><span class="line">                track.pop()</span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                <span class="comment"># 尝试添加一个右括号</span></span><br><span class="line">                track.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                backtrack(left, right+<span class="number">1</span>, track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        track = []</span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="051-N-皇后"><a href="#051-N-皇后" class="headerlink" title="051. N 皇后"></a>051. N 皇后</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbi1xdWVlbnMv">https://leetcode-cn.com/problems/n-queens/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。<br>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例 1：<br>输入：<code>n = 4</code><br>输出：<code>[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</code><br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<p>示例 2：<br>输入：<code>n = 1</code><br>输出：<code>[[&quot;Q&quot;]]</code></p>
<div class="tabs" id="51"><ul class="nav-tabs"><li class="tab active"><a href="#51-1">模板1</a></li><li class="tab"><a href="#51-2">模板2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="51-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 皇后可以攻击同一行、同一列、左上、左下、右上、右下任意单位。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        路径：棋盘中小于row的行已成功放置皇后</span></span><br><span class="line"><span class="string">        选择列表：第row行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="string">        结束条件：row超过棋盘的最后一行，棋盘放满了</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">board, row</span>):</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="built_in">len</span>(board):</span><br><span class="line">                board = [<span class="string">&#x27;&#x27;</span>.join(i) <span class="keyword">for</span> i <span class="keyword">in</span> board]</span><br><span class="line">                res.append(copy.deepcopy(board))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            n = <span class="built_in">len</span>(board[row]) <span class="comment"># n列</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 排除非法选择</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isValid(board, row, col): <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                backtrack(board, row+<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 取消选择</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">board, row, col</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            放置皇后是从上到下，就不需要判断左下、右下的合法性了</span></span><br><span class="line"><span class="string">            只需判断正上、左上、右上合法性</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            n = <span class="built_in">len</span>(board) <span class="comment"># n行/n列</span></span><br><span class="line">            <span class="comment"># 检查列是否冲突</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][col] == <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查右上方是否冲突</span></span><br><span class="line">            i = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br><span class="line">            j = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col+<span class="number">1</span>, n, <span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(i,j):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左上方是否冲突</span></span><br><span class="line">            i = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br><span class="line">            j = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(i,j):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 字符串不可变，使用 列表/字符串切片拼接 方法</span></span><br><span class="line">        <span class="comment"># 双层列表拷贝要用copy.deepcopy(board)</span></span><br><span class="line">        board = [ [<span class="string">&#x27;.&#x27;</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        backtrack(board, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="51-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">记录主对角线、副对角线、列(皇后放置位置)：</span></span><br><span class="line"><span class="string">    主对角线(左上右下)：行下标与列下标之差相等 row-col == 常数</span></span><br><span class="line"><span class="string">    副对角线(右上左下)：行下标与列下标之和相等 row+col == 常数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generateBoard</span>():</span></span><br><span class="line">            board = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                row = [<span class="string">&quot;.&quot;</span>] * n</span><br><span class="line">                row[queens[i]] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                board.append(<span class="string">&quot;&quot;</span>.join(row))</span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">row: <span class="built_in">int</span></span>):</span></span><br><span class="line">            <span class="keyword">if</span> row == n:  <span class="comment"># 棋盘行全判断完结束</span></span><br><span class="line">                board = generateBoard()</span><br><span class="line">                solutions.append(board)</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 排除非法选择</span></span><br><span class="line">                <span class="keyword">if</span> col <span class="keyword">in</span> columns <span class="keyword">or</span> row-col <span class="keyword">in</span> diagonal1 <span class="keyword">or</span> row+col <span class="keyword">in</span> diagonal2:  <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                queens[row] = col</span><br><span class="line">                columns.add(col)</span><br><span class="line">                diagonal1.add(row - col)</span><br><span class="line">                diagonal2.add(row + col)</span><br><span class="line">                <span class="comment"># 进入下一层</span></span><br><span class="line">                backtrack(row + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                columns.remove(col)</span><br><span class="line">                diagonal1.remove(row - col)</span><br><span class="line">                diagonal2.remove(row + col)</span><br><span class="line">                    </span><br><span class="line">        solutions = <span class="built_in">list</span>()</span><br><span class="line">        queens = [<span class="number">-1</span>] * n  <span class="comment"># 皇后放置在每行(下标)的列数(值)</span></span><br><span class="line">        columns = <span class="built_in">set</span>()    <span class="comment"># 皇后所在列位置</span></span><br><span class="line">        diagonal1 = <span class="built_in">set</span>()  <span class="comment"># 主对角线(左上右下)：row - col</span></span><br><span class="line">        diagonal2 = <span class="built_in">set</span>()  <span class="comment"># 副对角线(右上左下)：row + col</span></span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> solutions</span><br></pre></td></tr></table></figure></div></div></div>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p><strong>DFS（深度优先搜索）</strong>可以被认为是回溯算法。<br><strong>BFS（广度优先搜索）</strong>核心是<strong>从一个点向其四周扩散</strong>，编写代码时<strong>使用队列每次将一个节点周围所有节点加入队列中</strong>。<br><strong>BFS相对于DFS</strong>：BFS找到的<strong>路径</strong>一定是<strong>最短</strong>的，但是代价是空间复杂度比DFS高。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从起点start到终点target的最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">start:Node, target:Node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> start <span class="keyword">or</span> <span class="keyword">not</span> target: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    q = collections.deque([(start, <span class="number">1</span>)])  <span class="comment"># 将起点加入队列，开始长度为1</span></span><br><span class="line">    visited = Set([start])  <span class="comment"># 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node, depth = q.popleft()  <span class="comment"># 队尾弹出节点</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> target: <span class="keyword">return</span> depth   <span class="comment"># 判断是否到达终点</span></span><br><span class="line">        <span class="comment"># 将node的相邻节点加入队列：</span></span><br><span class="line">        <span class="comment"># 1.树结构</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">and</span> node.left <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((node.left, depth+<span class="number">1</span>))  <span class="comment"># 队头加入</span></span><br><span class="line">                visited.add(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">and</span> node.right <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((node.right, depth+<span class="number">1</span>))  <span class="comment"># 队头加入</span></span><br><span class="line">                visited.add(node.right)</span><br><span class="line">        <span class="comment"># 2.复杂问题</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> 相邻节点:</span><br><span class="line">            <span class="keyword">if</span> node 合法:</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">is</span> target: <span class="keyword">return</span> depth   <span class="comment"># 判断是否到达终点</span></span><br><span class="line">                q.append((node, depth+<span class="number">1</span>))</span><br><span class="line">                visited.add(node)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉树，找出其最小深度。最小深度是从<strong>根节点</strong>到<strong>最近叶子节点</strong>的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。<br>示例 1：<br>输入：<code>root = [3,9,20,null,null,15,7]</code><br>输出：<code>2</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 队列(右进左出)，根节点从 1 开始</span></span><br><span class="line">        q = collections.deque([(root, <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node, depth = q.popleft()</span><br><span class="line">            <span class="comment"># 到达叶子节点(左右节点为空)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right: <span class="keyword">return</span> depth</span><br><span class="line">            <span class="keyword">if</span> node.left: q.append((node.left, depth+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right: q.append((node.right, depth+<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a>752. 打开转盘锁</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvb3Blbi10aGUtbG9jay8=">https://leetcode-cn.com/problems/open-the-lock/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：你有一个带有<strong>四个圆形拨轮</strong>的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的<strong>最小旋转次数</strong>，如果无论如何不能解锁，返回 <code>-1</code> 。</p>
<p>示例 1:</p>
<p>输入：<code>deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</code><br>输出：<code>6</code><br>解释：<br>可能的移动序列为 “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”。<br>注意 “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” 这样的序列是不能解锁的，<br>因为当拨动到 “0102” 时这个锁就会被锁定。</p>
<p>示例 2:<br>输入: <code>deadends = [&quot;8888&quot;], target = &quot;0009&quot;</code><br>输出：<code>1</code><br>解释：把最后一位反向旋转一次即可 “0000” -&gt; “0009”。</p>
<p>示例 3:<br>输入: <code>deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;</code><br>输出：<code>-1</code><br>解释：无法旋转到目标数字且不被锁定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openLock</span>(<span class="params">self, deadends: List[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="string">&quot;0000&quot;</span>: <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 起始为目标，返回0</span></span><br><span class="line"></span><br><span class="line">        dead = <span class="built_in">set</span>(deadends)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;0000&quot;</span> <span class="keyword">in</span> dead: <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 起始在死亡状态，返回-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">num_prev</span>(<span class="params">x: <span class="built_in">str</span></span>) -&gt; str:</span>  <span class="comment"># 前拨</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> <span class="keyword">if</span> x == <span class="string">&quot;0&quot;</span> <span class="keyword">else</span> <span class="built_in">str</span>(<span class="built_in">int</span>(x) - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">num_succ</span>(<span class="params">x: <span class="built_in">str</span></span>) -&gt; str:</span>  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span> <span class="keyword">if</span> x == <span class="string">&quot;9&quot;</span> <span class="keyword">else</span> <span class="built_in">str</span>(<span class="built_in">int</span>(x) + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举 当前节点 一次旋转得到的数字(每个节点有8个相邻节点)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">status: <span class="built_in">str</span></span>) -&gt; Generator[str, <span class="keyword">None</span>, <span class="keyword">None</span>]:</span></span><br><span class="line">            s = <span class="built_in">list</span>(status)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                num = s[i]</span><br><span class="line">                <span class="comment"># 前拨</span></span><br><span class="line">                s[i] = num_prev(num)</span><br><span class="line">                <span class="keyword">yield</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line">                <span class="comment"># 后拨</span></span><br><span class="line">                s[i] = num_succ(num)</span><br><span class="line">                <span class="keyword">yield</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line">                s[i] = num</span><br><span class="line"></span><br><span class="line">        q = deque([(<span class="string">&quot;0000&quot;</span>, <span class="number">0</span>)])  <span class="comment"># 记录(当前状态, 路径长度)</span></span><br><span class="line">        seen = &#123;<span class="string">&quot;0000&quot;</span>&#125;  <span class="comment"># 记录走过的状态</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            status, step = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> next_status <span class="keyword">in</span> get(status):</span><br><span class="line">                <span class="keyword">if</span> next_status <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> next_status <span class="keyword">not</span> <span class="keyword">in</span> dead:</span><br><span class="line">                    <span class="keyword">if</span> next_status == target: <span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">                    q.append((next_status, step+<span class="number">1</span>))</span><br><span class="line">                    seen.add(next_status)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    
      


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>SoundMemories
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://soundmemories.github.io/2022/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/" title="算法题">https://soundmemories.github.io/2022/01/31/Other/算法题合集/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Other/" rel="tag"><i class="fa fa-tag"></i> Other</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/23/NLP/08.%E8%92%B8%E9%A6%8F/" rel="prev" title="蒸馏">
                  <i class="fa fa-chevron-left"></i> 蒸馏
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SoundMemories</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>








<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  








    <div class="pjax">
  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://soundmemories.github.io/2022/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/',]
      });
      });
  </script>

    </div>
</body>
</html>
