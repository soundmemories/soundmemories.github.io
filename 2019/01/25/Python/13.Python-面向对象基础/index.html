<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"soundmemories.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":true,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="语言的分类  面向机器：抽象成机器指令，机器容易理解，如：汇编语言。 面向过程：做一件事情，排出个步骤，第一步干什么，第二步干什么，如果出现情况，做什么处理。适合问题规模小，可以步骤化，如：C语言。 面向对象OOP：随着计算机需要解决问题的规模扩大，情况越来越复杂，需要很多人、很多部门协作，面向过程编程不适合了，需要面向对象方式。如：C++、Java、Python等。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python-面向对象-基础">
<meta property="og:url" content="https://soundmemories.github.io/2019/01/25/Python/13.Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="SoundMemories">
<meta property="og:description" content="语言的分类  面向机器：抽象成机器指令，机器容易理解，如：汇编语言。 面向过程：做一件事情，排出个步骤，第一步干什么，第二步干什么，如果出现情况，做什么处理。适合问题规模小，可以步骤化，如：C语言。 面向对象OOP：随着计算机需要解决问题的规模扩大，情况越来越复杂，需要很多人、很多部门协作，面向过程编程不适合了，需要面向对象方式。如：C++、Java、Python等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190219211051673.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNDAyMTY=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190219212129377.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNDAyMTY=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019021921305487.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNDAyMTY=,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2019-01-24T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-26T08:26:00.376Z">
<meta property="article:author" content="SoundMemories">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190219211051673.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNDAyMTY=,size_16,color_FFFFFF,t_70">


<link rel="canonical" href="https://soundmemories.github.io/2019/01/25/Python/13.Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python-面向对象-基础 | SoundMemories</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SoundMemories</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
	   
		  
      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text"> 语言的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text"> 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13%E8%A6%81%E7%B4%A0"><span class="nav-number">3.</span> <span class="nav-text"> 面向对象3要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#python%E7%9A%84%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text"> Python的类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text"> 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">4.2.</span> <span class="nav-text"> 实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96__init__%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text"> 初始化（__init__方法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1instance"><span class="nav-number">4.4.</span> <span class="nav-text"> 实例对象instance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="nav-number">4.5.</span> <span class="nav-text"> 实例变量和类变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="nav-number">4.6.</span> <span class="nav-text"> 装饰一个类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">4.7.</span> <span class="nav-text"> 类方法和静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">4.8.</span> <span class="nav-text"> 访问控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E4%B8%81"><span class="nav-number">4.9.</span> <span class="nav-text"> 补丁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="nav-number">4.10.</span> <span class="nav-text"> 属性装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="nav-number">4.11.</span> <span class="nav-text"> 对象的“销毁”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload"><span class="nav-number">4.12.</span> <span class="nav-text"> 方法重载（Overload）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96override"><span class="nav-number">4.13.</span> <span class="nav-text"> 方法的覆盖（Override）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">4.14.</span> <span class="nav-text"> 类的封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8D%95%E7%BB%A7%E6%89%BF"><span class="nav-number">4.15.</span> <span class="nav-text"> 类的单继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">4.16.</span> <span class="nav-text"> 类的多继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20%E5%92%8C30%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.17.</span> <span class="nav-text"> 2.0和3.0继承的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mixin%E9%87%8D%E7%82%B9"><span class="nav-number">4.18.</span> <span class="nav-text"> Mixin（重点）</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SoundMemories"
      src="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
  <p class="site-author-name" itemprop="name">SoundMemories</p>
  <div class="site-description" itemprop="description">今日事，今日毕</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvdW5kbWVtb3JpZXM=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soundmemories"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNvdW5kbWVtb3JpZXNAMTYzLmNvbQ==" title="E-Mail → mailto:soundmemories@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2019/01/25/Python/13.Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python-面向对象-基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-25T00:00:00+08:00">2019-01-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>28k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="语言的分类"><a class="markdownIt-Anchor" href="#语言的分类"></a> 语言的分类</h3>
<ol>
<li>面向机器：抽象成机器指令，机器容易理解，如：汇编语言。</li>
<li>面向过程：做一件事情，排出个步骤，第一步干什么，第二步干什么，如果出现情况，做什么处理。适合问题规模小，可以步骤化，如：C语言。</li>
<li>面向对象OOP：随着计算机需要解决问题的规模扩大，情况越来越复杂，需要很多人、很多部门协作，面向过程编程不适合了，需要面向对象方式。如：C++、Java、Python等。</li>
</ol>
<a id="more"></a>
<h3 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h3>
<p>什么是面向对象呢？<br />
一种认识世界、分析世界的方法论、将万事万物抽象称为各种对象。</p>
<p>类class？<br />
类是抽象的概念，是万事万物的抽象，是一类事物的共同特征的集合。<br />
用计算机语言来描述类，就是<code>属性</code>和<code>方法</code>的集合。<br />
<code>属性</code>：它是对象状态的抽象，用数据结构来描述。<br />
<code>操作</code>：它是对象行为的抽象，用操作名和实现该操作的方法来描述。</p>
<p>对象instance、object？<br />
对象是类的具象，是以个实体（一般类产生的对象说成instance。object可能不知道是类产生的）。<br />
对于我们每个人这个个体，都是抽象概念人类的不同的实体。</p>
<p>举例：你吃鱼。<br />
你，就是对象；鱼，也是对象；吃，就是动作。<br />
你是具体的人，是具体的对象。你属于人类，人类是个抽象的概念，是无数具体的人的个体的抽象。<br />
鱼也是具体的对象，就是你吃的这一条具体的鱼。这条鱼属于鱼类，鱼类是无数鱼抽象出来的概念。<br />
吃是动作，也是操作，也是方法，这个吃是你的动作，也就是人类具有的方法。如果反过来，鱼吃人，吃就是鱼类的动作了。<br />
吃这个动作，很多动物都具有的动作，人类和鱼类都属于动物类，而动物类是抽象的概念，是动物类都有吃的动作，但吃的方法不同而已。</p>
<p>每个人都是人类的一个单独的实例，都有自己的名字、身高、体重等信息，这些信息是个人的属性，但是这些信息不能保存在人类中，因为它是抽象的概念，不能保留具体的值。<br />
而人类的实例，是具体的人，他可以存储这些具体的属性，而且可以不同人有不同的属性。</p>
<p>哲学思想：<br />
一切皆对象；<br />
对象是数据和操作的封装；<br />
对象是独立的，但是对象之间可以相互作用；<br />
目前OOP是最接近人类认知的编程范式；</p>
<h3 id="面向对象3要素"><a class="markdownIt-Anchor" href="#面向对象3要素"></a> 面向对象3要素</h3>
<ol>
<li>
<p>封装Encapsulation</p>
<ul>
<li>组装：将数据和操作组装到一起。</li>
<li>隐藏数据：对外只暴露一些接口，通过接口访问对象。如：驾驶员使用汽车，不需要了解汽车的构造细节，只需要知道使用什么部件怎么驾驶就行，只要会用方向盘、油门、刹车、档位就可以驾驶汽车，可以不了解其中的机动原理。</li>
</ul>
</li>
<li>
<p>继承Inheritance</p>
<ul>
<li>多复用，继承来的就不用自己写了</li>
<li>多继承少修改，OCP开放封闭原则（Open-closed Principle，一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的），使用继承来改变，来体现个性</li>
</ul>
</li>
<li>
<p>多态Polymorphism</p>
<ul>
<li>面向对象编程最灵活的地方，动态绑定</li>
</ul>
</li>
</ol>
<p>人类就是封装；<br />
人类继承自动物类，孩子继承父母特征。分为单一继承、多继承；<br />
多态，自动物类的人类、猫类都有<code>吃</code>操作，但<code>吃</code>操作不同；</p>
<h3 id="python的类"><a class="markdownIt-Anchor" href="#python的类"></a> Python的类</h3>
<h4 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    语句块</span><br></pre></td></tr></table></figure>
<ol>
<li>必须使用class关键字。</li>
<li>类名必须使用<code>大驼峰</code>（首字母大写）命名。</li>
<li>类定义完成，解释器执行完后，就产生了一个<code>类对象</code>（类是特殊对象），绑定到了标识符ClassName上。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;MyClass doc&quot;&quot;&quot;</span></span><br><span class="line">    x = <span class="number">100</span> <span class="comment"># 类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span> <span class="comment"># 类属性foo，也是方法</span></span><br><span class="line">        print(<span class="string">&#x27;My Class&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(MyClass.x)</span><br><span class="line">print(MyClass.foo)</span><br><span class="line">print(MyClass.__doc__) </span><br></pre></td></tr></table></figure>
<ul>
<li>类对象：类的定义执行后会生成一个类对象</li>
<li>类的属性：类定义中的变量和类中定义的方法都是类的属性</li>
<li>类变量：上例中x是类MyClass的变量</li>
</ul>
<p>MyClass中，x、foo都是类的属性，__doc__也是类的特殊属性；<br />
foo是类的属性，也是方法（method），本质上就是普通的函数对象function，它一般要求至少有一个参数。第一个形式参数可以是self（self只是个惯用标识符，可以换名字），这个参数位置就留给了self。</p>
<h4 id="实例化"><a class="markdownIt-Anchor" href="#实例化"></a> 实例化</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = MyClass() <span class="comment"># 实例化（其实是调用__new__）</span></span><br><span class="line">b = MyClass() <span class="comment"># 每一次调用生成不同的实例</span></span><br></pre></td></tr></table></figure>
<p>使用上面的语法，在类对象名称后面加上一个括号，就调用类的实例化方法，完成实例化。实例化就是真正创建一个该类的具体对象（实例），<code>self指代当前实例本身</code>。</p>
<p>每次实例化后获得的实例，是不同的实例，即使是使用同样的参数实例化，也得到不一样的对象。<br />
Python类实例化后，会自动调用<code>__init__</code>方法。这个方法第一个形式参数必须留给self，其他参数随意。</p>
<p>类内部如何实例化为self的，请看进阶讲解创建（<code>__new__</code>）。</p>
<hr />
<h4 id="初始化__init__方法"><a class="markdownIt-Anchor" href="#初始化__init__方法"></a> 初始化（__init__方法）</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在实例化后会执行初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span> <span class="comment"># 对实例的初始化</span></span><br><span class="line">        self.name = name <span class="comment"># self指代当前实例，为这个实例增加了一个属性name</span></span><br><span class="line"></span><br><span class="line">print(Person(<span class="string">&#x27;tom&#x27;</span>))  <span class="comment"># 实例化会调用__init__</span></span><br><span class="line">print(Person) <span class="comment"># 没实例化，不会调用__init__</span></span><br></pre></td></tr></table></figure>
<p>初始化函数可以多个参数，请注意第一个位置必须是self，例如 <code>__init__(self, name, age)</code>。<br />
self是指实例本身（self是通过__new__得到的），所以是对实例的初始化。<br />
<code>__init__</code>不能有返回值！只能是<code>return None</code>。<br />
<code>__init__</code>不定义，会在实例化后隐式调用默认的。</p>
<h4 id="实例对象instance"><a class="markdownIt-Anchor" href="#实例对象instance"></a> 实例对象instance</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showage</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name,self.age))</span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">20</span>) <span class="comment"># 实例化，会调用__init__方法并为实例进行属性的初始化</span></span><br><span class="line">jerry = Person(<span class="string">&#x27;je&#x27;</span>,<span class="number">25</span>)</span><br><span class="line">print(tom.name,tom.age,jerry.name,jerry.age) <span class="comment"># Tom 20 je 25</span></span><br><span class="line"></span><br><span class="line">jerry.age += <span class="number">1</span></span><br><span class="line">print(jerry.age) <span class="comment"># 26</span></span><br><span class="line">jerry.showage() <span class="comment"># je is 26</span></span><br></pre></td></tr></table></figure>
<p>类实例化后一定获得一个类的实例，就是实例对象。<br />
上例中的tom、jerry就是Person类的实例。</p>
<p><code>__init__</code>方法的第一参数<code>self</code>就是指代某一个实例自身。</p>
<p>类实例化后，得到一个实例对象，调用方法时采用jerry.showage()的方式，实例对象会<code>绑定</code>到方法上。<br />
但是该函数签名是showage(self)，少传一个参数self吗？<br />
这个self就是jerry，jerry.showage()调用时，会把方法的调用者jerry实例作为第一参数self的实参传入。<br />
self.name就是jerry对象的name，name是保存在了jerry对象上，而不是Person类上，所以这里的name称为实例变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="number">1</span>,<span class="string">&#x27;id(self) = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(self)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showself</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="number">2</span>, <span class="string">&#x27;id(self) = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(self)))</span><br><span class="line"></span><br><span class="line">c = MyClass() <span class="comment"># 会调用__init__</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">3</span>, <span class="string">&#x27;id(c) = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>(c)))</span><br><span class="line">c.showself()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 id(self) = 2202141816032</span></span><br><span class="line"><span class="comment"># 3 id(c) = 2202141816032</span></span><br><span class="line"><span class="comment"># 2 id(self) = 2202141816032</span></span><br></pre></td></tr></table></figure>
<p>上例说明，self就是实例本身，就是c对应的实例对象。<br />
self这个名字只是一个惯例，它可以修改，但是不建议修改，否则影响代码的可读性。</p>
<h4 id="实例变量和类变量"><a class="markdownIt-Anchor" href="#实例变量和类变量"></a> 实例变量和类变量</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    age = <span class="number">200</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">p2 = Person(<span class="string">&#x27;jerry&#x27;</span>)</span><br><span class="line">print(Person.age,p1.age,p2.age) <span class="comment"># 200 200 200</span></span><br><span class="line">print(p1.__dict__)<span class="comment"># &#123;&#x27;name&#x27;: &#x27;tom&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">Person.age = <span class="number">20</span></span><br><span class="line">print(Person.age,p1.age,p2.age) <span class="comment"># 20 20 20</span></span><br><span class="line">print(p1.__dict__) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;tom&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">p1.age = <span class="number">30</span> <span class="comment"># 原先p1实例本身没有age这个属性（使用的是类的age），赋值定义p1才有自己的age属性</span></span><br><span class="line">print(Person.age,p1.age,p2.age) <span class="comment"># 20 30 20</span></span><br><span class="line">print(p1.__dict__) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;age&#x27;: 30&#125;</span></span><br></pre></td></tr></table></figure>
<p>实例变量是每一个实例自己的变量，是自己独有的；<br />
类变量是类的变量，是类的所有实例共享的属性和方法；</p>
<p>特殊属性：<br />
（1）<code>__name__</code>：对象名；<br />
（2）<code>__class__</code>：对象的类型；<br />
（3）<code>__dict__</code>：对象的属性的字典；<br />
（4）<code>__qualname__</code>：类的限定名；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    age = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">print(<span class="number">1</span>, Person.__name__)</span><br><span class="line">print(<span class="number">2</span>, p1.__class__ <span class="keyword">is</span> <span class="built_in">type</span>(p1), p1.__class__ <span class="keyword">is</span> Person) <span class="comment"># p1.__class__ == type(p1) == Person</span></span><br><span class="line">print(<span class="number">3</span>, <span class="built_in">type</span>(p1) <span class="keyword">is</span> <span class="built_in">type</span>(Person)) <span class="comment"># type(&#x27;abc&#x27;) type(str)</span></span><br><span class="line">print(<span class="number">4</span>, <span class="built_in">type</span>(p1), <span class="built_in">type</span>(Person))</span><br><span class="line">print(<span class="number">5</span>, <span class="built_in">type</span>(<span class="built_in">str</span>), <span class="built_in">type</span>(Person), <span class="built_in">type</span>(<span class="built_in">int</span>) <span class="keyword">is</span> <span class="built_in">type</span>(<span class="built_in">type</span>))</span><br><span class="line">print(<span class="number">6</span>, <span class="built_in">str</span>.__class__.__name__, p1.__class__.__class__.__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 Person</span></span><br><span class="line"><span class="comment"># 2 True True</span></span><br><span class="line"><span class="comment"># 3 False</span></span><br><span class="line"><span class="comment"># 4 &lt;class &#x27;__main__.Person&#x27;&gt; &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 5 &lt;class &#x27;type&#x27;&gt; &lt;class &#x27;type&#x27;&gt; True</span></span><br><span class="line"><span class="comment"># 6 type type</span></span><br></pre></td></tr></table></figure>
<p>上例说明，<code>__name__</code>就是对象名，<code>__class__</code>就是对象类型，这里有个等价关系<code>p1.__class__ == type(p1) == Person</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    age = <span class="number">3</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;----class----&#x27;</span>)</span><br><span class="line">print(Person.__class__)</span><br><span class="line">print(<span class="built_in">sorted</span>(Person.__dict__.items()), end=<span class="string">&#x27;\n\n&#x27;</span>) <span class="comment"># 属性字典</span></span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;----instance tom----&#x27;</span>)</span><br><span class="line">print(tom.__class__)</span><br><span class="line">print(<span class="built_in">sorted</span>(tom.__dict__.items()), end=<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;----tom&#x27;s class----&quot;</span>)</span><br><span class="line">print(tom.__class__.__name__) <span class="comment"># tom.__class__.__name__ == Person.__name__</span></span><br><span class="line">print(<span class="built_in">sorted</span>(tom.__class__.__dict__.items()), end=<span class="string">&#x27;\n\n&#x27;</span>) <span class="comment"># tom.__class__.__dict__.items() == Person.__dict__.items()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----class----</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="comment"># [(&#x27;__dict__&#x27;, &lt;attribute &#x27;__dict__&#x27; of &#x27;Person&#x27; objects&gt;), (&#x27;__doc__&#x27;, None), (&#x27;__init__&#x27;, &lt;function Person.__init__ at 0x00000247C6E49B70&gt;), (&#x27;__module__&#x27;, &#x27;__main__&#x27;), (&#x27;__weakref__&#x27;, &lt;attribute &#x27;__weakref__&#x27; of &#x27;Person&#x27; objects&gt;), (&#x27;age&#x27;, 3)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----instance tom----</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.Person&#x27;&gt;</span></span><br><span class="line"><span class="comment"># [(&#x27;name&#x27;, &#x27;Tom&#x27;)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----tom&#x27;s class----</span></span><br><span class="line"><span class="comment"># Person</span></span><br><span class="line"><span class="comment"># [(&#x27;__dict__&#x27;, &lt;attribute &#x27;__dict__&#x27; of &#x27;Person&#x27; objects&gt;), (&#x27;__doc__&#x27;, None), (&#x27;__init__&#x27;, &lt;function Person.__init__ at 0x00000247C6E49B70&gt;), (&#x27;__module__&#x27;, &#x27;__main__&#x27;), (&#x27;__weakref__&#x27;, &lt;attribute &#x27;__weakref__&#x27; of &#x27;Person&#x27; objects&gt;), (&#x27;age&#x27;, 3)]</span></span><br></pre></td></tr></table></figure>
<p>上例中，可以看到类属性保存在类的<code>__dict__</code>中，实例属性保存在实例的<code>__dict__</code>中，如果从实例访问类的属性，也可以借助<code>__class__</code>找到所属的类，再通过类来访问类属性，例如<code>tom.__class__.age</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    age = <span class="number">3</span></span><br><span class="line">    height = <span class="number">170</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>) <span class="comment"># 实例化、初始化</span></span><br><span class="line">jerry = Person(<span class="string">&#x27;Jerry&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">Person.age = <span class="number">30</span></span><br><span class="line">print(<span class="number">1</span>, Person.age, tom.age, jerry.age) <span class="comment"># 输出什么结果</span></span><br><span class="line">print(<span class="number">2</span>, Person.height, tom.height, jerry.height) <span class="comment"># 输出什么结果</span></span><br><span class="line"></span><br><span class="line">jerry.height = <span class="number">175</span></span><br><span class="line">print(<span class="number">3</span>, Person.height, tom.height, jerry.height) <span class="comment"># 输出什么结果</span></span><br><span class="line"></span><br><span class="line">tom.height += <span class="number">10</span> <span class="comment"># tom实例增加自己的height属性</span></span><br><span class="line">print(<span class="number">4</span>, Person.height, tom.height, jerry.height) <span class="comment"># 输出什么结果</span></span><br><span class="line"></span><br><span class="line">Person.height += <span class="number">15</span></span><br><span class="line">print(<span class="number">5</span>, Person.height, tom.height, jerry.height) <span class="comment"># 输出什么结果</span></span><br><span class="line"></span><br><span class="line">Person.weight = <span class="number">70</span> <span class="comment"># 类增加weight属性</span></span><br><span class="line">print(<span class="number">6</span>, Person.weight, tom.weight, jerry.weight) <span class="comment"># 输出什么结果</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">7</span>, tom.__dict__[<span class="string">&#x27;height&#x27;</span>]) <span class="comment"># 可以吗</span></span><br><span class="line"><span class="comment">#print(8, tom.__dict__[&#x27;weight&#x27;]) # 可以吗，不可以tom没有weight属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 30 18 20</span></span><br><span class="line"><span class="comment"># 2 170 170 170</span></span><br><span class="line"><span class="comment"># 3 170 170 175</span></span><br><span class="line"><span class="comment"># 4 170 180 175</span></span><br><span class="line"><span class="comment"># 5 185 180 175</span></span><br><span class="line"><span class="comment"># 6 70 70 70</span></span><br><span class="line"><span class="comment"># 7 180</span></span><br></pre></td></tr></table></figure>
<p>上例中，最后注释掉的print执行会报错，原因是tom实例中并没weight属性，所以tom对应的<code>__dict__</code>也没有weight（<code>__dict__</code>只访问实例的属性）。通过<code>tom.weight</code>可以访问实例/类的属性（实例没有就访问类）。</p>
<p>总结：<br />
是类的，也是这个类所有实例的，其实例都可以访问到；<br />
是实例的，就是这个实例自己的，通过类访问不到；<br />
类变量是属于类的变量，这个类的所有实例可以<code>共享</code>这个变量；</p>
<p>对象（实例或类）可以动态的给自己增加一个属性（赋值即定义一个新属性）。<br />
<code>实例.__dict__[变量名]</code>和<code>实例.变量名</code>都可以访问到实例自己的属性。<br />
实例的同名变量会隐藏掉类变量，或者说是覆盖了这个类变量。但是注意类变量还在那里，并没有真正被覆盖。</p>
<p>实例属性的查找顺序:<br />
指的是实例使用 <code>.</code> 点号来访问属性，会先找自己的 <code>__dict__</code>，如果没有，然后通过属性<code>__class__</code>找到自己的类，再去类的<code>__dict__</code>中找。</p>
<p>注意，如果实例使用<code>__dict__[变量名]</code>访问变量，将不会按照上面的查找顺序找变量了，这是指明使用字典的key查找，不是属性查找。</p>
<p>一般来说，<code>类变量可使用全大写来命名</code>来区别实例属性和类属性。</p>
<h4 id="装饰一个类"><a class="markdownIt-Anchor" href="#装饰一个类"></a> 装饰一个类</h4>
<p>回顾，什么是高阶函数？什么是装饰器函数？<br />
思考，如何装饰一个类？<br />
需求，为一个<code>类</code>同过装饰，增加一些类属性，例如能否给一个类增加一个<code>NAME类属性</code>并提供属性值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_name</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">cls</span>):</span></span><br><span class="line">        cls.NAME = name</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> wrapper </span><br><span class="line"></span><br><span class="line"><span class="meta">@add_name(&#x27;Tom&#x27;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    AGE = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">print(Person.NAME)</span><br></pre></td></tr></table></figure>
<p>之所以能够装饰，本质上是为类对象动态的添加了一个属性，而Person这个标识符指向这个类对象。</p>
<h4 id="类方法和静态方法"><a class="markdownIt-Anchor" href="#类方法和静态方法"></a> 类方法和静态方法</h4>
<p>前面的例子中定义的<code>__init__</code>等方法，这些方法本身都是类的属性，第一个参数必须是self，而self必须指向一个对象，也就是类实例化后，由实例来调用这个方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#普通函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normal_method</span>():</span> <span class="comment"># 可以吗？</span></span><br><span class="line">        print(<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line"><span class="comment">#如何调用</span></span><br><span class="line">Person.normal_method() <span class="comment"># 可以吗？可以</span></span><br><span class="line">Person().normal_method() <span class="comment"># 可以吗？不可以，相当于多给个参数（实例）</span></span><br><span class="line"></span><br><span class="line">print(Person.normal_method)<span class="comment"># function</span></span><br><span class="line">print(Person().normal_method) <span class="comment"># bound method</span></span><br></pre></td></tr></table></figure>
<p><code>Person.normal_method()</code>可以放在类中定义，因为这个方法只是被Person这个名词空间管理的一个普通的方法，<code>normal_method</code>是Person的一个属性而已。<br />
由于<code>normal_method</code>在定义的时候没有指定self，所以不能完成实例对象的<code>绑定</code>（bound method），不能用<code>Person().normal_method()</code>调用。<br />
注意：虽然语法是对的，但是，没有人这么用，也就是说禁止这么写！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span>(<span class="params">cls</span>):</span> <span class="comment"># cls是什么</span></span><br><span class="line">        print(<span class="string">&#x27;class = &#123;0.__name__&#125; (&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(cls))</span><br><span class="line">        cls.HEIGHT = <span class="number">170</span></span><br><span class="line"></span><br><span class="line">Person.class_method()</span><br><span class="line"><span class="comment">#class = Person (&lt;class &#x27;__main__.Person&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>
<p>注入的是类，可以通过类或者实例访问，<code>@classmethod</code>会找出实例的类传给cls。</p>
<ul>
<li>在类定义中，使用<code>@classmethod</code>装饰器修饰的方法</li>
<li>必须至少有一个参数，且第一个参数留给了cls，cls指代调用者即类对象自身</li>
<li>cls这个标识符可以是任意合法名称，但是为了易读，请不要修改（和self不修改一样）</li>
<li>通过cls可以直接操作类的属性（无法通过cls操作类的实例）</li>
</ul>
<p>类方法，类似于C++、Java中的静态方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span>(<span class="params">cls</span>):</span> <span class="comment"># cls是什么</span></span><br><span class="line">        print(<span class="string">&#x27;class = &#123;0.__name__&#125;， &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(cls))</span><br><span class="line">        cls.HEIGHT = <span class="number">170</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_methd</span>():</span></span><br><span class="line">        print(Person.HEIGHT)</span><br><span class="line"></span><br><span class="line">Person.class_method()</span><br><span class="line">Person.static_methd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># class = Person，&lt;class &#x27;__main__.Person&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 170</span></span><br></pre></td></tr></table></figure>
<p>当普通函数用，可以不注入（无参），但这个函数归类管，可以通过类或实例调用。</p>
<ul>
<li>在类定义中，使用<code>@staticmethod</code>装饰器修饰的方法</li>
<li>调用时，不会隐式的传入参数</li>
<li>静态方法，只是表明这个方法属于这个类。函数归在一起，方便组织管理。</li>
</ul>
<p>方法的调用：<br />
类可以定义这么多种方法，究竟如何调用它们？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normal_method</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;&#123;&#125;&#x27;s method&quot;</span>.<span class="built_in">format</span>(self))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_method</span>(<span class="params">cls</span>):</span> <span class="comment"># cls是什么</span></span><br><span class="line">        print(<span class="string">&#x27;class = &#123;0.__name__&#125; (&#123;0&#125;)&#x27;</span>.<span class="built_in">format</span>(cls))</span><br><span class="line">        cls.HEIGHT = <span class="number">170</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_methd</span>():</span></span><br><span class="line">        print(Person.HEIGHT)</span><br><span class="line"><span class="comment">#类访问</span></span><br><span class="line">print(<span class="number">1</span>, Person.normal_method()) <span class="comment"># 可以吗？可以</span></span><br><span class="line">print(<span class="number">2</span>, Person.method()) <span class="comment"># 可以吗？不可以，缺少实例</span></span><br><span class="line">print(<span class="number">3</span>, Person.class_method()) <span class="comment"># 可以吗？可以 </span></span><br><span class="line">print(<span class="number">4</span>, Person.static_methd()) <span class="comment"># 可以吗？可以，上面执行class_method给Person增加了HEIGHT属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实例访问</span></span><br><span class="line">print(<span class="string">&#x27;tom----&#x27;</span>)</span><br><span class="line">tom = Person()</span><br><span class="line"><span class="comment">#print(1, tom.normal_method()) # 可以吗，不可以，normal_method是无参的，实例传了tom错误</span></span><br><span class="line">print(<span class="number">2</span>, tom.method()) <span class="comment"># 可以吗，可以</span></span><br><span class="line">print(<span class="number">3</span>, tom.class_method()) <span class="comment"># 可以吗？可以</span></span><br><span class="line">print(<span class="number">4</span>, tom.static_methd()) <span class="comment"># 可以吗？可以</span></span><br></pre></td></tr></table></figure>
<p>类几乎可以调用所有内部定义的方法，但是调用<code>普通的方法</code>时会报错，原因是第一参数必须是类的实例。<br />
实例也几乎可以调用所有的方法，<code>普通的函数</code>的调用一般不可能出现，因为不允许这么定义。</p>
<p>总结：<br />
类除了<code>普通方法</code>都可以调用，<code>普通方法</code>需要对象的实例作为第一参数。<br />
实例可以调用所有类中定义的方法（包括<code>类方法</code>、<code>静态方法</code>），<code>普通方法</code>传入实例自身，<code>静态方法</code>和<code>类方法</code>需要找到实例的类。</p>
<h4 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h4>
<ul>
<li>私有属性：<code>使用双下划线开头的属性名，就是私有属性</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">growup</span>(<span class="params">self, i=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="number">150</span>: <span class="comment"># 控制逻辑</span></span><br><span class="line">            self.age += i</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">p1.growup(<span class="number">20</span>) <span class="comment"># 正常的范围</span></span><br><span class="line"></span><br><span class="line">p1.age = <span class="number">160</span> <span class="comment"># 超过了范围，并绕过了控制逻辑，直接给属性赋值了</span></span><br><span class="line">print(p1.age) <span class="comment"># 160</span></span><br></pre></td></tr></table></figure>
<p>上例，本想通过方法控制属性，但是由于属性在外部可以访问（外部可见），就可以直接绕过方法，直接修改这个属性。</p>
<p>Python提供了私有属性可以解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">growup</span>(<span class="params">self, i=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="number">150</span>: <span class="comment"># 控制逻辑</span></span><br><span class="line">            self.__age += i</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">p1.growup(<span class="number">20</span>) <span class="comment"># 正常的范围，可以执行</span></span><br><span class="line">print(p1.__age) <span class="comment"># 可以吗？不可以，私有化了外部不能直接访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AttributeError: &#x27;Person&#x27; object has no attribute &#x27;__age&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上例，外部已经访问不到<code>__age</code>了，age根本就没有定义，更是访问不到。</p>
<p>那么，如何访问这个私有变量<code>__age</code>呢？可以通过<code>方法</code>来访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">growup</span>(<span class="params">self, i=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="number">150</span>: </span><br><span class="line">            self.__age += i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getage</span>(<span class="params">self</span>):</span> <span class="comment"># 定义方法</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">print(Person(<span class="string">&#x27;tom&#x27;</span>).getage()) <span class="comment"># 18</span></span><br></pre></td></tr></table></figure>
<p>上面定义了一个<code>方法</code>，通过这个方法就可以访问到私有变量<code>__age</code>了。</p>
<p>外部访问不到，能够动态增加一个<code>__age</code>吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">growup</span>(<span class="params">self, i=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="number">150</span>:</span><br><span class="line">            self.__age += i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getage</span>(<span class="params">self</span>):</span> <span class="comment"># 定义方法</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">p1.__age = <span class="number">28</span> <span class="comment"># 这里其实是赋值即定义，对p1增加了一个__age属性，与私有变量无关</span></span><br><span class="line"><span class="comment"># 下面2个输出为什么年龄不一样？__age没有被覆盖吗？</span></span><br><span class="line">print(p1.__age)</span><br><span class="line">print(p1.getage())</span><br><span class="line">print(p1.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 28</span></span><br><span class="line"><span class="comment"># 18</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;_Person__age&#x27;: 18, &#x27;__age&#x27;: 28&#125;</span></span><br></pre></td></tr></table></figure>
<p>秘密都在<code>__dict__</code>中，根据结果，对应属性字典，发现<code>_Person__age</code>是18，对应私有变量<code>__age</code>；<code>__age</code>是28，对应的是后来增加的<code>__age</code>属性。</p>
<p>私有变量的本质：<br />
类定义的时候，如果声明一个实例变量的时候，使用双下划线，Python解释器会将其<code>改名</code>，转换名称为<code>_类名__变量名</code>的名称，所以用原来的名字访问不到了。</p>
<p>知道了这个私有化的名字，是否直接修改呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">growup</span>(<span class="params">self, i=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="number">150</span>:</span><br><span class="line">            self.__age += i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getage</span>(<span class="params">self</span>):</span> <span class="comment"># 定义方法</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">p1.__age = <span class="number">28</span></span><br><span class="line">print(p1.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接修改私有变量</span></span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">48</span>)</span><br><span class="line">p1._Person__age = <span class="number">15</span> <span class="comment"># 知道私有化变量名，就可以外部访问私有变量</span></span><br><span class="line">print(p1.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;_Person__age&#x27;: 18, &#x27;__age&#x27;: 28&#125;</span></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;tom&#x27;, &#x27;_Person__age&#x27;: 15, &#x27;__age&#x27;: 28&#125;</span></span><br></pre></td></tr></table></figure>
<p>上例可以看出，知道了私有变量规则生成的新名称，就可以直接从外部访问到，并可以修改它。</p>
<ul>
<li>保护变量：<code>变量名前使用一个下划线，称为保护变量</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">print(tom._age)</span><br><span class="line">print(tom.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 18</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;_age&#x27;: 18&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过上例，可以看出这个<code>_age</code>属性根本就没有改变名称，和普通的属性一样，解释器不做任何特殊处理。<br />
这只是开发者共同的约定，看见这种属性或者变量，就如同私有，不要直接使用。</p>
<ul>
<li>私有方法：参照保护、私有，使用单下划线、双下划线命方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_getname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getage</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">print(tom._getname()) <span class="comment"># 保护，没改名</span></span><br><span class="line"><span class="comment">#print(tom.__getage()) # 无此属性</span></span><br><span class="line">print(tom._Person__getage()) <span class="comment"># 黑魔法（作弊访问）</span></span><br><span class="line">print(tom.__dict__)</span><br><span class="line">print(tom.__class__.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tom</span></span><br><span class="line"><span class="comment"># 18</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;_age&#x27;: 18&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__init__&#x27;: &lt;function Person.__init__ at 0x0000023033569B70&gt;, &#x27;_getname&#x27;: &lt;function Person._getname at 0x0000023033569BF8&gt;, &#x27;_Person__getage&#x27;: &lt;function Person.__getage at 0x0000023033569C80&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Person&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Person&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure>
<p>上例，私有方法和前面的私有变量一样，解释器给<code>改名</code>了。</p>
<p>私有方法的本质：<br />
单下划线的方法只是开发者之间的约定，解释器不做任何改变。<br />
双下划线的方法，是私有方法，解释器会改名，改名策略和私有变量相同，<code>_类名__方法名</code>。<br />
方法变量都在类的<code>__dict__</code>中可以找到。</p>
<p>私有成员的总结：<br />
在Python中使用 <code>_</code>单下划线 或者<code>__</code>双下划线来标识一个成员被保护或者被私有化隐藏起来。<br />
但是，不管使用什么样的访问控制，都不能真正的阻止用户修改类的成员。Python中没有绝对的安全的<code>保护成员</code>或者<code>私有成员</code>。<br />
因此，前导的下划线只是一种警告或者提醒，请遵守这个约定。<code>除非真有必要，否则外部不要使用保护成员或者私有成员，更不要修改它们</code>。</p>
<h4 id="补丁"><a class="markdownIt-Anchor" href="#补丁"></a> 补丁</h4>
<p>可以通过<code>修改或者替换类的成员</code>。使用者调用的方式没有改变，但是类提供的功能可能已经改变了。</p>
<p>猴子补丁（Monkey Patch）：<br />
在运行时，对属性、方法、函数等进行动态替换。<br />
目的往往是为了通过替换、修改来增强原有代码的能力。<br />
黑魔法（作弊访问）慎用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        ret = &#123;<span class="string">&#x27;English&#x27;</span>:<span class="number">78</span>, <span class="string">&#x27;Chinese&#x27;</span>:<span class="number">86</span>, <span class="string">&#x27;History&#x27;</span>:<span class="number">82</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test3.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dict</span>(name=self.__class__.__name__,English=<span class="number">88</span>, Chinese=<span class="number">90</span>,History=<span class="number">85</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test1.py</span></span><br><span class="line"><span class="keyword">from</span> test2 <span class="keyword">import</span> Person</span><br><span class="line"><span class="keyword">from</span> test3 <span class="keyword">import</span> get_score</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">monkeypatch4Person</span>():</span></span><br><span class="line">    Person.get_score = get_score <span class="comment"># 用test3中的get_score替换2中Person类的get_score方法</span></span><br><span class="line"></span><br><span class="line">monkeypatch4Person() <span class="comment"># 打补丁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(Person().get_score())</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;Person&#x27;, &#x27;English&#x27;: 88, &#x27;Chinese&#x27;: 90, &#x27;History&#x27;: 85&#125;</span></span><br></pre></td></tr></table></figure>
<p>上例中，假设<code>Person</code>类的<code>get_score</code>方法是从数据库拿数据，但是测试的时候不方便，为了测试时方便，使用猴子补丁，替换了<code>get_score</code>方法，返回模拟的数据。</p>
<h4 id="属性装饰器"><a class="markdownIt-Anchor" href="#属性装饰器"></a> 属性装饰器</h4>
<p>一般好设计是：把实例的某些属性保护起来，不让外部直接访问，外部使用<code>getter</code>读取属性、<code>setter</code>设置属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age = <span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_age</span>(<span class="params">self,age</span>):</span></span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">print(tom.age())</span><br><span class="line">tom.set_age(<span class="number">20</span>)</span><br><span class="line">print(tom.age())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 18</span></span><br><span class="line"><span class="comment"># 20</span></span><br></pre></td></tr></table></figure>
<p>通过age和set_age方法操作私有属性。<br />
有没有简单方式呢？让使用者感觉是属性而不是方法？<br />
Python提供了属性property装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#装饰器去掉方法的&quot;()&quot;，方法当成属性来用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age1=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__agex = age1</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property # 只读，tom.age 等价以前的tom.age()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__agex</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter # 可写，属性名就是函数名age</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self, age2</span>):</span></span><br><span class="line">        self.__agex = age2</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.deleter # 控制是否删除属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;del&#x27;</span>) <span class="comment"># 应该是del self.__age，这里看效果使用print</span></span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">print(tom.age) <span class="comment">#property装饰后，可读</span></span><br><span class="line"></span><br><span class="line">tom.age = <span class="number">20</span> <span class="comment"># setter装饰后，可写</span></span><br><span class="line">print(tom.age)</span><br><span class="line"><span class="keyword">del</span> tom.age <span class="comment"># deleter装饰后，引用计数为0，垃圾回收时执行del</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 18 20 del </span></span><br></pre></td></tr></table></figure>
<p>特别注意：</p>
<ul>
<li>使用属性装饰器的时候<code>这三个被装饰的函数要同名</code>！以后调用的属性名就是这个函数名。</li>
<li><code>property</code>装饰器必须在前面，<code>setter</code>、<code>deleter</code>装饰器在后面。</li>
<li><code>property</code>装饰器：后面跟的<code>函数名就是以后的属性名</code>。它就是getter。这个必须有，有了它至少是<code>只读</code>属性。</li>
<li><code>setter</code>装饰器：与属性名（函数名）同名，且接收2个参数，第一个是self，第二个是将要赋值的值。有了它，属性<code>可写</code>。</li>
<li><code>deleter</code>装饰器：与属性名（函数名）同名，可以控制是否删除属性，很少用。</li>
</ul>
<p><code>property</code>装饰器能通过简单的方式，把对方法的操作变成对属性的访问，并起到了一定隐藏效果。其次在返回这个属性前，可以对其<code>加工</code>。</p>
<p>其他写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age=<span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getage</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setage</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delage</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># del self.__age</span></span><br><span class="line">        print(<span class="string">&#x27;del&#x27;</span>,end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    age = <span class="built_in">property</span>(getage, setage, delage, <span class="string">&#x27;age property&#x27;</span>)</span><br><span class="line">        <span class="comment"># property(fget=None, fset=None, fdel=None, doc=None)</span></span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">print(tom.age,end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">tom.age = <span class="number">20</span></span><br><span class="line">print(tom.age,end = <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">del</span> tom.age</span><br><span class="line"></span><br><span class="line"><span class="comment">#18 20 del </span></span><br></pre></td></tr></table></figure>
<p>还可以如下写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age = <span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    age = <span class="built_in">property</span>(<span class="keyword">lambda</span> self:self.__age)</span><br><span class="line"></span><br><span class="line">tom = Person(<span class="string">&#x27;Tom&#x27;</span>)</span><br><span class="line">print(tom.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">#18</span></span><br></pre></td></tr></table></figure>
<h4 id="对象的销毁"><a class="markdownIt-Anchor" href="#对象的销毁"></a> 对象的“销毁”</h4>
<p>类中可以定义<code>__del__</code>方法，称为<code>析构函数（方法）</code>。</p>
<ul>
<li><code>__del__</code>方法：销毁类的<code>实例</code>的时候调用，以释放占用的资源。其中就放些清理资源的代码，比如释放连接。</li>
<li>这个方法不能引起对象的真正销毁，只是对象销毁的时候会自动调用它。</li>
<li>使用<code>del</code>语句删除实例，引用计数减1，当引用计数为0时，会自动调用<code>__del__</code>方法（并不一定是立即执行）。</li>
<li>由于Python实现了垃圾回收机制，不能确定对象何时执行垃圾回收。</li>
</ul>
<p>小知识：用<code>__</code>全包裹的都是魔术方法，比如<code>__init__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age = <span class="number">18</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;delete &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    tom = Person(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">    tom.__del__() <span class="comment">#手动调用</span></span><br><span class="line">    tom.__del__()</span><br><span class="line">    print(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    tom2 = tom <span class="comment"># 对tom增加引用</span></span><br><span class="line">    tom3 = tom2</span><br><span class="line"></span><br><span class="line">    print(<span class="number">1</span>,<span class="string">&#x27;del&#x27;</span>)</span><br><span class="line">    <span class="keyword">del</span> tom <span class="comment"># 虽然删除了tom（引用计数减1），但tom引用计数还不是0</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="number">2</span>,<span class="string">&#x27;del&#x27;</span>)</span><br><span class="line">    <span class="keyword">del</span> tom2</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&#x27;-&#x27;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> tom3 <span class="comment"># 注释掉这句，就不会执行__del__，因为tom引用计数不为0</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&#x27;-&#x27;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete tom</span></span><br><span class="line"><span class="comment"># delete tom</span></span><br><span class="line"><span class="comment"># ------------------------------</span></span><br><span class="line"><span class="comment"># 1 del</span></span><br><span class="line"><span class="comment"># ------------------------------</span></span><br><span class="line"><span class="comment"># 2 del</span></span><br><span class="line"><span class="comment"># ------------------------------</span></span><br><span class="line"><span class="comment"># delete tom</span></span><br><span class="line"><span class="comment"># ------------------------------</span></span><br></pre></td></tr></table></figure>
<p>上例中手动调用<code>__del__</code>会执行，而且当实例的引用计数为0时，自动调用<code>__del__</code>执行（什么时候执行与垃圾回收有关）。<br />
由于垃圾回收对象销毁时，才会真正清理对象，还会在回收对象之前自动调用<code>__del__</code>方法，执行不确定性强，除非你明确知道自己的目的，<code>建议不要手动调用</code>这个方法。</p>
<h4 id="方法重载overload"><a class="markdownIt-Anchor" href="#方法重载overload"></a> 方法重载（Overload）</h4>
<p>其他面向对象的高级语言中，会有重载的概念。<br />
所谓重载，就是同一个方法名，但是参数数量、类型不一样，就是同一个方法的重载。</p>
<p>在其他语言中，这些同名函数可以存在，不会出现覆盖，调用时根据参数数量等，符合哪个就用哪个。</p>
<p>比如C++中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// volume of a cube</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s*s*s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volume of a cylinder</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">volume</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> r, <span class="keyword">const</span> <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.1415926</span>*r*r*<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// volume of a cuboid</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">volume</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> l, <span class="keyword">const</span> <span class="keyword">int</span> b, <span class="keyword">const</span> <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l*b*h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; volume(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; volume(<span class="number">2.5</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; volume(<span class="number">100</span>, <span class="number">75</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1000</span></span><br><span class="line"><span class="comment">// 157.08</span></span><br><span class="line"><span class="comment">// 112500</span></span><br></pre></td></tr></table></figure>
<p>main函数分别调用了三个同名的函数，但它会根据参数匹配符合的函数，这就是重载。</p>
<p>那么Python呢？</p>
<ul>
<li>Python没有重载！</li>
<li>Python不需要重载！</li>
<li>Python中，同一作用域，出现同一方法名，就是覆盖！</li>
</ul>
<p>可以说Python本身就实现了其他语言的重载。</p>
<p>Python函数定义中，形参非常灵活，不需要指定类型（Python中只有参数注解，是一种提示不是约束），参数个数也不固定（可变参数<code>*args，**kwargs</code>），一个函数的定义可以实现多种不同形式实参的调用，所以Python不需要方法的重载。</p>
<h4 id="方法的覆盖override"><a class="markdownIt-Anchor" href="#方法的覆盖override"></a> 方法的覆盖（Override）</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 继承参考4.15</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal shouts&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="comment"># 覆盖了父类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;miao&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = Animal()</span><br><span class="line">a.shout()</span><br><span class="line">c = Cat()</span><br><span class="line">c.shout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Animal shouts</span></span><br><span class="line"><span class="comment"># miao</span></span><br></pre></td></tr></table></figure>
<p>上例中，子类的shout方法覆盖了父类方法。</p>
<p>Cat中能否覆盖自己的方法吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal shouts&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="comment"># 覆盖了父类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;miao&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="built_in">super</span>()) <span class="comment"># super(type, obj) -&gt; bound super object</span></span><br><span class="line">        print(<span class="built_in">super</span>(Cat, self)) <span class="comment"># 和上面super()等价的</span></span><br><span class="line">        print(<span class="string">&#x27;-&#x27;</span> * <span class="number">30</span>)</span><br><span class="line">        <span class="built_in">super</span>().shout()</span><br><span class="line">        <span class="built_in">super</span>(Cat, self).shout()  <span class="comment"># 等价于super().shout()</span></span><br><span class="line">        self.__class__.__base__.shout(self)  <span class="comment"># 不推荐</span></span><br><span class="line"></span><br><span class="line">a = Animal()</span><br><span class="line">a.shout() <span class="comment"># Animal shouts</span></span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">30</span>)</span><br><span class="line">c = Cat()</span><br><span class="line">c.shout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Animal shouts</span></span><br><span class="line"><span class="comment"># ------------------------------</span></span><br><span class="line"><span class="comment"># &lt;super: &lt;class &#x27;Cat&#x27;&gt;, &lt;Cat object&gt;&gt;</span></span><br><span class="line"><span class="comment"># &lt;super: &lt;class &#x27;Cat&#x27;&gt;, &lt;Cat object&gt;&gt;</span></span><br><span class="line"><span class="comment"># ------------------------------</span></span><br><span class="line"><span class="comment"># Animal shouts</span></span><br><span class="line"><span class="comment"># Animal shouts</span></span><br><span class="line"><span class="comment"># Animal shouts</span></span><br></pre></td></tr></table></figure>
<p><code>super()</code>可以访问到父类的属性。<br />
那对于类方法和静态方法呢？一样会覆盖，可以自己试试，原理都一样，属性字典的顺序。</p>
<h4 id="类的封装"><a class="markdownIt-Anchor" href="#类的封装"></a> 类的封装</h4>
<p>面向对象的三要素之一，封装Encapsulation！</p>
<p>在Python中封装的作用：</p>
<ul>
<li>将数据和操作组织到类中，即属性和方法。</li>
<li>将数据隐藏起来，给使用者提供操作（方法）。使用者通过操作就可以获取或者修改数据，比如<code>getter</code>和<code>setter</code>。</li>
<li>通过访问终止，暴露适当的数据和操作给用户，该隐藏的隐藏起来，例如<code>保护成员</code>或<code>私有成员</code>。</li>
</ul>
<p>以上就是封装作用描述，其实在之前的内容中都能体会到这些作用，这里就不在举例解释了。</p>
<h4 id="类的单继承"><a class="markdownIt-Anchor" href="#类的单继承"></a> 类的单继承</h4>
<p>面向对象的三要素之一，继承Inheritance！</p>
<p>个体继承自父母，继承了父母的一部分特征，但也有自己的个性。</p>
<p>在面向对象的世界中，从父类继承，就可以直接拥有父类的属性和方法，这样可以减少代码、多复用。子类可以定义自己的属性和方法。</p>
<p>看一个不用继承的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal shouts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = Animal()</span><br><span class="line">a.shout()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Cat shouts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">c = Cat()</span><br><span class="line">c.shout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Animal shouts</span></span><br><span class="line"><span class="comment"># Cat shouts</span></span><br></pre></td></tr></table></figure>
<p>上面的2个类虽然有关系，但是定义时并没有建立这种关系，而是各自完成定义。<br />
动物类和猫类都有吃，但是它们的吃有区别，所以分别定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shout</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; shouts&#x27;</span>.<span class="built_in">format</span>(self.__class__.__name__))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">a = Animal(<span class="string">&#x27;monster&#x27;</span>)</span><br><span class="line">a.shout()</span><br><span class="line">print(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cat = Cat(<span class="string">&#x27;girl&#x27;</span>)</span><br><span class="line">cat.shout()</span><br><span class="line">print(cat.name)</span><br><span class="line">print(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">&#x27;ahuang&#x27;</span>)</span><br><span class="line">dog.shout()</span><br><span class="line">print(dog.name)</span><br><span class="line">print(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Animal shouts</span></span><br><span class="line"><span class="comment"># --------------------</span></span><br><span class="line"><span class="comment"># Cat shouts</span></span><br><span class="line"><span class="comment"># girl</span></span><br><span class="line"><span class="comment"># --------------------</span></span><br><span class="line"><span class="comment"># Dog shouts</span></span><br><span class="line"><span class="comment"># ahuang</span></span><br><span class="line"><span class="comment"># --------------------</span></span><br></pre></td></tr></table></figure>
<p>上例可以看出，通过继承，猫类、狗类不用写shout函数，直接继承了父类的属性和方法。</p>
<ul>
<li>继承：<code>class Cat(Animal)</code>这种形式就是从父类继承，括号中写上继承的类的列表。</li>
<li>父类：Animal就是Cat的父类，也称为基类、超类。</li>
<li>子类：Cat就是Animal的子类，也称为派生类。</li>
</ul>
<p>定义格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类名(<span class="params">基类<span class="number">1</span>[,基类<span class="number">2</span>,...]</span>)：</span></span><br><span class="line"><span class="class">    语句块</span></span><br></pre></td></tr></table></figure>
<p>如果类定义时，没有基类列表，等同于继承自object。在Python3中，object类是所有对象的<code>根</code>基类。</p>
<p>继承的特殊属性和方法：<code>__base__</code>类的基类，<code>__bases__</code>类的基类元组，<code>__mro__</code>显示方法查找顺序，基类的元组，<code>maro()</code>显示方法查找顺序，返回基类的列表，<code>__subclasses__()</code>类的子类列表。</p>
<p>继承中的访问控制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    __COUNT = <span class="number">100</span> <span class="comment"># _Animal__COUNT</span></span><br><span class="line">    HEIGHT = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age, weight, height</span>):</span></span><br><span class="line">        self.__COUNT += <span class="number">1</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.__weight = weight</span><br><span class="line">        self.HEIGHT = height</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; eat&#x27;</span>.<span class="built_in">format</span>(self.__class__.__name__)) <span class="comment"># Cat.__name__</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getweight</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.__weight)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showcount1</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(cls)</span><br><span class="line">        print(cls.__dict__)</span><br><span class="line">        print(cls.__COUNT) <span class="comment"># 显示多少？100,等价于cls._Animal__COUNT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__showcount2</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(cls.__COUNT)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showcount3</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.__COUNT) <span class="comment"># 是多少？101，等价于self._Animal__COUNT</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    NAME = <span class="string">&#x27;CAT&#x27;</span></span><br><span class="line">    __COUNT = <span class="number">200</span> <span class="comment"># _Cat__COUNT</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c = Cat() # __init__函数参数错误</span></span><br><span class="line">c = Cat(<span class="number">3</span>, <span class="number">5</span>, <span class="number">15</span>)</span><br><span class="line">c.eat()</span><br><span class="line">print(c.HEIGHT)</span><br><span class="line"><span class="comment"># print(c.__COUNT) #私有的不可访问</span></span><br><span class="line"><span class="comment"># c.__getweight() #私有的不可访问</span></span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">40</span>)</span><br><span class="line">c.showcount1()</span><br><span class="line"><span class="comment"># c.__showcount2() #私有的不可访问</span></span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">40</span>)</span><br><span class="line">c.showcount3()</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">40</span>)</span><br><span class="line">print(c.NAME)</span><br><span class="line">print(c._Cat__COUNT)</span><br><span class="line">print(c._Animal__COUNT)</span><br><span class="line">print(<span class="built_in">type</span>(c)._Cat__COUNT)</span><br><span class="line">print(<span class="built_in">type</span>(c)._Animal__COUNT)</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">40</span>)</span><br><span class="line">print(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(Animal.__dict__))</span><br><span class="line">print(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(Cat.__dict__))</span><br><span class="line">print(c.__dict__)</span><br><span class="line">print(<span class="string">&#x27;-&#x27;</span> * <span class="number">40</span>)</span><br><span class="line">print(c.__class__.mro())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cat eat</span></span><br><span class="line"><span class="comment"># 15</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;__main__.Cat&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;NAME&#x27;: &#x27;CAT&#x27;, &#x27;_Cat__COUNT&#x27;: 200, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="comment"># 100</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># 101</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># CAT</span></span><br><span class="line"><span class="comment"># 200</span></span><br><span class="line"><span class="comment"># 101</span></span><br><span class="line"><span class="comment"># 200</span></span><br><span class="line"><span class="comment"># 100</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;_Animal__COUNT&#x27;: 100, &#x27;HEIGHT&#x27;: 0, &#x27;__init__&#x27;: &lt;function Animal.__init__ at 0x00000226B7399B70&gt;, &#x27;eat&#x27;: &lt;function Animal.eat at 0x00000226B7399BF8&gt;, &#x27;_Animal__getweight&#x27;: &lt;function Animal.__getweight at 0x00000226B7399C80&gt;, &#x27;showcount1&#x27;: &lt;classmethod object at 0x00000226B73B62E8&gt;, &#x27;_Animal__showcount2&#x27;: &lt;classmethod object at 0x00000226B73B6358&gt;, &#x27;showcount3&#x27;: &lt;function Animal.showcount3 at 0x00000226B7399E18&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Animal&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Animal&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;NAME&#x27;: &#x27;CAT&#x27;, &#x27;_Cat__COUNT&#x27;: 200, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_Animal__COUNT&#x27;: 101, &#x27;age&#x27;: 3, &#x27;_Animal__weight&#x27;: 5, &#x27;HEIGHT&#x27;: 15&#125;</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># [&lt;class &#x27;__main__.Cat&#x27;&gt;, &lt;class &#x27;__main__.Animal&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>从父类继承，自己没有的，即可以到父类中找。</li>
<li>私有的外部都不可以访问（黑魔法除外）。</li>
<li>继承时，公有的，子类和实例都可以随意访问；私有成员被隐藏，子类和实例不可直接访问，但私有变量所在的类内的方法中可以访问这个私有变量。</li>
<li>属性查找顺序：<code>self.__dict__</code> -&gt; <code>cls.__dict__</code> -&gt; <code>父类.__dict__</code>，如果都查找不到就会抛出异常，先找到就会立即返回了。</li>
</ul>
<p>继承中初始化：</p>
<p>前面十三讲了覆盖的事情，那么初始化会不会被覆盖呢？先看下面一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a</span>):</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, b, c</span>):</span></span><br><span class="line">        self.b = b</span><br><span class="line">        self.c = c</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printv</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.b)</span><br><span class="line">        print(self.a) <span class="comment"># 出错吗？出错，用自己的初始化，不用A的，所以没有a属性</span></span><br><span class="line">f = B(<span class="number">200</span>,<span class="number">300</span>)</span><br><span class="line">print(f.__dict__)</span><br><span class="line">print(f.__class__.__bases__)</span><br><span class="line">f.printv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;b&#x27;: 200, &#x27;c&#x27;: 300&#125;</span></span><br><span class="line"><span class="comment"># (&lt;class &#x27;__main__.A&#x27;&gt;,)</span></span><br><span class="line"><span class="comment"># 200</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;B&#x27; object has no attribute &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上例可知：<br />
类B定义时声明继承自类A，所以在类B中<code>__bases__</code>中是可以看到类A的。<br />
但是这个是否调用类A的构造方法是两回事。<br />
如果B中调用了A中方法，就可以拥有父类的属性了。<br />
从B的实例<code>f.__dict</code>中可知，f 的初始化是走的B类的，所以相当于覆盖了A的初始化。</p>
<p>试想一下，如果A类初始化中的属性，是子类都应该有的，但子类（B）也有初始化自己独有的属性，这就产生冲突，因为初始化只执行子类的了，这种情况如何解决呢？看如下代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, a, d=<span class="number">10</span></span>):</span></span><br><span class="line">        self.a = a </span><br><span class="line">        self.__d = d <span class="comment"># d是A类独有，就私有化，这样子类B就不能更改了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, b, c</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(b + c, b - c) <span class="comment"># 手动调用</span></span><br><span class="line">        self.b = b</span><br><span class="line">        self.c = c</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printv</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.b)</span><br><span class="line">        print(self.a) <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">f = B(<span class="number">200</span>,<span class="number">300</span>)</span><br><span class="line">print(f.__dict__)</span><br><span class="line">print(f.__class__.__bases__)</span><br><span class="line">f.printv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;a&#x27;: 500, &#x27;_A__d&#x27;: -100, &#x27;b&#x27;: 200, &#x27;c&#x27;: 300&#125;</span></span><br><span class="line"><span class="comment"># (&lt;class &#x27;__main__.A&#x27;&gt;,)</span></span><br><span class="line"><span class="comment"># 200</span></span><br><span class="line"><span class="comment"># 500</span></span><br></pre></td></tr></table></figure>
<p>上例中：</p>
<ul>
<li>父类A有子类B不可更改的属性d，所以使用私有化，使父类某些属性与子类属性隔离。</li>
<li>在子类B初始化中，调用父类初始化。</li>
</ul>
<p>从<code>f.__dict__</code>中可以看到，父类A和子类B的初始化都成功执行了。</p>
<p>作为好习惯，如果父类定义了<code>__init__</code>方法，你就该在子类的<code>__init__</code>中调用它。</p>
<p>那子类什么时候调用父类的<code>__init__</code>呢？</p>
<ol>
<li>子类中没有<code>__init__</code>时，自动调用用父类<code>__init__</code>。</li>
<li>子类定义了<code>__init__</code>，不会自动调用父类的<code>__init__</code>，这时需要手动调用。</li>
</ol>
<p>正确使用方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal init&#x27;</span>)</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.age)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age, weight</span>):</span></span><br><span class="line">        <span class="comment"># 注意：调用父类的__init__方法的位置决定着show方法的结果</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(age) <span class="comment"># 使用super()</span></span><br><span class="line">        print(<span class="string">&#x27;Cat init&#x27;</span>)</span><br><span class="line">        self.age = age + <span class="number">1</span></span><br><span class="line">        self.weight = weight</span><br><span class="line">        <span class="comment"># super().__init__(age) # 若在此调用呢？结果一样吗？10，不一样，覆盖了</span></span><br><span class="line"></span><br><span class="line">c = Cat(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">c.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Animal init</span></span><br><span class="line"><span class="comment"># Cat init</span></span><br><span class="line"><span class="comment"># 11</span></span><br></pre></td></tr></table></figure>
<p>上面例子，使用<code>super()</code>来调用父类初始化，严谨。发现属性age有冲突，这时初始化的执行顺序就很重要了，一般父类（Animal）的初始化要放在子类<code>__init__</code>内的最前面执行。</p>
<p>也可以直接将所有的实例属性改成私有变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal init&#x27;</span>)</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.__age) <span class="comment"># __age == _Animal__age</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age, weight</span>):</span></span><br><span class="line">        <span class="comment">#super().__init__(age)</span></span><br><span class="line">        print(<span class="string">&#x27;Cat init&#x27;</span>)</span><br><span class="line">        self.__age = age + <span class="number">1</span> <span class="comment"># __age == _Cat__age</span></span><br><span class="line">        self.__weight = weight</span><br><span class="line">        <span class="built_in">super</span>().__init__(age) <span class="comment"># 这样就不会覆盖了</span></span><br><span class="line"></span><br><span class="line">c = Cat(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">c.show()</span><br><span class="line">print(c.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cat init</span></span><br><span class="line"><span class="comment"># Animal init</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_Cat__age&#x27;: 11, &#x27;_Cat__weight&#x27;: 5, &#x27;_Animal__age&#x27;: 10&#125;</span></span><br></pre></td></tr></table></figure>
<p>上例中打印10，原因看<code>__dict</code>就知道了，因为父类Animal的show方法中__age会被解释为_Animal__age，因此显示的是10，而不是11。</p>
<p>但是这样的设计不好，Cat的实例c应该显示自己的属性值更好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal init&#x27;</span>)</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.__age) <span class="comment"># __age == _Animal__age</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age, weight</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(age)</span><br><span class="line">        print(<span class="string">&#x27;Cat init&#x27;</span>)</span><br><span class="line">        self.age = age + <span class="number">1</span> </span><br><span class="line">        self.weight = weight</span><br><span class="line">        <span class="comment">#super().__init__(age) </span></span><br><span class="line"></span><br><span class="line">c = Cat(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line">c.show()</span><br><span class="line">print(c.age)</span><br><span class="line">print(c.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Animal init</span></span><br><span class="line"><span class="comment"># Cat init</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># 11</span></span><br><span class="line"><span class="comment"># &#123;&#x27;_Animal__age&#x27;: 10, &#x27;age&#x27;: 11, &#x27;weight&#x27;: 5&#125;</span></span><br></pre></td></tr></table></figure>
<p>把不需要隐藏的属性暴露出来，这样实例就可以调用自己属性了。</p>
<ul>
<li>总结： 自己的私有属性，就该自己的方法读取和修改，不要借助其他类的方法，即使是父类或者派生类的方法。</li>
</ul>
<h4 id="类的多继承"><a class="markdownIt-Anchor" href="#类的多继承"></a> 类的多继承</h4>
<p>OCP原则：多用“继承”、少修改。<br />
继承的用途：在子类上实现对基类的增强、实现多态。</p>
<p>多态：在面向对象中，父类、子类通过继承联系在一起，如果可以通过一套方法，就可以实现不同表现，就是多态。</p>
<p>一个类继承自多个类就是多继承，它将具有多个类的特征。</p>
<p>多继承弊端：<br />
多继承很好的模拟了世界，因为事物很少是单一继承，但是舍弃简单，必然引入复杂性，带来了冲突。<br />
如同一个孩子继承了来自父母双方的特征。那么到底眼睛像爸爸还是妈妈呢？孩子究竟该像谁多一点呢？</p>
<p>多继承的实现会导致编译器设计的复杂度增加，所以现在很多语言也舍弃了类的多继承。</p>
<p>C++支持多继承；Java舍弃了多继承。<br />
Java中，一个类可以实现多个接口，一个接口也可以继承多个接口。Java的接口很纯粹，只是方法的声明，继承者必须实现这些方法，就具有了这些能力，就能干什么。</p>
<p>多继承可能会带来二义性，例如，猫和狗都继承自动物类，现在如果一个类多继承了猫和狗类，猫和狗都有shout方法，子类究竟继承谁的shout呢？<br />
解决方案：实现多继承的语言，要解决二义性，深度优先或者广度优先。</p>
<p>Python多继承的实现：</p>
<p>如图所示：</p>
<div  align=center> 
<img src="https://img-blog.csdnimg.cn/20190219211051673.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNDAyMTY=,size_16,color_FFFFFF,t_70" width=70%" height="70%">    
</div>  
<p>左图是多继承（菱形继承），右图是单一继承。</p>
<p>多继承带来路径选择问题，究竟继承哪个父类的特征呢？<br />
Python使用MRO（method resolution order方法解析顺序）解决基类搜索顺序问题。</p>
<ul>
<li>历史原因，MRO有三个搜索算法（都是深度优先）：
<ul>
<li>经典算法，按照定义从左到右，深度优先策略。2.2版本之前，左图的MRO是<code>MyClass,D,B,A,C,A</code>。</li>
<li>新式类算法，是经典算法的升级，深度优先，重复的只保留最后一个。2.2版本，左图的MRO是<code>MyClass,D,B,C,A,object</code>。</li>
<li>C3算法，在类被创建出来的时候，就计算出一个MRO有序列表。2.3之后，Python3唯一支持的算法。左图中的MRO是<code>MyClass,D,B,C,A,object</code>的列表。C3算法解决多继承的二义性。</li>
</ul>
</li>
</ul>
<ol>
<li>经典算法有很大的问题，如果C中有覆盖A的方法，就不会访问到了，因为先访问A（深度优先）。</li>
<li>新式类算法，依然采用了深度优先，解决了重复问题，但是同经典算法一样，没有解决继承的单调性。</li>
<li>C3算法，解决了继承的单调性，它阻止创建之前版本产生二义性的代码。求得的MRO本质是为了线性化，且确定了顺序。</li>
</ol>
<p>多继承的缺点：</p>
<ol>
<li>当类很多，继承复杂的情况下，继承路径太多，很难说清什么样的继承路径。</li>
<li>Python语法是允许多继承，但Python代码是解释执行，只有执行到的时候，才发现错误。</li>
<li>团队协作开发，如果引入多继承，那代码很有可能不可控。</li>
<li>不管编程语言是否支持多继承，都应当避免多继承。</li>
<li>Python的面向对象，我们看到的太灵活了，太开放了，所以要团队守规矩。</li>
</ol>
<h4 id="20和30继承的区别"><a class="markdownIt-Anchor" href="#20和30继承的区别"></a> 2.0和3.0继承的区别</h4>
<ol>
<li>Python2.2之前类是没有共同的祖先的。这之后，引入object类，它是所有类的共同祖先类object。</li>
<li>Python2中为了兼容，分为古典类（旧式类）和新式类。</li>
<li>Python3中全部都是新式类。</li>
<li>新式类都是继承自object的，新式类可以使用super。</li>
</ol>
<p>以下代码是Python2.x中的类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码在Python2.x中运行</span></span><br><span class="line"><span class="comment"># 古典类（旧式类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">dir</span>(A))</span><br><span class="line">print(<span class="built_in">dir</span>(B))</span><br><span class="line">print(A.__bases__)</span><br><span class="line">print(B.__bases__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 古典类</span></span><br><span class="line">a = A()</span><br><span class="line">print(a.__class__)</span><br><span class="line">print(<span class="built_in">type</span>(a)) <span class="comment"># &lt;type &#x27;instance&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新式类</span></span><br><span class="line">b = B()</span><br><span class="line">print(b.__class__)</span><br><span class="line">print(<span class="built_in">type</span>(b))</span><br></pre></td></tr></table></figure>
<p>在Python3版本开始，都是新式类了。</p>
<h4 id="mixin重点"><a class="markdownIt-Anchor" href="#mixin重点"></a> Mixin（重点）</h4>
<p>类有下面的继承关系：</p>
<div  align=center> 
<img src="https://img-blog.csdnimg.cn/20190219212129377.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNDAyMTY=,size_16,color_FFFFFF,t_70" width=50%" height="50%">    
</div> 
<p>文档Document类是其他所有文档类的抽象基类；<br />
Word、Pdf类是Document的子类；</p>
<p>现在有如下3个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span>(<span class="params">self,content</span>):</span></span><br><span class="line">        self.content = content</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span>(<span class="params">self</span>):</span>  <span class="comment"># 抽象方法，这里当成“打印”方法</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span>(<span class="params">Document</span>):</span> <span class="keyword">pass</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pdf</span>(<span class="params">Document</span>):</span> <span class="keyword">pass</span>  </span><br></pre></td></tr></table></figure>
<p>基类提供的方法可以不具体实现，因为它未必适合子类的打印，子类中需要覆盖重写。<br />
基类中只定义，不实现的方法，称为<code>抽象方法</code>。在Python中，如果采用这种方式定义的抽象方法，子类可以不实现，直到子类使用该方法的时候才报错。</p>
<p>需要打印的子类上增加（使用继承来增加功能）：<br />
如果在现有子类上直接增加，虽然可以却违反了OCP的原则，（对原代码进行了修改），这种情况可以用继承解决，继承后增加打印功能。如下图所示：</p>
<div  align=center> 
<img src="https://img-blog.csdnimg.cn/2019021921305487.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMzNDAyMTY=,size_16,color_FFFFFF,t_70" width=50%" height="50%">    
</div> 
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>:</span> <span class="comment"># 第三方库，不允许修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        self.content = content</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span>(<span class="params">Document</span>):</span> <span class="keyword">pass</span> <span class="comment"># 第三方库，不允许修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pdf</span>(<span class="params">Document</span>):</span> <span class="keyword">pass</span> <span class="comment"># 第三方库，不允许修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintableWord</span>(<span class="params">Word</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.content)</span><br><span class="line"></span><br><span class="line">print(PrintableWord.__dict__)</span><br><span class="line">print(PrintableWord.mro())</span><br><span class="line"></span><br><span class="line">pw = PrintableWord(<span class="string">&#x27;test string&#x27;</span>)</span><br><span class="line">pw.print()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;print&#x27;: &lt;function PrintableWord.print at 0x0000023859129950&gt;, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="comment"># [&lt;class &#x27;__main__.PrintableWord&#x27;&gt;, &lt;class &#x27;__main__.Word&#x27;&gt;, &lt;class &#x27;__main__.Document&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line"><span class="comment"># test string</span></span><br></pre></td></tr></table></figure>
<p>上例使用继承来达到目的，看似不错，如果需要还要提供其他能力，如何继承？一个一个增加吗？<br />
比如，应用于网络，文档应该具备序列化的能力，类上就应该实现序列化。可序列化还可能分为使用pickle、json、messagepack等。</p>
<p>功能太多，A类需要某几样功能，B类需要另几样功能，它们需要的是多个功能的自由组合，继承实现很繁琐。</p>
<p>类和功能太多，而且不同类需要的功能组合不同，这时单继承就力不从心了。使用<code>装饰器</code>或<code>Mixin（本质是多继承）</code>来实现。</p>
<p>装饰器方式：<br />
用装饰器增强一个类，把功能给类附加上去，哪个类需要，就装饰它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>:</span> <span class="comment"># 第三方库，不允许修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        self.content = content</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span>(<span class="params">Document</span>):</span> <span class="keyword">pass</span> <span class="comment"># 第三方库，不允许修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pdf</span>(<span class="params">Document</span>):</span> <span class="keyword">pass</span> <span class="comment"># 第三方库，不允许修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printable</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_print</span>(<span class="params">self</span>):</span><span class="comment"># _print这里是防止和内部print重名而引起死循环</span></span><br><span class="line">        print(self.content, <span class="string">&#x27;装饰器&#x27;</span>)</span><br><span class="line">    cls.<span class="built_in">print</span> = _print <span class="comment"># 为类增加print属性，print记住了_print函数</span></span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@printable # 先继承，后装饰</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintableWord</span>(<span class="params">Word</span>):</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(PrintableWord.__dict__)</span><br><span class="line">print(PrintableWord.mro())</span><br><span class="line">pw = PrintableWord(<span class="string">&#x27;test string&#x27;</span>)</span><br><span class="line">pw.print()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;print&#x27;: &lt;function printable.&lt;locals&gt;._print at 0x000002553DAA9950&gt;&#125;</span></span><br><span class="line"><span class="comment"># [&lt;class &#x27;__main__.PrintableWord&#x27;&gt;, &lt;class &#x27;__main__.Word&#x27;&gt;, &lt;class &#x27;__main__.Document&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line"><span class="comment"># test string 装饰器</span></span><br><span class="line">``` </span><br><span class="line">上例中，类增加<span class="built_in">print</span>属性，<span class="built_in">print</span>属性记住了_print函数。  </span><br><span class="line">这里体现了`一切皆对象`的特点！！！</span><br><span class="line"></span><br><span class="line">装饰器优点：  </span><br><span class="line">简单方便，在需要的地方动态增加，直接使用装饰器。    </span><br><span class="line">可以为类灵活的增加功能。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mixin方式：</span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span>:</span> <span class="comment"># 第三方库，不允许修改</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        self.content = content</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word</span>(<span class="params">Document</span>):</span> <span class="keyword">pass</span> <span class="comment"># 第三方库，不允许修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pdf</span>(<span class="params">Document</span>):</span> <span class="keyword">pass</span> <span class="comment"># 第三方库，不允许修改</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintableMixin</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.content, <span class="string">&#x27;Mixin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintableWord</span>(<span class="params">PrintableMixin, Word</span>):</span> <span class="keyword">pass</span> <span class="comment"># Mixin</span></span><br><span class="line">print(PrintableWord.__dict__)</span><br><span class="line">print(PrintableWord.mro())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printable</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_print</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.content, <span class="string">&#x27;装饰器&#x27;</span>)</span><br><span class="line">    cls.<span class="built_in">print</span> = _print</span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@printable # 装饰器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintablePdf</span>(<span class="params">Pdf</span>):</span> <span class="keyword">pass</span></span><br><span class="line">print(PrintablePdf.__dict__)</span><br><span class="line">print(PrintablePdf.mro())</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="comment"># [&lt;class &#x27;__main__.PrintableWord&#x27;&gt;, &lt;class &#x27;__main__.PrintableMixin&#x27;&gt;, &lt;class &#x27;__main__.Word&#x27;&gt;, &lt;class &#x27;__main__.Document&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;print&#x27;: &lt;function printable.&lt;locals&gt;._print at 0x00000296D46099D8&gt;&#125;</span></span><br><span class="line"><span class="comment"># [&lt;class &#x27;__main__.PrintablePdf&#x27;&gt;, &lt;class &#x27;__main__.Pdf&#x27;&gt;, &lt;class &#x27;__main__.Document&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span></span><br></pre></td></tr></table></figure>
<p>Mixin就是其它类混合进来，同事带来了类的属性和方法。<br />
这里看来Mixin类和装饰器效果一样，但是Mixin是类，就可以继承。</p>
<p>Mixin类本质上就是多继承实现的。<br />
Mixin体现的是一种组合的设计模式。</p>
<p>在面向对象的设计中，一个复杂的类，往往需要很多功能，而这些功能有来自不同的类提供，这就需要很多的类组合在一起。<br />
从设计模式的角度来说，多组合，少继承。</p>
<p>Mixin类的使用原则：</p>
<ul>
<li>Mixin类中不应该显式的出现__init__初始化方法。</li>
<li>Mixin类通常不能独立工作，因为它是准备混入别的类中的部分功能实现。</li>
<li>Mixin类的祖先类也应是Mixin类。</li>
</ul>
<p>使用时，Mixin类通常在继承列表的<code>第一个位置</code>，例如<code>class PrintableWord(PrintableMixin, Word): pass</code></p>
<p>Mixin类和装饰器，这两种方式都可以使用，看个人喜好。<br />
如果还需要继承就得使用Mixin类的方式。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\09\Python\00.Python-pdb\" rel="bookmark">Python-pdb调试器</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\13\Python\03.Python-字符串\" rel="bookmark">Python-字符串</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\12\Python\02.Python-列表、元组\" rel="bookmark">Python-列表、元组</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\15\Python\05.Python-封装解构、切片\" rel="bookmark">Python-切片、封装解构</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\14\Python\04.Python-集合\" rel="bookmark">Python-集合</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>SoundMemories
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://soundmemories.github.io/2019/01/25/Python/13.Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" title="Python-面向对象-基础">https://soundmemories.github.io/2019/01/25/Python/13.Python-面向对象基础/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"><i class="fa fa-tag"></i> Python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/01/23/Python/12.Python-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" rel="prev" title="Python-文件操作">
                  <i class="fa fa-chevron-left"></i> Python-文件操作
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/01/31/Python/14.Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/" rel="next" title="Python-面向对象-进阶">
                  Python-面向对象-进阶 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SoundMemories</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>








<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  








    <div class="pjax">
  

  
      <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">


  
  <script src="//cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://soundmemories.github.io/2019/01/25/Python/13.Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/',]
      });
      });
  </script>

    </div>
</body>
</html>
