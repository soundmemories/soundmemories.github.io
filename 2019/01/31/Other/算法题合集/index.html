<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"soundmemories.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":true,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="基础题001. 两数之和难度：简单题目链接：https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;two-sum&#x2F;题目描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。示例 1：输入：n">
<meta property="og:type" content="article">
<meta property="og:title" content="算法题">
<meta property="og:url" content="https://soundmemories.github.io/2019/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/index.html">
<meta property="og:site_name" content="SoundMemories">
<meta property="og:description" content="基础题001. 两数之和难度：简单题目链接：https:&#x2F;&#x2F;leetcode.cn&#x2F;problems&#x2F;two-sum&#x2F;题目描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。示例 1：输入：n">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-01-30T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-19T06:01:22.142Z">
<meta property="article:author" content="SoundMemories">
<meta property="article:tag" content="Other">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://soundmemories.github.io/2019/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法题 | SoundMemories</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SoundMemories</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
	   
		  
      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">基础题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.1.</span> <span class="nav-text">001. 两数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.</span> <span class="nav-text">169. 多数元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#540-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0"><span class="nav-number">1.3.</span> <span class="nav-text">540. 有序数组中的单一元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#041-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">041. 缺失的第一个正数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="nav-number">1.5.</span> <span class="nav-text">415. 字符串相加</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="nav-number">1.6.</span> <span class="nav-text">014. 最长公共前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#151-%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-number">1.7.</span> <span class="nav-text">151. 颠倒字符串中的单词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#557-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-III"><span class="nav-number">1.8.</span> <span class="nav-text">557. 反转字符串中的单词 III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#859-%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.9.</span> <span class="nav-text">859. 亲密字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#468-%E9%AA%8C%E8%AF%81IP%E5%9C%B0%E5%9D%80"><span class="nav-number">1.10.</span> <span class="nav-text">468. 验证IP地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.11.</span> <span class="nav-text">088. 合并两个有序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.12.</span> <span class="nav-text">021. 合并两个有序链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-number">1.13.</span> <span class="nav-text">1290. 二进制链表转整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">1.14.</span> <span class="nav-text">083. 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#082-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="nav-number">1.15.</span> <span class="nav-text">082. 删除排序链表中的重复元素 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-I"><span class="nav-number">1.16.</span> <span class="nav-text">002. 两数相加 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="nav-number">1.17.</span> <span class="nav-text">445. 两数相加 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.18.</span> <span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">1.19.</span> <span class="nav-text">092. 反转链表 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#025-K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.20.</span> <span class="nav-text">025. K 个一组翻转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">1.21.</span> <span class="nav-text">138. 复制带随机指针的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">1.22.</span> <span class="nav-text">560. 和为 K 的子数组(前缀和)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#020-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">1.23.</span> <span class="nav-text">020. 有效的括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">1.24.</span> <span class="nav-text">150. 逆波兰表达式求值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#772-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8%E2%85%A2"><span class="nav-number">1.25.</span> <span class="nav-text">772. 基本计算器Ⅲ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#032-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-number">1.26.</span> <span class="nav-text">032. 最长有效括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0"><span class="nav-number">1.27.</span> <span class="nav-text">204. 计数质数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">1.28.</span> <span class="nav-text">189. 轮转数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#054-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">1.29.</span> <span class="nav-text">054. 螺旋矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#048-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">1.30.</span> <span class="nav-text">048. 旋转图像</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">2.1.</span> <span class="nav-text">912. 排序数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.</span> <span class="nav-text">215. 数组中的第K个最大元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">148. 排序链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">2.4.</span> <span class="nav-text">二维数组中的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">2.5.</span> <span class="nav-text">数组中的逆序对</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">3.</span> <span class="nav-text">二分搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">3.1.</span> <span class="nav-text">704. 二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#069-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-number">3.2.</span> <span class="nav-text">069. x 的平方根</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#034-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E9%A6%96%E6%9C%AB%E4%BD%8D%E7%BD%AE"><span class="nav-number">3.3.</span> <span class="nav-text">034. 排序数组中查找元素的首末位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#875-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82"><span class="nav-number">3.4.</span> <span class="nav-text">875. 爱吃香蕉的珂珂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1011-%E5%9C%A8D%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">3.5.</span> <span class="nav-text">1011. 在D天内送达包裹的能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">3.6.</span> <span class="nav-text">162. 寻找峰值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">3.7.</span> <span class="nav-text">旋转数组的最小数字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="nav-number">4.1.</span> <span class="nav-text">146. LRU 缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#460-LFU-%E7%BC%93%E5%AD%98"><span class="nav-number">4.2.</span> <span class="nav-text">460. LFU 缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">4.3.</span> <span class="nav-text">232. 用栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">4.4.</span> <span class="nav-text">295. 数据流的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#341-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.5.</span> <span class="nav-text">341. 扁平化嵌套列表迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#855-%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7"><span class="nav-number">4.6.</span> <span class="nav-text">855. 考场就座</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%90%91%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">4.7.</span> <span class="nav-text">前向最大匹配算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D-%E4%B8%AD-%E5%90%8E-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-144-094-145-102"><span class="nav-number">5.1.</span> <span class="nav-text">前&#x2F;中&#x2F;后&#x2F;层序遍历(144&#x2F;094&#x2F;145&#x2F;102)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-I-II-III"><span class="nav-number">5.2.</span> <span class="nav-text">从上到下打印二叉树 I&#x2F;II&#x2F;III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.</span> <span class="nav-text">树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number">5.4.</span> <span class="nav-text">100. 相同的树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.5.</span> <span class="nav-text">617. 合并二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.6.</span> <span class="nav-text">101. 对称二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E9%95%9C%E5%83%8F"><span class="nav-number">5.7.</span> <span class="nav-text">226. 翻转二叉树(镜像)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.8.</span> <span class="nav-text">110. 平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.9.</span> <span class="nav-text">654. 最大二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#112-113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-I-II"><span class="nav-number">5.10.</span> <span class="nav-text">112&#x2F;113. 路径总和 I&#x2F;II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">5.11.</span> <span class="nav-text">104. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#508-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C"><span class="nav-number">5.12.</span> <span class="nav-text">508. 出现次数最多的子树元素和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">5.13.</span> <span class="nav-text">297. 二叉树的序列化与反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.14.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">5.15.</span> <span class="nav-text">199. 二叉树的右视图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#098-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">5.16.</span> <span class="nav-text">098. 验证二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-number">5.17.</span> <span class="nav-text">700. 二叉搜索树中的搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">5.18.</span> <span class="nav-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">5.19.</span> <span class="nav-text">701. 二叉搜索树中的插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">5.20.</span> <span class="nav-text">450. 删除二叉搜索树中的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#235-236-%E4%BA%8C%E5%8F%89-%E6%90%9C%E7%B4%A2%E6%A0%91-%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">5.21.</span> <span class="nav-text">235&#x2F;236. 二叉(搜索树)的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">5.22.</span> <span class="nav-text">二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#958-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C"><span class="nav-number">5.23.</span> <span class="nav-text">958. 二叉树的完全性检验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="nav-number">5.24.</span> <span class="nav-text">222. 完全二叉树的节点个数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">6.</span> <span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-number">6.1.</span> <span class="nav-text">155. 最小栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-I"><span class="nav-number">6.2.</span> <span class="nav-text">496. 下一个更大元素 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-II"><span class="nav-number">6.3.</span> <span class="nav-text">503. 下一个更大元素 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1019-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">6.4.</span> <span class="nav-text">1019. 链表中的下一个更大节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">6.5.</span> <span class="nav-text">739. 每日温度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#907-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="nav-number">6.6.</span> <span class="nav-text">907. 子数组的最小值之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#402-%E7%A7%BB%E6%8E%89-K-%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="nav-number">6.7.</span> <span class="nav-text">402. 移掉 K 位数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#768-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97-II"><span class="nav-number">6.8.</span> <span class="nav-text">768. 最多能完成排序的块 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#011-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">6.9.</span> <span class="nav-text">011. 盛最多水的容器(双指针)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#042-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">6.10.</span> <span class="nav-text">042. 接雨水</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#084-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E9%98%B5"><span class="nav-number">6.11.</span> <span class="nav-text">084. 柱状图中最大的矩阵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">7.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-%E6%99%AE%E9%80%9A"><span class="nav-number">7.1.</span> <span class="nav-text">160. 相交链表(普通)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7-%E6%99%AE%E9%80%9A"><span class="nav-number">7.2.</span> <span class="nav-text">165. 比较版本号(普通)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#026-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-%E5%BF%AB%E6%85%A2"><span class="nav-number">7.3.</span> <span class="nav-text">026. 删除有序数组中的重复项(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2"><span class="nav-number">7.4.</span> <span class="nav-text">141. 环形链表(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II-%E5%BF%AB%E6%85%A2"><span class="nav-number">7.5.</span> <span class="nav-text">142. 环形链表 II(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2"><span class="nav-number">7.6.</span> <span class="nav-text">234. 回文链表(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2"><span class="nav-number">7.7.</span> <span class="nav-text">143. 重排链表(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8-%E5%BF%AB%E6%85%A2"><span class="nav-number">7.8.</span> <span class="nav-text">328. 奇偶链表(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9-%E5%BF%AB%E6%85%A2"><span class="nav-number">7.9.</span> <span class="nav-text">019. 删除链表的倒数第N个节点(快慢)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%B7%A6%E5%8F%B3"><span class="nav-number">7.10.</span> <span class="nav-text">344. 反转字符串(左右)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%B7%A6%E5%8F%B3"><span class="nav-number">7.11.</span> <span class="nav-text">125. 验证回文串(左右)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%B7%A6%E5%8F%B3"><span class="nav-number">7.12.</span> <span class="nav-text">015. 三数之和(左右)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">8.</span> <span class="nav-text">滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">8.1.</span> <span class="nav-text">003. 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">8.2.</span> <span class="nav-text">239. 滑动窗口最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">8.3.</span> <span class="nav-text">567. 字符串的排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">8.4.</span> <span class="nav-text">438. 找到字符串中所有字母异位词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#076-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-number">8.5.</span> <span class="nav-text">076. 最小覆盖子串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">9.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="nav-number">9.1.</span> <span class="nav-text">509. 斐波那契数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">9.2.</span> <span class="nav-text">322. 零钱兑换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">9.3.</span> <span class="nav-text">746. 使用最小花费爬楼梯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#070-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">9.4.</span> <span class="nav-text">070. 爬楼梯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">9.5.</span> <span class="nav-text">120. 三角形最小路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#062-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">9.6.</span> <span class="nav-text">062. 不同路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#064-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">9.7.</span> <span class="nav-text">064. 最小路径和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">9.8.</span> <span class="nav-text">把数字翻译成字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#053-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">9.9.</span> <span class="nav-text">053. 最大子数组和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">9.10.</span> <span class="nav-text">300. 最长递增子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#673-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">9.11.</span> <span class="nav-text">673. 最长递增子序列的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">9.12.</span> <span class="nav-text">1143. 最长公共子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E4%B8%AA%E6%95%B0"><span class="nav-number">9.13.</span> <span class="nav-text">647. 回文子串(个数)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">9.14.</span> <span class="nav-text">005. 最长回文子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">9.15.</span> <span class="nav-text">516. 最长回文子序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1312-%E6%88%90%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0"><span class="nav-number">9.16.</span> <span class="nav-text">1312. 成为回文串的最少插入次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#072-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">9.17.</span> <span class="nav-text">072. 编辑距离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98"><span class="nav-number">9.18.</span> <span class="nav-text">354. 俄罗斯套娃信封问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#010-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">9.19.</span> <span class="nav-text">010. 正则表达式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD"><span class="nav-number">9.20.</span> <span class="nav-text">887. 鸡蛋掉落</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#312-%E6%88%B3%E6%B0%94%E7%90%83"><span class="nav-number">9.21.</span> <span class="nav-text">312. 戳气球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">9.22.</span> <span class="nav-text">198. 打家劫舍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="nav-number">9.23.</span> <span class="nav-text">213. 打家劫舍 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="nav-number">9.24.</span> <span class="nav-text">337. 打家劫舍 III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">9.25.</span> <span class="nav-text">121. 买卖股票的最佳时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1"><span class="nav-number">9.26.</span> <span class="nav-text">122. 买卖股票的最佳时机Ⅱ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A2"><span class="nav-number">9.27.</span> <span class="nav-text">123. 买卖股票的最佳时机Ⅲ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">9.28.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">9.29.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-II"><span class="nav-number">9.30.</span> <span class="nav-text">518. 零钱兑换 II</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83"><span class="nav-number">10.</span> <span class="nav-text">贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#056-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">10.1.</span> <span class="nav-text">056. 合并区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">10.2.</span> <span class="nav-text">409. 最长回文串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#055-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">10.3.</span> <span class="nav-text">055. 跳跃游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#045-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="nav-number">10.4.</span> <span class="nav-text">045. 跳跃游戏 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E6%8C%81%E4%BA%BA%E8%B0%83%E5%BA%A6%E2%85%A1"><span class="nav-number">10.5.</span> <span class="nav-text">主持人调度Ⅱ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%B3%96%E6%9E%9C%E9%97%AE%E9%A2%98"><span class="nav-number">10.6.</span> <span class="nav-text">分糖果问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">11.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98"><span class="nav-number">11.1.</span> <span class="nav-text">汉诺塔问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#969-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F"><span class="nav-number">11.2.</span> <span class="nav-text">969. 煎饼排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-DFS"><span class="nav-number">12.</span> <span class="nav-text">回溯&#x2F;DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#046-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">12.1.</span> <span class="nav-text">046. 全排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#047-%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="nav-number">12.2.</span> <span class="nav-text">047. 全排列 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#078-%E5%AD%90%E9%9B%86"><span class="nav-number">12.3.</span> <span class="nav-text">078. 子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#090-%E5%AD%90%E9%9B%86-II"><span class="nav-number">12.4.</span> <span class="nav-text">090. 子集 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#077-%E7%BB%84%E5%90%88"><span class="nav-number">12.5.</span> <span class="nav-text">077. 组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#039-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">12.6.</span> <span class="nav-text">039. 组合总和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#040-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-number">12.7.</span> <span class="nav-text">040. 组合总和 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#022-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">12.8.</span> <span class="nav-text">022. 括号生成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">12.9.</span> <span class="nav-text">200. 岛屿数量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#093-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="nav-number">12.10.</span> <span class="nav-text">093. 复原 IP 地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#051-N-%E7%9A%87%E5%90%8E"><span class="nav-number">12.11.</span> <span class="nav-text">051. N 皇后</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#329-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84"><span class="nav-number">12.12.</span> <span class="nav-text">329. 矩阵中的最长递增路径</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS"><span class="nav-number">13.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">13.1.</span> <span class="nav-text">111. 二叉树的最小深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#752-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81"><span class="nav-number">13.2.</span> <span class="nav-text">752. 打开转盘锁</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SoundMemories"
      src="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
  <p class="site-author-name" itemprop="name">SoundMemories</p>
  <div class="site-description" itemprop="description">今日事，今日毕</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">118</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvdW5kbWVtb3JpZXM=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soundmemories"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNvdW5kbWVtb3JpZXNAMTYzLmNvbQ==" title="E-Mail → mailto:soundmemories@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2019/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-31 00:00:00" itemprop="dateCreated datePublished" datetime="2019-01-31T00:00:00+08:00">2019-01-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Other/" itemprop="url" rel="index"><span itemprop="name">Other</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>157k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:22</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h2 id="001-两数之和"><a href="#001-两数之和" class="headerlink" title="001. 两数之和"></a>001. 两数之和</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLw==">https://leetcode.cn/problems/two-sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。<br>示例 1：<br>输入：<code>nums = [2,7,11,15], target = 9</code><br>输出：<code>[0,1]</code><br>解释：因为 <code>nums[0] + nums[1] == 9</code> ，返回 <code>[0, 1]</code> 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用hmap记录&#123;target-num:下标&#125;，时间复杂度O(1)。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hmap, res = &#123;&#125;, []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            val = target-nums[i]</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">in</span> hmap: res.extend([hmap[val], i])</span><br><span class="line">            hmap[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYWpvcml0eS1lbGVtZW50Lw==">https://leetcode.cn/problems/majority-element/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        hmap, half = &#123;&#125;, <span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            hmap[num] = hmap.get(num, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> hmap[num] &gt; half: <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure></p>
<h2 id="540-有序数组中的单一元素"><a href="#540-有序数组中的单一元素" class="headerlink" title="540. 有序数组中的单一元素"></a>540. 有序数组中的单一元素</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaW5nbGUtZWxlbWVudC1pbi1hLXNvcnRlZC1hcnJheS9zdWJtaXNzaW9ucy8=">https://leetcode.cn/problems/single-element-in-a-sorted-array/submissions/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。请你找出并返回只出现一次的那个数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNonDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        hmap, res = &#123;&#125;, []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            hmap[num] = hmap.get(num,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> hmap:</span><br><span class="line">            <span class="keyword">if</span> hmap[key]==<span class="number">1</span>: <span class="keyword">return</span> key</span><br></pre></td></tr></table></figure></p>
<h2 id="041-缺失的第一个正数"><a href="#041-缺失的第一个正数" class="headerlink" title="041. 缺失的第一个正数"></a>041. 缺失的第一个正数</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maXJzdC1taXNzaW5nLXBvc2l0aXZlLw==">https://leetcode.cn/problems/first-missing-positive/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        hmap, n = &#123;&#125;, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            hmap[num] = hmap.get(num,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 正整数从1开始找，遇到缺失/结束，即为最小正整数</span></span><br><span class="line">        res = <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">while</span> res <span class="keyword">in</span> hmap:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtc3RyaW5ncy8=">https://leetcode.cn/problems/add-strings/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addStrings</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        模拟加法运算过程。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j, sums, res = <span class="built_in">len</span>(num1)<span class="number">-1</span>, <span class="built_in">len</span>(num2)<span class="number">-1</span>, <span class="number">0</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> <span class="keyword">or</span> j&gt;=<span class="number">0</span> <span class="keyword">or</span> sums!=<span class="number">0</span>):</span><br><span class="line">            sums += (<span class="built_in">int</span>(num1[i]) <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>) + (<span class="built_in">int</span>(num2[j]) <span class="keyword">if</span> j &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            res = <span class="built_in">str</span>(sums % <span class="number">10</span>) + res</span><br><span class="line">            sums = sums // <span class="number">10</span></span><br><span class="line">            i, j = i<span class="number">-1</span>, j<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="014-最长公共前缀"><a href="#014-最长公共前缀" class="headerlink" title="014. 最长公共前缀"></a>014. 最长公共前缀</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbW1vbi1wcmVmaXgv">https://leetcode.cn/problems/longest-common-prefix/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzI4ZWIzMTc1NDg4ZjQ0MzRhNGE2MjA3ZjZmNDg0ZjQ3">BM84 最长公共前缀<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br>示例 1：<br>输入：<code>strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</code><br>输出：<code>&quot;fl&quot;</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        以0位字符串为基准，和其余字符串对比每个字符，直到不相同结束。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(strs)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(strs[<span class="number">0</span>])):  </span><br><span class="line">            temp = strs[<span class="number">0</span>][i]  </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):  </span><br><span class="line">                <span class="comment"># 比较每个字符串该位置是否和第一个相同</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;=<span class="built_in">len</span>(strs[j]) <span class="keyword">or</span> strs[j][i]!=temp:</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>][<span class="number">0</span>:i]  <span class="comment"># 不相同则结束</span></span><br><span class="line">        <span class="comment"># 后续字符串有整个字一个字符串的前缀</span></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="151-颠倒字符串中的单词"><a href="#151-颠倒字符串中的单词" class="headerlink" title="151. 颠倒字符串中的单词"></a>151. 颠倒字符串中的单词</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXdvcmRzLWluLWEtc3RyaW5nLw==">https://leetcode.cn/problems/reverse-words-in-a-string/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlL2MzMTIwYzFjMWJjNDRhZDk4NjI1OWMwY2YwZjBiODBl">BM83 字符串变形<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给你一个字符串 s ，颠倒字符串中 单词 的顺序。BM83：把这个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。<br>示例 1：<br>输入：<code>s = &quot;the sky is blue&quot;</code><br>输出：<code>&quot;blue is sky the&quot;</code></p>
<p>示例1：<br>输入：<code>&quot;This is a sample&quot;,16</code><br>返回值：<code>&quot;SAMPLE A IS tHIS&quot;</code></p>
<div class="tabs" id="151"><ul class="nav-tabs"><li class="tab active"><a href="#151-1">151</a></li><li class="tab"><a href="#151-2">BM83</a></li></ul><div class="tab-content"><div class="tab-pane active" id="151-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="comment"># 按空格切分-&gt;单词逆序-&gt;拼接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="built_in">reversed</span>(s.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">        <span class="comment"># 整体逆序-&gt;每个单词逆序-&gt;拼接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join([word[::<span class="number">-1</span>] <span class="keyword">for</span> word <span class="keyword">in</span> s[::<span class="number">-1</span>].split(<span class="string">&quot; &quot;</span>)])</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="151-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trans</span>(<span class="params">self , s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先转换大小写，再翻转顺序。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>: <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 大小写转换</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> s[i].isalpha() <span class="keyword">and</span> s[i].islower():</span><br><span class="line">                res += s[i].upper()</span><br><span class="line">            <span class="keyword">elif</span> s[i].isalpha() <span class="keyword">and</span> s[i].isupper():</span><br><span class="line">                res += s[i].lower()</span><br><span class="line">            <span class="keyword">else</span>: res += s[i]  <span class="comment"># 空格/tab 直接复制</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(<span class="built_in">reversed</span>(res.split(<span class="string">&#x27; &#x27;</span>)))  <span class="comment"># 单词反序</span></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a>557. 反转字符串中的单词 III</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS13b3Jkcy1pbi1hLXN0cmluZy1paWkv">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。<br>示例 1：<br>输入：<code>s = &quot;Let&#39;s take LeetCode contest&quot;</code><br>输出：<code>&quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</code><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS13b3Jkcy1pbi1hLXN0cmluZy1paWkvc29sdXRpb24vcHl0aG9uLWZhbi16aHVhbi16aS1mdS1jaHVhbi16aG9uZy1kYW4tY2ktc2ktbHUteGkv">Swants题解<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="comment"># 按空格切分-&gt;每个字符串反转-&gt;拼接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(word[::<span class="number">-1</span>] <span class="keyword">for</span> word <span class="keyword">in</span> s.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">        <span class="comment"># 先反转单词列表 再反转字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s.split(<span class="string">&quot; &quot;</span>)[::<span class="number">-1</span>])[::<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 先反转字符串，再反转单词列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(s[::<span class="number">-1</span>].split(<span class="string">&quot; &quot;</span>)[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="859-亲密字符串"><a href="#859-亲密字符串" class="headerlink" title="859. 亲密字符串"></a>859. 亲密字符串</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYnVkZHktc3RyaW5ncy8=">https://leetcode-cn.com/problems/buddy-strings/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<br>给你两个字符串 <code>s</code> 和 <code>goal</code> ，只要我们可以通过交换 <code>s</code> 中的两个字母得到与 <code>goal</code> 相等的结果，就返回 <code>true</code> ；否则返回 <code>false</code> 。<br>交换字母的定义是：取两个下标 <code>i</code> 和 <code>j</code> （下标从 0 开始）且满足 <code>i != j</code> ，接着交换 <code>s[i]</code> 和 <code>s[j]</code> 处的字符。<br>例如，在 “abcd” 中交换下标 0 和下标 2 的元素可以生成 “cbad” 。</p>
<p>示例 1：<br>输入：<code>s = &quot;ab&quot;, goal = &quot;ba&quot;</code><br>输出：<code>true</code><br>解释：你可以交换 s[0] = ‘a’ 和 s[1] = ‘b’ 生成 “ba”，此时 s 和 goal 相等。</p>
<p><strong>题目解析</strong>：</p>
<ol>
<li>字符串A、B满足条件且长度相等；</li>
<li>A、B字符串相同时，A或B字符串去重后长度比原来小；</li>
<li>A、B字符串不相同的位置字符zip成元组放在列表中，因为只交换一次，所以列表长度必为2，且2个元组为对称关系；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span>(<span class="params">self, A: <span class="built_in">str</span>, B: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># A和B长度必须相等，不相等返回false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(A)!=<span class="built_in">len</span>(B) : <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># A和B相同时，如果A去重后长度比原来小，返回True</span></span><br><span class="line">        <span class="keyword">if</span> A == B <span class="keyword">and</span> <span class="built_in">len</span>(<span class="built_in">set</span>(A)) &lt; <span class="built_in">len</span>(A): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 使用zip组合A、B中同位置不相等的字符</span></span><br><span class="line">        dif = [(a,b) <span class="keyword">for</span> a,b <span class="keyword">in</span> <span class="built_in">zip</span>(A,B) <span class="keyword">if</span> a != b]</span><br><span class="line">        <span class="comment"># 因为只交换一次，所以dif长度只能是2，且2个元组为对称关系</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(dif) == <span class="number">2</span> <span class="keyword">and</span> dif[<span class="number">0</span>] == dif[<span class="number">1</span>][::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="468-验证IP地址"><a href="#468-验证IP地址" class="headerlink" title="468. 验证IP地址"></a>468. 验证IP地址</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1pcC1hZGRyZXNzLw==">https://leetcode.cn/problems/validate-ip-address/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<br>给定一个字符串 <code>queryIP</code>。如果是有效的 IPv4 地址，返回 <code>&quot;IPv4&quot;</code> ；如果是有效的 IPv6 地址，返回 <code>&quot;IPv6&quot;</code> ；如果不是上述类型的 IP 地址，返回 <code>&quot;Neither&quot;</code> 。</p>
<p>有效的IPv4地址 是 <code>“x1.x2.x3.x4”</code> 形式的IP地址。 其中 <code>0 &lt;= xi &lt;= 255</code> 且 <code>xi</code> 不能包含 前导零。例如: <code>“192.168.1.1”</code> 、 <code>“192.168.1.0”</code> 为有效IPv4地址， <code>“192.168.01.1”</code> 为无效IPv4地址; <code>“192.168.1.00”</code> 、 <code>“192.168@1.1”</code> 为无效IPv4地址。</p>
<p>有效的IPv6地址 是 <code>“x1:x2:x3:x4:x5:x6:x7:x8”</code> 形式的IP地址，其中 <code>1 &lt;= xi.length &lt;= 4</code>；<code>xi</code> 是一个 十六进制字符串 ，可以包含数字、小写英文字母( <code>&#39;a&#39;</code> 到 <code>&#39;f&#39;</code> )和大写英文字母( <code>&#39;A&#39;</code> 到 <code>&#39;F&#39;</code> )；在 <code>xi</code> 中允许前导零。例如 <code>&quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 和 <code>&quot;2001:db8:85a3:0:0:8A2E:0370:7334&quot;</code> 是有效的 IPv6 地址，而 <code>&quot;2001:0db8:85a3::8A2E:037j:7334&quot;</code> 和 <code>&quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334&quot;</code> 是无效的 IPv6 地址。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validIPAddress</span>(<span class="params">self, IP: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        IPv4只有十进制数和分割点，其中数字在0-255之间，共4组，且不能有零开头的非零数，不能缺省</span></span><br><span class="line"><span class="string">        IPv6由8组16进制数组成，会出现a-fA-F，通过冒号分割，不可缺省，可以零开头，或者为一个单独零，每组最多4位。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(IP) == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> IP.count(<span class="string">&#x27;.&#x27;</span>) == <span class="number">3</span>: <span class="keyword">return</span> self.isIPv4(IP)</span><br><span class="line">        <span class="keyword">elif</span> IP.count(<span class="string">&#x27;:&#x27;</span>) == <span class="number">7</span>: <span class="keyword">return</span> self.isIPv6(IP)</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIPv4</span> (<span class="params">self, IP:<span class="built_in">str</span></span>):</span></span><br><span class="line">        nums = IP.split(<span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># Validate integer in range (0, 255):</span></span><br><span class="line">            <span class="comment"># 1. length of chunk is between 1 and 3</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(x)==<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(x)&gt;<span class="number">3</span>: <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">            <span class="comment"># 2. no extra leading zeros</span></span><br><span class="line">            <span class="comment"># 3. only digits are allowed</span></span><br><span class="line">            <span class="comment"># 4. less than 255</span></span><br><span class="line">            <span class="keyword">if</span> (x[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(x)!=<span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">not</span> x.isdigit() <span class="keyword">or</span> <span class="built_in">int</span>(x)&gt;<span class="number">255</span>: <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIPv6</span> (<span class="params">self, IP:<span class="built_in">str</span></span>):</span></span><br><span class="line">        nums = IP.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        hexdigits = <span class="string">&#x27;0123456789abcdefABCDEF&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># Validate hexadecimal in range (0, 2**16):</span></span><br><span class="line">            <span class="comment"># 1. at least one and not more than 4 hexdigits in one chunk</span></span><br><span class="line">            <span class="comment"># 2. only hexdigits are allowed: 0-9, a-f, A-F</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(x)==<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(x)&gt;<span class="number">4</span> <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">all</span>(c <span class="keyword">in</span> hexdigits <span class="keyword">for</span> c <span class="keyword">in</span> x): <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="088-合并两个有序数组"><a href="#088-合并两个有序数组" class="headerlink" title="088. 合并两个有序数组"></a>088. 合并两个有序数组</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1zb3J0ZWQtYXJyYXkv">https://leetcode.cn/problems/merge-sorted-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。<br>示例 1：<br>输入：<code>nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</code><br>输出：<code>[1,2,2,3,5,6]</code><br>解释：需要合并 <code>[1,2,3]</code> 和 <code>[2,5,6]</code> 。<br>合并结果是 <code>[1,2,2,3,5,6]</code> ，其中斜体加粗标注的为 nums1 中的元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        合并结果放到nums1中， nums1实际初始长度为m+n。</span></span><br><span class="line"><span class="string">        从后-&gt;前遍历，把大的放在nums1后面。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        a, b = m<span class="number">-1</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):  <span class="comment"># i指向nums1放入值位置</span></span><br><span class="line">            <span class="comment"># B数组用完了/(a数组没用完+A数组的数大)，就填A数组的数 </span></span><br><span class="line">            <span class="keyword">if</span> b&lt;<span class="number">0</span> <span class="keyword">or</span> a&gt;=<span class="number">0</span> <span class="keyword">and</span> nums1[a]&gt;=nums2[b]:</span><br><span class="line">                nums1[i]=nums1[a]</span><br><span class="line">                a=a<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[i]=nums2[b]</span><br><span class="line">                b=b<span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="021-合并两个有序链表"><a href="#021-合并两个有序链表" class="headerlink" title="021. 合并两个有序链表"></a>021. 合并两个有序链表</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLXNvcnRlZC1saXN0cy8=">https://leetcode-cn.com/problems/merge-two-sorted-lists/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：将两个<strong>升序链表</strong>合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例 1：<br>输入：<code>l1 = [1,2,4], l2 = [1,3,4]</code><br>输出：<code>[1,1,2,3,4,4]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: Optional[ListNode], list2: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        cur = newlist = ListNode(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt; list2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = list1</span><br><span class="line">                list1 = list1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = list2</span><br><span class="line">                list2 = list2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        cur.<span class="built_in">next</span> = list1 <span class="keyword">if</span> list1 <span class="keyword">else</span> list2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newlist.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="1290-二进制链表转整数"><a href="#1290-二进制链表转整数" class="headerlink" title="1290. 二进制链表转整数"></a>1290. 二进制链表转整数</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udmVydC1iaW5hcnktbnVtYmVyLWluLWEtbGlua2VkLWxpc3QtdG8taW50ZWdlci8=">https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个单链表的引用结点 <code>head</code>。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。请你返回该链表所表示数字的 <strong>十进制值</strong> 。</p>
<p>示例 1：<br>输入：<code>head = [1,0,1]</code><br>输出：<code>5</code><br>解释：二进制数 (101) 转化为十进制数 (5)</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udmVydC1iaW5hcnktbnVtYmVyLWluLWEtbGlua2VkLWxpc3QtdG8taW50ZWdlci9zb2x1dGlvbi9lci1qaW4temhpLWxpYW4tYmlhby16aHVhbi16aGVuZy1zaHUtYnktbGVldGNvZGUtcy8=">官方题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDecimalValue</span>(<span class="params">self, head: ListNode</span>) -&gt; int:</span></span><br><span class="line">        cur = head</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur: </span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            # 二进制方法</span></span><br><span class="line"><span class="string">            # 左移n位==乘2^n，| 按位或</span></span><br><span class="line"><span class="string">            ans = ans&lt;&lt;1 | cur.val</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            ans = ans * <span class="number">2</span> + cur.val <span class="comment"># 十进制方法</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="083-删除排序链表中的重复元素"><a href="#083-删除排序链表中的重复元素" class="headerlink" title="083. 删除排序链表中的重复元素"></a>083. 删除排序链表中的重复元素</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1saXN0Lw==">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。<br>示例 1：<br>输入：<code>head = [1,1,2]</code><br>输出：<code>[1,2]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p>
<h2 id="082-删除排序链表中的重复元素-II"><a href="#082-删除排序链表中的重复元素-II" class="headerlink" title="082. 删除排序链表中的重复元素 II"></a>082. 删除排序链表中的重复元素 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtbGlzdC1paS8=">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。<br>示例 1：<br>输入：<code>head = [1,2,3,3,4,4,5]</code><br>输出：<code>[1,2,5]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtbGlzdC1paS9zb2x1dGlvbi84Mi1weXRob25zaHVhbmctemhpLXpoZW4tZmEtYnktbHVsbGFieS8=">Lullaby题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line">        pre = dummy = ListNode(<span class="number">-1</span>,head) <span class="comment"># 防止head被删除，增加一个哑节点</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 跳过重复节点，cur停在最后一个重复元素</span></span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.val == cur.<span class="built_in">next</span>.val: cur = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># pre和cur之间没有重复节点，pre后移</span></span><br><span class="line">            <span class="keyword">if</span> pre.<span class="built_in">next</span> == cur: pre = pre.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># pre和cur之间有重复节点，跳过重复节点</span></span><br><span class="line">            <span class="keyword">elif</span> pre.<span class="built_in">next</span> != cur: pre.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="002-两数相加-I"><a href="#002-两数相加-I" class="headerlink" title="002. 两数相加 I"></a>002. 两数相加 I</h2><p><strong>难度</strong>：中等<br><strong>题⽬链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkLXR3by1udW1iZXJzLw==">https://leetcode-cn.com/problems/add-two-numbers/<i class="fa fa-external-link-alt"></i></span><br><strong>题⽬描述</strong>：给出两个 <strong>⾮空</strong> 的链表⽤来表示两个非负的整数。其中，它们各⾃的位数是按照 <strong>逆序</strong> 的⽅式存储的，并且它们的每个节点只能存储 <strong>⼀位</strong> 数字。如果，我们将这两个数相加起来，则会返回⼀个新的链表来表示它们的和您可以假设除了数字 <code>0</code> 之外，这两个数都不会以 <code>0</code> 开头。</p>
<p>示例：<br>输⼊：<code>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code><br>输出：<code>7 -&gt; 0 -&gt; 8</code><br>原因：<code>342 + 465 = 807</code></p>
<a id="more"></a> 
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkLXR3by1udW1iZXJzL3NvbHV0aW9uL2xpYW5nLXNodS14aWFuZy1qaWEtYnktbGVldGNvZGUv">官方题解<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        dummy = cur = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span> <span class="comment"># 按位相加结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 两链表为空时退出</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> <span class="built_in">sum</span>:</span><br><span class="line">            <span class="comment"># 取相同位的值相加，某一链表当前位为空时用0去计算</span></span><br><span class="line">            <span class="built_in">sum</span> += (l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span>) + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 当前节点值为/10的余数，链表起始为None下一位</span></span><br><span class="line">            cur.<span class="built_in">next</span> = ListNode(<span class="built_in">sum</span> % <span class="number">10</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span> <span class="comment"># 移动指针</span></span><br><span class="line">            <span class="comment"># 更新进位值</span></span><br><span class="line">            <span class="built_in">sum</span> //= <span class="number">10</span></span><br><span class="line">            <span class="comment"># 某一链表为空，不next</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkLXR3by1udW1iZXJzLWlpLw==">https://leetcode-cn.com/problems/add-two-numbers-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字<strong>最高位位于链表开始位置</strong>。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 <code>0</code> 之外，这两个数字都不会以零开头。和 <strong>两数相加 I</strong> 区别是数字 <strong>非逆序</strong> 存储。</p>
<p>示例1：<br>输入：<code>l1 = [7,2,4,3], l2 = [5,6,4]</code><br>输出：<code>[7,8,0,7]</code></p>
<p><strong>题目解析</strong>：</p>
<ol>
<li>在 <strong>2.两数相加</strong> 基础上使用2次反转链表。</li>
<li>使用栈（先进后出） + 头插法。</li>
</ol>
<div class="tabs" id="445"><ul class="nav-tabs"><li class="tab active"><a href="#445-1">反转链表</a></li><li class="tab"><a href="#445-2">栈+头插法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="445-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 如果链表 非逆序，需要先逆序</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">head</span>):</span></span><br><span class="line">            cur = head</span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">        l1 = reverse(l1)</span><br><span class="line">        l2 = reverse(l2)</span><br><span class="line">        dummy = cur = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span> <span class="comment"># 按位相加结果</span></span><br><span class="line">        <span class="comment"># 两链表为空时退出</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> <span class="built_in">sum</span>:</span><br><span class="line">            <span class="comment"># 取相同位的值相加，某一链表当前位为空时用0去计算</span></span><br><span class="line">            <span class="built_in">sum</span> += (l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span>) + (l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 当前节点值为/10的余数，链表起始为None下一位</span></span><br><span class="line">            cur.<span class="built_in">next</span> = ListNode(<span class="built_in">sum</span> % <span class="number">10</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span> <span class="comment"># 移动指针</span></span><br><span class="line">            <span class="comment"># 更新进位值</span></span><br><span class="line">            <span class="built_in">sum</span> //= <span class="number">10</span></span><br><span class="line">            <span class="comment"># 某一链表为空，不next</span></span><br><span class="line">            l1 = l1.<span class="built_in">next</span> <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.<span class="built_in">next</span> <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverse(dummy.<span class="built_in">next</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="445-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        a,b = [],[]</span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            a.append(l1.val)</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            b.append(l2.val)</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> a <span class="keyword">or</span> b <span class="keyword">or</span> <span class="built_in">sum</span>:</span><br><span class="line">            <span class="built_in">sum</span> += (a.pop() <span class="keyword">if</span> a <span class="keyword">else</span> <span class="number">0</span>) + (b.pop() <span class="keyword">if</span> b <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 头插法</span></span><br><span class="line">            cur = ListNode(<span class="built_in">sum</span> % <span class="number">10</span>)</span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sum</span> //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">https://leetcode-cn.com/problems/reverse-linked-list/<i class="fa fa-external-link-alt"></i></span> ，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmFuLXpodWFuLWxpYW4tYmlhby1sY29mLw==">剑指offer 面试题24<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：<br>输入：<code>head = [1,2,3,4,5]</code><br>输出：<code>[5,4,3,2,1]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC9zb2x1dGlvbi9kb25nLWh1YS15YW4tc2hpLTIwNi1mYW4temh1YW4tbGlhbi1iaWFvLWJ5LXVzZXI3NC8=">wang_ni_ma题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 申请两个节点，pre和 cur，pre指向None</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 记录当前节点的下一个节点</span></span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 然后将当前节点指向pre</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            <span class="comment"># pre和cur节点都前进一位</span></span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></p>
<h2 id="092-反转链表-II"><a href="#092-反转链表-II" class="headerlink" title="092. 反转链表 II"></a>092. 反转链表 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC1paS8=">https://leetcode-cn.com/problems/reverse-linked-list-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 反转后的链表 。<br>示例 1：<br>输入：<code>head = [1,2,3,4,5], left = 2, right = 4</code><br>输出：<code>[1,4,3,2,5]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        遍历到[left, right]的节点，每次都把当前节点(node)插到头部，结束即为 反转后的链表。</span></span><br><span class="line"><span class="string">        pre：left的前一个节点</span></span><br><span class="line"><span class="string">        cur：需要翻转的起始节点</span></span><br><span class="line"><span class="string">        node：第一个翻转节点</span></span><br><span class="line"><span class="string">        需要反转的次数：right-left</span></span><br><span class="line"><span class="string">        先断开node：cur和cur.next.next链接；再插入node：将cur.next插入pre后。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = dummy = ListNode(<span class="number">-1</span>, head)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left<span class="number">-1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right-left):</span><br><span class="line">            node = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="025-K-个一组翻转链表"><a href="#025-K-个一组翻转链表" class="headerlink" title="025. K 个一组翻转链表"></a>025. K 个一组翻转链表</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1ub2Rlcy1pbi1rLWdyb3VwLw==">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后<strong>剩余的节点保持原有顺序</strong>。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br>示例 1：<br>输入：<code>head = [1,2,3,4,5], k = 2</code><br>输出：<code>[2,1,4,3,5]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        长度为k的链表</span></span><br><span class="line"><span class="string">        tail：k翻转前的尾节点</span></span><br><span class="line"><span class="string">        hair：k翻转前的头节点(即k翻转后的尾节点)</span></span><br><span class="line"><span class="string">        cur：k翻转前的头节点前一个节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = tail = dummy = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        <span class="keyword">while</span> tail:</span><br><span class="line">            <span class="comment"># 找到k个节点的结尾</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):  </span><br><span class="line">                <span class="keyword">if</span> tail: tail = tail.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail: <span class="keyword">break</span>  <span class="comment"># k结尾为None，结束循环</span></span><br><span class="line">            <span class="comment"># 先断开</span></span><br><span class="line">            next_head = tail.<span class="built_in">next</span></span><br><span class="line">            tail.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 再翻转，pre为翻转后的尾节点</span></span><br><span class="line">            hair = cur.<span class="built_in">next</span> </span><br><span class="line">            cur.<span class="built_in">next</span> = self.reverse(hair)</span><br><span class="line">            <span class="comment"># 再接回</span></span><br><span class="line">            hair.<span class="built_in">next</span> = next_head</span><br><span class="line">            <span class="comment"># 更新下一轮</span></span><br><span class="line">            cur = tail = hair</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, head: ListNode</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        翻转链表，pre为反转后的头节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></p>
<h2 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a>138. 复制带随机指针的链表</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29weS1saXN0LXdpdGgtcmFuZG9tLXBvaW50ZXIv">https://leetcode-cn.com/problems/copy-list-with-random-pointer/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<br>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。<br>构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong>。<br>例如，如果原链表中有<code>X</code>和<code>Y</code>两个节点，其中<code>X.random -&gt; Y</code>。那么在复制链表中对应的两个节点<code>x</code>和<code>y</code>，同样有<code>x.random -&gt; y</code>。<br>返回复制链表的头节点。<br>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：<code>val</code>：一个表示 <code>Node.val</code> 的整数。<code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>你的代码 只 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<p>示例 1：<br>输入：<code>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</code><br>输出：<code>[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29weS1saXN0LXdpdGgtcmFuZG9tLXBvaW50ZXIvc29sdXRpb24vZnUtemhpLWRhaS1zdWktamktemhpLXpoZW4tZGUtbGlhbi1iaWFvLWJ5LWxlZXRjb2Qv">LeetCode官方题解<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>题目解析</strong>：迭代 + 节点拆分。</p>
<ol>
<li>判断空链表</li>
<li>复制节点+节点值</li>
<li>复制随机指针</li>
<li>拆分<br>时间复杂度$O(n)$，只需遍历3遍链表。<br>空间复杂度$O(1)$。</li>
</ol>
<div class="tabs" id="138"><ul class="nav-tabs"><li class="tab active"><a href="#138-1">2次迭代+哈希表</a></li><li class="tab"><a href="#138-2">3次迭代+拆分</a></li></ul><div class="tab-content"><div class="tab-pane active" id="138-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="comment"># 空链表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># &#123;旧节点:新节点...&#125; 哈希表</span></span><br><span class="line">        cur = head</span><br><span class="line">        hash_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            hash_map[cur] = Node(cur.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据旧节点找新节点，建立连接+复制随机指针</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># get方法找不到返回None，[&#x27;key&#x27;]方法找不到会报错</span></span><br><span class="line">            hash_map[cur].<span class="built_in">next</span> = hash_map.get(cur.<span class="built_in">next</span>)  </span><br><span class="line">            hash_map[cur].random = hash_map.get(cur.random)</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hash_map[head]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="138-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, x: int, next: &#x27;Node&#x27; = None, random: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = int(x)</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">        self.random = random</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="comment"># 空链表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:<span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 复制节点+节点值</span></span><br><span class="line">        ptr = head</span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line">            node = Node(ptr.val, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            node.<span class="built_in">next</span> = ptr.<span class="built_in">next</span></span><br><span class="line">            ptr.<span class="built_in">next</span> = node</span><br><span class="line">            ptr = node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 复制节点随机指针</span></span><br><span class="line">        ptr = head</span><br><span class="line">        <span class="keyword">while</span> ptr:</span><br><span class="line">            ptr.<span class="built_in">next</span>.random = ptr.random.<span class="built_in">next</span> <span class="keyword">if</span> ptr.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            ptr = ptr.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 拆分节点 A-&gt;A&#x27;-&gt;B-&gt;B&#x27;-&gt;C-&gt;C&#x27; 拆分成 A-&gt;B-&gt;C 和 A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">        old = head  <span class="comment"># A-&gt;B-&gt;C</span></span><br><span class="line">        new = head.<span class="built_in">next</span>  <span class="comment"># A&#x27;-&gt;B&#x27;-&gt;C&#x27;</span></span><br><span class="line">        head_new = head.<span class="built_in">next</span>  <span class="comment"># 必须是新的指针</span></span><br><span class="line">        <span class="keyword">while</span> old:</span><br><span class="line">            old.<span class="built_in">next</span> = old.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            new.<span class="built_in">next</span> = new.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">if</span> new.<span class="built_in">next</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            old = old.<span class="built_in">next</span></span><br><span class="line">            new = new.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head_new</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="560-和为-K-的子数组-前缀和"><a href="#560-和为-K-的子数组-前缀和" class="headerlink" title="560. 和为 K 的子数组(前缀和)"></a>560. 和为 K 的子数组(前缀和)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3ViYXJyYXktc3VtLWVxdWFscy1rLw==">https://leetcode-cn.com/problems/subarray-sum-equals-k/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 该数组中和为 <code>k</code> 的子数组的个数 。<br>示例 1：<br>输入：<code>nums = [1,1,1], k = 2</code><br>输出：<code>2</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        每次遇到“连续子数组的和”相关问题，都可以考虑前缀和是否能行。</span></span><br><span class="line"><span class="string">        sums比nums长度+1，考虑用sums[i]记录nums[0~i]的和，sums[j]-sums[i-1]得到nums[i~j]的和，</span></span><br><span class="line"><span class="string">        和为k，那么sums[j]-sums[i-1]==k，可得sums[i-1]==sums[j]-k，而sums[j]可由sums[j-1]+nums[i]得来，</span></span><br><span class="line"><span class="string">        可以使用一个变量sumsj记录，而不用数组。</span></span><br><span class="line"><span class="string">        hmap：&#123;前缀和:该前缀和出现次数&#125;</span></span><br><span class="line"><span class="string">        presum：前i个值的和</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hmap = &#123;&#125;</span><br><span class="line">        hmap[<span class="number">0</span>] = <span class="number">1</span>  <span class="comment"># 前缀和为0，算1次(只有1个元素且值为k)</span></span><br><span class="line">        sumsj, res = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            sumsj += nums[i]  <span class="comment"># sums[j]</span></span><br><span class="line">            sumsi_1 = sumsj - k  <span class="comment"># sums[i-1]</span></span><br><span class="line">            res += hmap.get(sumsi_1, <span class="number">0</span>)</span><br><span class="line">            hmap[sumsj] = hmap.get(sumsj, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="020-有效的括号"><a href="#020-有效的括号" class="headerlink" title="020. 有效的括号"></a>020. 有效的括号</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv">https://leetcode-cn.com/problems/valid-parentheses/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个只包括 <code>(</code>，<code>)</code>，<code>&#123;</code>，<code>&#125;</code>，<code>[</code>，<code>]</code> 的字符串 <code>s</code> ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。<br>示例 1：<br>输入：<code>s = &quot;()[]&#123;&#125;&quot;</code><br>输出：<code>true</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用栈，先进后出的性质，判断括号合法性。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) % <span class="number">2</span> == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        dic = &#123;<span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>,  <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="comment"># 左半，入栈</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> dic: stack.append(c)</span><br><span class="line">            <span class="comment"># 右半，出栈</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> stack <span class="keyword">or</span> dic[stack.pop()] != c: <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1yZXZlcnNlLXBvbGlzaC1ub3RhdGlvbi8=">https://leetcode.cn/problems/evaluate-reverse-polish-notation/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：根据 逆波兰表示法，求表达式的值。有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。注意 两个整数之间的除法只保留整数部分。可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ldmFsdWF0ZS1yZXZlcnNlLXBvbGlzaC1ub3RhdGlvbi9zb2x1dGlvbi94aWFuZy1qaWUtbmktYm8tbGFuLWJpYW8tZGEtc2hpLWZ1LWJlbi10LXNmbDYv">负雪明烛 题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">self, tokens: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用int()转整数，try-except处理运算符。</span></span><br><span class="line"><span class="string">        本题除法是向零取整的，python除法是向下取整，调整为向零取整：先按float除法得到值，再把值用int取整。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                stack.append(<span class="built_in">int</span>(token))</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                num2 = stack.pop()  <span class="comment"># 右操作数</span></span><br><span class="line">                num1 = stack.pop()  <span class="comment"># 左操作数</span></span><br><span class="line">                stack.append(self.evaluate(num1, num2, token))</span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params">self, num1, num2, op</span>):</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 + num2</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 - num2</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> num1 * num2</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(num1 / <span class="built_in">float</span>(num2))</span><br></pre></td></tr></table></figure></p>
<h2 id="772-基本计算器Ⅲ"><a href="#772-基本计算器Ⅲ" class="headerlink" title="772. 基本计算器Ⅲ"></a>772. 基本计算器Ⅲ</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYXNpYy1jYWxjdWxhdG9yLWlpaS8=">https://leetcode.cn/problems/basic-calculator-iii/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlL2MyMTViYTYxYzhiMTQ0M2I5OTYzNTFkZjkyOWRjNGQ0">BM49 表达式求值<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：请写一个整数计算器，支持 加减乘 三种运算和 括号。<br><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9EUXhNRE0wTXc9PSZhbXA7bWlkPTIyNDc0ODQ5MDMmYW1wO2lkeD0xJmFtcDtzbj0xODRiZWFhZDM2YTcxYzlhOGRkOTNjNDFhOGJhNzRhYyZhbXA7Y2hrc209OWJkN2ZiZWZhY2EwNzJmOWJlY2NmZjkyYTcxNWQ5MmVlOTBmNDZjMjk3Mjc3ZWVjMTBjMzIyYmM1Y2NkMDUzNDYwZGE2YWZiNzZjMiZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">labuladong 题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &quot;1+2&quot;看成&quot;+1+2&quot;，每个值带上前面符号放入栈中，最后求和(乘法/除法要计算一下再放入栈中)。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="built_in">list</span>(s))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, s: List</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        sign = <span class="string">&#x27;+&#x27;</span>  <span class="comment"># 默认第一个值为+</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; <span class="number">0</span>:</span><br><span class="line">            c = s.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> c.isdigit(): num = <span class="number">10</span> * num + <span class="built_in">int</span>(c)</span><br><span class="line">            <span class="comment"># 遇到左括号开始递归计算 num</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>: num = self.helper(s)</span><br><span class="line">            <span class="comment"># 遇到 符号(非数字、空格)/最后位置 时，把前面的 符号和值 一起放入栈中。</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> c.isdigit() <span class="keyword">and</span> c != <span class="string">&#x27; &#x27;</span>) <span class="keyword">or</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="string">&#x27;+&#x27;</span>: stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> sign == <span class="string">&#x27;-&#x27;</span>: stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> sign == <span class="string">&#x27;*&#x27;</span>: stack[<span class="number">-1</span>] = stack[<span class="number">-1</span>] * num</span><br><span class="line">                <span class="keyword">elif</span> sign == <span class="string">&#x27;/&#x27;</span>: stack[<span class="number">-1</span>] = <span class="built_in">int</span>(stack[<span class="number">-1</span>] / <span class="built_in">float</span>(num))  <span class="comment"># python除法向0取整的写法</span></span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                sign = c</span><br><span class="line">            <span class="comment"># 遇到右括号返回递归结果</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;)&#x27;</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(stack)</span><br></pre></td></tr></table></figure></p>
<h2 id="032-最长有效括号"><a href="#032-最长有效括号" class="headerlink" title="032. 最长有效括号"></a>032. 最长有效括号</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXZhbGlkLXBhcmVudGhlc2VzLw==">https://leetcode.cn/problems/longest-valid-parentheses/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res, st = <span class="number">0</span>, []</span><br><span class="line">        start = <span class="number">-1</span>  <span class="comment"># 记录上一次连续括号结束的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span>: st.append(i)  <span class="comment"># 左括号入栈</span></span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 右括号</span></span><br><span class="line">                <span class="comment"># 如果右括号时栈为空，不合法，设置为结束位置</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(st) == <span class="number">0</span>: start = i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    st.pop()  <span class="comment"># 弹出左括号</span></span><br><span class="line">                    <span class="comment"># 栈中还有左括号，说明右括号不够，减去栈顶位置就是长度</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(st) != <span class="number">0</span>: res = <span class="built_in">max</span>(res, i-st[<span class="number">-1</span>])</span><br><span class="line">                    <span class="comment"># 栈中没有括号，说明左右括号行号，减去上一次结束的位置就是长度</span></span><br><span class="line">                    <span class="keyword">else</span>: res = <span class="built_in">max</span>(res, i-start)   </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtcHJpbWVzLw==">https://leetcode-cn.com/problems/count-primes/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定整数 <code>n</code> ，返回 <strong>所有小于非负整数 n 的质数</strong>的数量 。<br>示例 1：<br>输入：<code>n = 10</code><br>输出：<code>4</code><br>解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">质数：也叫素数，只能被 1 和 它本身 整除。</span></span><br><span class="line"><span class="string">(1) 埃氏筛：如果一个数 x 是质数，那么它的倍数 2x,3x,4x...一定不是质数。</span></span><br><span class="line"><span class="string">(2) 计算[2~n]的质数个数,只需看[2~sqrt(n)]区间,之后的数都是镜像,比如 12=3*4,4*3, sqrt(12)为3.4, 从4往后就是前面的镜像了</span></span><br><span class="line"><span class="string">(3) 剔除 质数i 的倍数，不需要从头开始，因为在剔除之前的质数倍数时，把i^2前的都算过了。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 最小的质数是 2</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        isPrime = [<span class="literal">True</span>] * n</span><br><span class="line">        isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">False</span>   <span class="comment"># 0和1不是质数，先排除掉</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 埃式筛，把不大于根号 n 的所有 质数i 的倍数剔除</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(sqrt(n))+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> isPrime[i]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i^<span class="number">2</span>, n, i):  <span class="comment"># j为质数i的倍数</span></span><br><span class="line">                    isPrime[j] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(isPrime)</span><br></pre></td></tr></table></figure></p>
<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a>189. 轮转数组</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtYXJyYXkv">https://leetcode.cn/problems/rotate-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。<br>示例 1:<br>输入: <code>nums = [1,2,3,4,5,6,7], k = 3</code><br>输出: <code>[5,6,7,1,2,3,4]</code><br>解释:<br>向右轮转 1 步: <code>[7,1,2,3,4,5,6]</code><br>向右轮转 2 步: <code>[6,7,1,2,3,4,5]</code><br>向右轮转 3 步: <code>[5,6,7,1,2,3,4]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">不使用额外数组，因为是循环移动，可看成右移 m=k%n 次，按照这个把数组分成2部分，即abcdefg右移3位efgabcd可以看成AB翻转成BA。</span></span><br><span class="line"><span class="string">(1) 将整个数组翻转，得到数组的逆序，它已经满足了右移的整体出现在了左边。</span></span><br><span class="line"><span class="string">(2) 将左边的m个元素单独翻转，因为它虽然移到了左边，但是逆序了。</span></span><br><span class="line"><span class="string">(3) 将右边的n−m个元素单独翻转，因此这部分也逆序了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">reverse()就地翻转，非迭代器。</span></span><br><span class="line"><span class="string">reversed()非就地翻转，迭代器(不可切片等操作)。</span></span><br><span class="line"><span class="string">不能nums.reverse()再nums[:m].reverse()，因为就地翻转的是nums[:m]临时变量(结束时就没了)，</span></span><br><span class="line"><span class="string">需要借助中间变量存储nums[:m]，再.reverse()。</span></span><br><span class="line"><span class="string">不能nums=reversed(nums)再reversed(nums[:m])，因为reversed()惰性的，不会立即返回结果，无法[:m]切片。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = k % <span class="built_in">len</span>(nums)  <span class="comment"># 取余，因为每次长度为n的旋转数组相当于没有变化</span></span><br><span class="line">        nums.reverse()  <span class="comment"># 第一次逆转全部数组元素 </span></span><br><span class="line">        nums[:m] = <span class="built_in">reversed</span>(nums[:m])  <span class="comment"># 第二次只逆转开头m个</span></span><br><span class="line">        nums[m:] = <span class="built_in">reversed</span>(nums[m:])  <span class="comment"># 第三次只逆转结尾m个</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></p>
<h2 id="054-螺旋矩阵"><a href="#054-螺旋矩阵" class="headerlink" title="054. 螺旋矩阵"></a>054. 螺旋矩阵</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4Lw==">https://leetcode.cn/problems/spiral-matrix/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。<br>示例 1：<br>输入：<code>matrix = [[1,2,3],[4,5,6],[7,8,9]]</code><br>输出：<code>[1,2,3,6,9,8,7,4,5]</code><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4LWlpL3NvbHV0aW9uL3NwaXJhbC1tYXRyaXgtaWktbW8tbmktZmEtc2hlLWRpbmctYmlhbi1qaWUtcWluZy14Lw==">Krahets<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGlyYWwtbWF0cml4L3NvbHV0aW9uL2p1LXpoZW4tYmlhbi1saS13ZW4tdGktZGUtc2ktYnUtcXUtYnktZnUtOTF6YS8=">负雪明烛<i class="fa fa-external-link-alt"></i></span>。<br><div class="tabs" id="54"><ul class="nav-tabs"><li class="tab active"><a href="#54-1">模拟(需中间变量)</a></li><li class="tab"><a href="#54-2">模拟(无中间变量)</a></li><li class="tab"><a href="#54-3">找规律</a></li></ul><div class="tab-content"><div class="tab-pane active" id="54-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        起始从左上角向右走，每次到 边界/遇到走过的，转换方向继续走，直到全都走过。</span></span><br><span class="line"><span class="string">        需要辅助数组visited记录是否走过，时间/空间复杂度O(mn)。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]  <span class="comment"># 记录是否走过</span></span><br><span class="line">        total = m * n</span><br><span class="line">        res = [<span class="number">0</span>] * total</span><br><span class="line"></span><br><span class="line">        dirs = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">-1</span>, <span class="number">0</span>]]  <span class="comment"># directions方向</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># i行j列，当前位置坐标</span></span><br><span class="line">        dirIndex = <span class="number">0</span>  <span class="comment"># 转转方向的次数</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            res[x] = matrix[i][j]</span><br><span class="line">            visited[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 计算下一位置坐标</span></span><br><span class="line">            nexti, nextj = i+dirs[dirIndex][<span class="number">0</span>], j+dirs[dirIndex][<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 边界/遇到走过的，转换方向</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=nexti&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=nextj&lt;n <span class="keyword">and</span> visited[nexti][nextj]==<span class="number">0</span>):</span><br><span class="line">                dirIndex = (dirIndex+<span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            <span class="comment"># 更新坐标</span></span><br><span class="line">            i += dirs[dirIndex][<span class="number">0</span>]</span><br><span class="line">            j += dirs[dirIndex][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="54-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        记录上下左右应当遍历的行号、列号，每次顺时针遍历完，改变下次遍历行号、列号。</span></span><br><span class="line"><span class="string">        比如首次顺时针遍历：0行，0列，m-1行，n-1列；</span></span><br><span class="line"><span class="string">        下一次就是：1行，1列，m-2行，n-2列。</span></span><br><span class="line"><span class="string">        每次遍历后一定检查total，total数量减为0停止。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> []</span><br><span class="line">        res, m, n = [], <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        up, down, left, right = <span class="number">0</span>, m<span class="number">-1</span>, <span class="number">0</span>, n<span class="number">-1</span>   <span class="comment"># 上下左右边界</span></span><br><span class="line">        total = m*n  <span class="comment"># 当前个数，总共个数</span></span><br><span class="line">        <span class="keyword">while</span> total:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right+<span class="number">1</span>): <span class="comment"># left to right</span></span><br><span class="line">                res.append(matrix[up][i])</span><br><span class="line">                total -= <span class="number">1</span></span><br><span class="line">            up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> total: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(up, down+<span class="number">1</span>): <span class="comment"># up to down</span></span><br><span class="line">                res.append(matrix[i][right])</span><br><span class="line">                total -= <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> total: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(right, left<span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># right to left</span></span><br><span class="line">                res.append(matrix[down][i])</span><br><span class="line">                total -= <span class="number">1</span></span><br><span class="line">            down -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> total: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(down, up<span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># down to up</span></span><br><span class="line">                res.append(matrix[i][left])</span><br><span class="line">                total -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> total: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="54-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        大神找规律。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res += matrix.pop(<span class="number">0</span>)</span><br><span class="line">            matrix = <span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix))[::<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="048-旋转图像"><a href="#048-旋转图像" class="headerlink" title="048. 旋转图像"></a>048. 旋转图像</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtaW1hZ2Uv">https://leetcode.cn/problems/rotate-image/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzJlOTUzMzNmYmRkNDQ1MTM5NTA2Njk1N2UyNDkwOWNj">BM99 顺时针旋转矩阵<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 <strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。<br>示例 1：<br>输入：<code>matrix = [[1,2,3],[4,5,6],[7,8,9]]</code><br>输出：<code>[[7,4,1],[8,5,2],[9,6,3]]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        顺时针90度旋转后+每行翻转，和原矩阵关于主对角线对称。</span></span><br><span class="line"><span class="string">        逆序一下这个过程，先主按对角线互换元素，再每行翻转，就是顺时针90度结果。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="comment"># 交换上三角与下三角对应的元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">        <span class="comment"># 每行翻转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            matrix[i].reverse()</span><br><span class="line">        <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a>912. 排序数组</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS8=">https://leetcode-cn.com/problems/sort-an-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>nums</code>，请你将该数组升序排列。<br>示例 1：<br>输入：<code>nums = [5,2,3,1]</code><br>输出：<code>[1,2,3,5]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS9zb2x1dGlvbi85MTItcGFpLXh1LXNodS16dS1qaS1jaHUtcGFpLXh1LXN1YW4tZmEtMXF0NWYv">郁郁雨 题解<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS9zb2x1dGlvbi9weXRob24zLXN1aS1qaS1rdWFpLXN1LXBhaS14dS1ieS12MTJkZS1hLWN1ZjMv">V12的奥托 快排题解<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1hbi1hcnJheS9zb2x1dGlvbi9kb25nLWh1YS1tby1uaS15aS1nZS1wby1kdWktcGFpLXdvLWdhby1sLWk2bXQv">程序厨 堆排序讲解<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zb3J0LWFuLWFycmF5L3NvbHV0aW9uL2Rhbmctd28tdGFuLXBhaS14dS1zaGktd28temFpLXRhbi14aWUtc2hpLXlhby1ieS1zLw==">Sweetiee 排序算法复杂度<i class="fa fa-external-link-alt"></i></span>。<br><div class="tabs" id="912"><ul class="nav-tabs"><li class="tab active"><a href="#912-1">快速排序</a></li><li class="tab"><a href="#912-2">堆排序</a></li><li class="tab"><a href="#912-3">归并排序</a></li><li class="tab"><a href="#912-4">冒泡排序</a></li><li class="tab"><a href="#912-5">选择排序</a></li><li class="tab"><a href="#912-6">插入排序</a></li><li class="tab"><a href="#912-7">堆显示</a></li></ul><div class="tab-content"><div class="tab-pane active" id="912-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先随机选择一个值作为轴，比轴小的放左边，比轴大的放到右边，该轴就处于数列的中间位置。</span></span><br><span class="line"><span class="string">        递归地把小于轴值元素的子数列和大于轴值元素的子数列排序。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># def partition(left, right):</span></span><br><span class="line">        <span class="comment">#     index = random.randint(left, right)</span></span><br><span class="line">        <span class="comment">#     # 记录轴，并把轴移动到左侧保存</span></span><br><span class="line">        <span class="comment">#     pivot = nums[index]</span></span><br><span class="line">        <span class="comment">#     nums[index], nums[left] = nums[left], nums[index]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     i, j = left, right</span></span><br><span class="line">        <span class="comment">#     while i &lt; j:</span></span><br><span class="line">        <span class="comment">#         while i &lt; j and nums[j] &gt;= pivot: j -= 1  # 找到右边小于轴的j</span></span><br><span class="line">        <span class="comment">#         while i &lt; j and nums[i] &lt;= pivot: i += 1 # 找到左边大于轴的i</span></span><br><span class="line">        <span class="comment">#         nums[i], nums[j] = nums[j], nums[i]  # 交换</span></span><br><span class="line">        <span class="comment">#     # 结束时左边比轴小，右边比轴大，j==i停在轴应在的位置(左侧最后一位)，和轴交换</span></span><br><span class="line">        <span class="comment">#     nums[left], nums[j] = nums[j], nums[left]</span></span><br><span class="line">        <span class="comment">#     return j  # 返回轴最终位置</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            index = random.randint(left, right)</span><br><span class="line">            <span class="comment"># 记录轴，并把轴移动到右侧保存</span></span><br><span class="line">            pivot = nums[index]</span><br><span class="line">            nums[index], nums[right] = nums[right], nums[index]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 比轴元素小的放在左侧</span></span><br><span class="line">            j = left</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">                    nums[j], nums[i] = nums[i], nums[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最后 j 为轴元素位置(右侧第一位，第一个大于等于轴的值的位置)</span></span><br><span class="line">            nums[right], nums[j] = nums[j], nums[right]</span><br><span class="line">            <span class="keyword">return</span> j  <span class="comment"># 返回轴最终位置</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            <span class="comment"># 递归</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                mid = partition(left, right)</span><br><span class="line">                quick(left, mid<span class="number">-1</span>)</span><br><span class="line">                quick(mid+<span class="number">1</span>, right)</span><br><span class="line">            <span class="comment"># 非递归</span></span><br><span class="line">            stack = []</span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                stack.append((left, right))</span><br><span class="line">                <span class="keyword">while</span> stack:</span><br><span class="line">                    left, right = stack.pop()</span><br><span class="line">                    mid = partation(left, right)</span><br><span class="line">                    <span class="keyword">if</span> left &lt; mid - <span class="number">1</span>:</span><br><span class="line">                        stack.append((left, mid - <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">if</span> mid + <span class="number">1</span> &lt; right:</span><br><span class="line">                        stack.append((mid + <span class="number">1</span>, right))</span><br><span class="line">                        </span><br><span class="line">        quick(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums = [<span class="number">0</span>] + nums  <span class="comment"># 下标为 1~n</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建大顶堆(从最后一个非叶子节点n//2开始-&gt;堆顶)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            self.heap_adjust(n, i, nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 排序：依次将，尾部元素和堆最大值(堆顶nums[1])交换，并调整堆</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            nums[<span class="number">1</span>], nums[j] = nums[j], nums[<span class="number">1</span>] </span><br><span class="line">            <span class="comment"># 交换完，尾部是最大值了，只需调整前面的 nums[1~j-1] 节点   </span></span><br><span class="line">            self.heap_adjust(j<span class="number">-1</span>, <span class="number">1</span>, nums)                 </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">1</span>:]  <span class="comment"># 结束时，nums[1:]小-&gt;大的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap_adjust</span>(<span class="params">self, end, index, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        下沉法调整大顶堆</span></span><br><span class="line"><span class="string">        end：大顶堆数组尾部索引</span></span><br><span class="line"><span class="string">        index：当前节点的索引(要调整节点)</span></span><br><span class="line"><span class="string">        nums：大顶堆数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        index左节点索引：2*index</span></span><br><span class="line"><span class="string">        index右节点索引：2*index + 1</span></span><br><span class="line"><span class="string">        节点idx的父节点：idx//2</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            j = <span class="number">2</span> * index  <span class="comment"># 先设定j为index左节点索引</span></span><br><span class="line">            <span class="comment"># 如果左节点存在，j指向左右节点大的</span></span><br><span class="line">            <span class="keyword">if</span> j&lt;=end<span class="number">-1</span> <span class="keyword">and</span> nums[j]&lt;nums[j+<span class="number">1</span>]: </span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 验证j合法性，j节点大于index节点，交换</span></span><br><span class="line">            <span class="keyword">if</span> j&lt;=end <span class="keyword">and</span> nums[index]&lt;nums[j]: </span><br><span class="line">                nums[index],nums[j] = nums[j],nums[index]</span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            index = j  <span class="comment"># 继续下沉 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        归并是从中间开始不断分为左右两部分，对左右两部分进行合并排序</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> nums</span><br><span class="line">        <span class="comment"># 分半</span></span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        left = self.sortArray(nums[:mid])</span><br><span class="line">        right = self.sortArray(nums[mid:])</span><br><span class="line">        <span class="comment"># 合并</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">                res.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后有剩余，直接添加到res中</span></span><br><span class="line">        res += left[i:]</span><br><span class="line">        res += right[j:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-4"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 可优化为n-1，最后一次不用比</span></span><br><span class="line">            is_sorted = <span class="literal">True</span>  <span class="comment"># 当某一轮没有交换过，就已经排序好了</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i<span class="number">-1</span>):  <span class="comment"># 当i==0时，比较n-1次</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                    nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">                    is_sorted = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> is_sorted: <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-5"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        最大值移动到后面/最小值移动到前面，这里选择第二种。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 可优化为n-1，最后一次不用比</span></span><br><span class="line">            min_index = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[min_index]: min_index = j</span><br><span class="line">            nums[i], nums[min_index] = nums[min_index], nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-6"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        类似打扑克牌的时候，每次会把新摸的牌插入到已经排好序的牌里。</span></span><br><span class="line"><span class="string">        (1) 将比当前数大的元素依次后移，然后把当前数放在最后一个比它大的数字的原位置。</span></span><br><span class="line"><span class="string">        (2) 和比当前数大的元素依次交换，直到停止。</span></span><br><span class="line"><span class="string">        以上两种方法都可以。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 第一种</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):  </span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> nums[j<span class="number">-1</span>]&gt;tmp:</span><br><span class="line">                nums[j] = nums[j<span class="number">-1</span>]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[j] = tmp</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二种</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):  </span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> nums[j<span class="number">-1</span>]&gt;nums[j]:</span><br><span class="line">                nums[j<span class="number">-1</span>],nums[j] = nums[j], nums[j<span class="number">-1</span>]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="912-7"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># unit_width：单元宽度，数据和空格的单位</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ptree</span>(<span class="params">nums,unit_width=<span class="number">2</span></span>):</span></span><br><span class="line">    <span class="comment"># 为了和编号对应，增加一个无用的0在首位</span></span><br><span class="line">    nums.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 数据长度，减1跳过第0位</span></span><br><span class="line">    length = <span class="built_in">len</span>(nums) <span class="number">-1</span> </span><br><span class="line">    <span class="comment"># 树深度</span></span><br><span class="line">    depth = <span class="built_in">int</span>(math.log2(length)) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 按满二叉树算，最深那行个数，投影看就是总体数据个数</span></span><br><span class="line">    width = <span class="number">2</span> ** depth - <span class="number">1</span> </span><br><span class="line">    <span class="comment"># 层，从0开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(depth):</span><br><span class="line">        <span class="comment"># 每层最多几个数。如果层数从1开始：2**(i-1)，从0开始：2**i</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** i):</span><br><span class="line">            <span class="comment"># 当前索引：前i-1层的个数(2**i-1=2**k-1)+当前层第(j+1),最终等于2**i+j</span></span><br><span class="line">            <span class="comment"># 非满叉，判断当前层的节点索引是否超出数组最大索引，超出就结束</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> ** i + j) &gt;= length + <span class="number">1</span>:<span class="keyword">return</span></span><br><span class="line">            <span class="comment"># end是中间的空格(居中打印，后面追加一个单位空格，因为7//2=3,3+3=6,少一个)</span></span><br><span class="line">            print(<span class="string">&quot;&#123;:^&#123;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(nums[<span class="number">2</span> ** i + j],width * unit_width),end=<span class="string">&#x27; &#x27;</span> * unit_width)</span><br><span class="line">        <span class="comment">#每层居中宽度是上一层的一半</span></span><br><span class="line">        width = width // <span class="number">2</span> </span><br><span class="line">        <span class="comment">#每行结束换行</span></span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">30</span>,<span class="number">20</span>,<span class="number">80</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">90</span>]</span><br><span class="line">ptree(nums)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              30                </span></span><br><span class="line"><span class="string">      20              80        </span></span><br><span class="line"><span class="string">  40      50      10      60    </span></span><br><span class="line"><span class="string">70  90  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLWxhcmdlc3QtZWxlbWVudC1pbi1hbi1hcnJheS8=">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。<br>示例 1:<br>输入: <code>[3,2,1,5,6,4] 和 k = 2</code><br>输出: <code>5</code><br>第k大，在 Python 的 heapq 库中有一个 nlargest 方法，具有同样的时间复杂度，能将代码简化到只有一行 <code>heapq.nlargest(k, nums)[-1]</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        快速排序，quick中发现目标位置被排好序，直接返回值。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">left, right</span>):</span></span><br><span class="line">            index = random.randint(left, right)</span><br><span class="line">            <span class="comment"># 记录基准，并把基准移动到右侧保存</span></span><br><span class="line">            pivot = nums[index]</span><br><span class="line">            nums[index], nums[right] = nums[right], nums[index]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 比轴元素小的放在左侧，最后j为轴元素位置</span></span><br><span class="line">            j = left</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">                    nums[j], nums[i] = nums[i], nums[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 轴元素放入其应在位置</span></span><br><span class="line">            nums[right], nums[j] = nums[j], nums[right]</span><br><span class="line">            <span class="keyword">return</span> j  <span class="comment"># 返回基准最终位置</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">left, right</span>):</span> </span><br><span class="line">            idx = <span class="built_in">len</span>(nums)-k   <span class="comment"># 第k大的下标为n-k</span></span><br><span class="line">            mid = partition(left, right)</span><br><span class="line">            <span class="keyword">if</span> mid == idx: <span class="keyword">return</span> nums[mid]  <span class="comment"># 此时确定好位置的mid为第k大下标，直接返回值。</span></span><br><span class="line">            <span class="keyword">elif</span> mid &gt; idx: <span class="keyword">return</span> quick(left, mid<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">elif</span> mid &lt; idx: <span class="keyword">return</span> quick(mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quick(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc29ydC1saXN0Lw==">https://leetcode-cn.com/problems/sort-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。<br>示例 1：<br>输入：<code>head = [4,2,1,3]</code><br>输出：<code>[1,2,3,4]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        归并排序</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">        left_end = self.find_mid(head)</span><br><span class="line">        right_head = left_end.<span class="built_in">next</span></span><br><span class="line">        left_end.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(right_head)</span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_mid</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        快慢指针找中点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 奇数：slow停在中间</span></span><br><span class="line">        <span class="comment"># 偶数：slow停在中间偏左</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        021. 合并两个有序链表</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cur = newlist = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> head1 <span class="keyword">and</span> head2:</span><br><span class="line">            <span class="keyword">if</span> head1.val &lt; head2.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = head1</span><br><span class="line">                head1 = head1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.<span class="built_in">next</span> = head2</span><br><span class="line">                head2 = head2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        cur.<span class="built_in">next</span> = head1 <span class="keyword">if</span> head1 <span class="keyword">else</span> head2</span><br><span class="line">        <span class="keyword">return</span> newlist.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lci13ZWktc2h1LXp1LXpob25nLWRlLWNoYS16aGFvLWxjb2Yv">剑指 Offer 04. 二维数组中的查找<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：在一个 <code>n * m</code> 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        二维数组 左-&gt;右、上-&gt;下 递增，利用这一点可知：左上角为min，右下角为max。</span></span><br><span class="line"><span class="string">        选左上角，往右走和往下走都增大，不能选</span></span><br><span class="line"><span class="string">        选右下角，往上走和往左走都减小，不能选</span></span><br><span class="line"><span class="string">        选左下角，往右走增大，往上走减小，可选</span></span><br><span class="line"><span class="string">        选右上角，往下走增大，往左走减小，可选</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 优先判断特殊</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n, m = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 左下角开始 </span></span><br><span class="line">        i, j = n<span class="number">-1</span>, <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;m:</span><br><span class="line">            <span class="comment"># 元素较大，往上走</span></span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] &gt; target: i -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 元素较小，往右走</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target: j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 找到target了</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaHUtenUtemhvbmctZGUtbmkteHUtZHVpLWxjb2Yv">剑指 Offer 51. 数组中的逆序对<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。<br>示例 1:<br>输入: <code>[7,5,6,4]</code><br>输出: <code>5</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.sortArray(nums)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> nums</span><br><span class="line">        <span class="comment"># 分半</span></span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        left = self.sortArray(nums[:mid])</span><br><span class="line">        right = self.sortArray(nums[mid:])</span><br><span class="line">        <span class="comment"># 合并</span></span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">            <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">                res.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 对排好序的两组，右边小于左边时，它小于了左边i和之后的所有值[i~len(left)-1]</span></span><br><span class="line">                <span class="comment"># 逆序对数为[i~len(left)-1]个数</span></span><br><span class="line">                self.count += <span class="built_in">len</span>(left)-i</span><br><span class="line">        <span class="comment"># 最后有剩余，直接添加到res中</span></span><br><span class="line">        res += left[i:]</span><br><span class="line">        res += right[j:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">二分搜索**边界**细节：</span><br><span class="line">1. mid加1还是减1?</span><br><span class="line">    - [left,right]：nums[mid]&#x3D;&#x3D;target时，left&#x2F;right &#x3D; mid +&#x2F;- 1</span><br><span class="line">    - [left,right)：nums[mid]&#x3D;&#x3D;target时，left&#x2F;right &#x3D; mid</span><br><span class="line">2. while用不用加&#x3D;? </span><br><span class="line">    - [left,right]：初始[0,n-1]，加&#x3D;，会判断left&#x3D;&#x3D;right时的mid，结束时left&gt;right。</span><br><span class="line">        - 求target左边界：right不断缩小，直到left&gt;right，返回left。检查left&gt;n?</span><br><span class="line">        - 求target右边界：left不断增大，直到left&gt;right，返回right。检查right&lt;0?</span><br><span class="line">    - [left,right)：初始[0,n]，不加&#x3D;，不会判断left&#x3D;&#x3D;right的mid，结束时left&#x3D;&#x3D;right。</span><br><span class="line">建议使用第一种方法做二分搜索，便于记忆。</span><br></pre></td></tr></table></figure>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC8=">https://leetcode-cn.com/problems/binary-search/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p>示例 1:<br>输入: <code>nums = [-1,0,3,5,9,12], target = 9</code><br>输出: <code>4</code><br>解释: 9 出现在 nums 中并且下标为 4</p>
<p>示例 2:<br>输入: <code>nums = [-1,0,3,5,9,12], target = 2</code><br>输出: <code>-1</code><br>解释: 2 不存在 nums 中因此返回 -1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建议不用else，用elif把条件都写出来，容易纠错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 需要判断当前值，所以有=</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 奇数：mid停在中间</span></span><br><span class="line">            <span class="comment"># 偶数：mid停在中间偏左</span></span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            num = nums[mid]</span><br><span class="line">            <span class="keyword">if</span> num == target: <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> num &lt; target: left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &gt; target: right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="069-x-的平方根"><a href="#069-x-的平方根" class="headerlink" title="069. x 的平方根"></a>069. x 的平方根</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcXJ0eC8=">https://leetcode.cn/problems/sqrtx/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个非负整数 x ，计算并返回 x 的 算术平方根。由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        找 k^2 &lt;= x 的 最大k是多少</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> x==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left, right, res = <span class="number">0</span>, x, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid*mid &lt;=x:</span><br><span class="line">                res = mid</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="034-排序数组中查找元素的首末位置"><a href="#034-排序数组中查找元素的首末位置" class="headerlink" title="034. 排序数组中查找元素的首末位置"></a>034. 排序数组中查找元素的首末位置</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1maXJzdC1hbmQtbGFzdC1wb3NpdGlvbi1vZi1lbGVtZW50LWluLXNvcnRlZC1hcnJheS8=">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个<strong>按照升序排列</strong>的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的<strong>开始位置</strong>和<strong>结束位置</strong>。如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>示例 1：<br>输入：<code>nums = [5,7,7,8,8,10], target = 8</code><br>输出：<code>[3,4]</code></p>
<p>示例 2：<br>输入：<code>nums = [5,7,7,8,8,10], target = 6</code><br>输出：<code>[-1,-1]</code></p>
<p>示例 3：<br>输入：<code>nums = [], target = 0</code><br>输出：<code>[-1,-1]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1maXJzdC1hbmQtbGFzdC1wb3NpdGlvbi1vZi1lbGVtZW50LWluLXNvcnRlZC1hcnJheS9zb2x1dGlvbi9sYW4taG9uZy1odWEtZmVuLWZhLWRhbi1tby1iYW4tbWlhby1zaGEtZTdyNDAv">随心源 题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        left = self.binarySearchLeft(nums, target)</span><br><span class="line">        right = self.binarySearchRight(nums, target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [left, right]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearchLeft</span>(<span class="params">self, nums:List[<span class="built_in">int</span>], target:<span class="built_in">int</span></span>)-&gt;List[int]:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 需要判断当前值，所以有=，结束时left停在左边界</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 奇数：mid停在中间</span></span><br><span class="line">            <span class="comment"># 偶数：mid停在中间偏左</span></span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            num = nums[mid]</span><br><span class="line">            <span class="keyword">if</span> num == target: right = mid - <span class="number">1</span> <span class="comment"># 收缩右侧边界</span></span><br><span class="line">            <span class="keyword">elif</span> num &lt; target: left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &gt; target: right = mid - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 检测left越界(target比所有元素都大)</span></span><br><span class="line">        <span class="keyword">if</span> left &gt;= <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left] != target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearchRight</span>(<span class="params">self, nums:List[<span class="built_in">int</span>], target:<span class="built_in">int</span></span>)-&gt;List[int]:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 需要判断当前值，所以有=，结束时right停在右边界</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="comment"># 奇数：mid停在中间</span></span><br><span class="line">            <span class="comment"># 偶数：mid停在中间偏左</span></span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            num = nums[mid]</span><br><span class="line">            <span class="keyword">if</span> num == target: left = mid + <span class="number">1</span> <span class="comment"># 收缩左侧边界</span></span><br><span class="line">            <span class="keyword">elif</span> num &lt; target: left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num &gt; target: right = mid - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 检测right越界((target比所有元素都小))</span></span><br><span class="line">        <span class="keyword">if</span> right &lt; <span class="number">0</span> <span class="keyword">or</span> nums[right] != target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure></p>
<h2 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a>875. 爱吃香蕉的珂珂</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva29rby1lYXRpbmctYmFuYW5hcy8=">https://leetcode-cn.com/problems/koko-eating-bananas/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（k 为整数）。<br>示例 1：<br>输入：<code>piles = [3,6,7,11], h = 8</code><br>输出：<code>4</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span>(<span class="params">self, piles: List[<span class="built_in">int</span>], h: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        正常考虑速度 K 由 [1~max(piles)] 选择，因为要最小速度，所以取能吃完的速度最小值k。</span></span><br><span class="line"><span class="string">        二分查找：类似寻找左侧边界。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">k</span>):</span></span><br><span class="line">            <span class="comment"># 能否以速度 k 吃完香蕉(吃完香蕉总用时不超过H)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(ceil(p/k) <span class="keyword">for</span> p <span class="keyword">in</span> piles) &lt;= h</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">1</span>, <span class="built_in">max</span>(piles)</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            <span class="keyword">if</span> canFinish(mid):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 本题可不用检验边界</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="built_in">max</span>(piles) <span class="keyword">or</span> <span class="keyword">not</span> canFinish(left): <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p>
<h2 id="1011-在D天内送达包裹的能力"><a href="#1011-在D天内送达包裹的能力" class="headerlink" title="1011. 在D天内送达包裹的能力"></a>1011. 在D天内送达包裹的能力</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2FwYWNpdHktdG8tc2hpcC1wYWNrYWdlcy13aXRoaW4tZC1kYXlzLw==">https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：传送带上的包裹必须在 <code>days</code> 天内从一个港口运送到另一个港口。传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。返回能在 <code>days</code> 天内将传送带上的所有包裹<strong>按顺序</strong>送达的船的最低运载能力。<br>示例 1：<br>输入：<code>weights = [1,2,3,4,5,6,7,8,9,10], days = 5</code><br>输出：<code>15</code><br>解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：<br>第 1 天：1, 2, 3, 4, 5<br>第 2 天：6, 7<br>第 3 天：8<br>第 4 天：9<br>第 5 天：10<br>请注意，<strong>货物必须按照给定的顺序装运</strong>，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shipWithinDays</span>(<span class="params">self, weights: List[<span class="built_in">int</span>], days: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        和吃香蕉一样，先确定最小载重值的范围[max(weights), sum(weights)]，在这个范围内二分搜索。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">k</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            能否以载重 k 运完货物(运完货物总天数不超过days)</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># need 为需要运送的天数</span></span><br><span class="line">            <span class="comment"># cur 为当前这一天已经运送的包裹重量之和</span></span><br><span class="line">            need, cur = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> weight <span class="keyword">in</span> weights:</span><br><span class="line">                <span class="comment"># 当前货物超载，结束当天装载，放入下一天</span></span><br><span class="line">                <span class="keyword">if</span> cur + weight &gt; k: </span><br><span class="line">                    need += <span class="number">1</span></span><br><span class="line">                    cur = <span class="number">0</span></span><br><span class="line">                cur += weight</span><br><span class="line">            <span class="keyword">return</span> need &lt;= days</span><br><span class="line">        </span><br><span class="line">        left, right = <span class="built_in">max</span>(weights), <span class="built_in">sum</span>(weights)</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            <span class="keyword">if</span> canFinish(mid):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 本题可不用检验边界</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="built_in">sum</span>(weights) <span class="keyword">or</span> <span class="keyword">not</span> canFinish(left): <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure></p>
<h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a>162. 寻找峰值</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBlYWstZWxlbWVudC8=">https://leetcode.cn/problems/find-peak-element/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：峰值元素是指其值严格大于左右相邻值的元素。给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。你可以假设 <code>nums[-1] = nums[n] = -inf</code>。你必须实现时间复杂度为 <code>O(logn)</code> 的算法来解决此问题。<br>示例 1：<br>输入：<code>nums = [1,2,3,1]</code><br>输出：<code>2</code><br>解释：3 是峰值元素，你的函数应该返回其索引 2。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        题目将数组边界看成最小值，而我们只需要找到其中一个波峰，因此只要不断地往高处走，一定会有波峰。</span></span><br><span class="line"><span class="string">        那我们可以每次找一个轴元素，将数组分成两个区间，每次向较高的一边走，因此可用二分法(分治)来解决，而轴元素可选择区间中点。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right= <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 二分法</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (right-left)//<span class="number">2</span> + left</span><br><span class="line">            <span class="comment"># mid处于下坡，向左侧走寻找峰值(区间为[left,mid])</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[mid+<span class="number">1</span>]: right = mid</span><br><span class="line">            <span class="comment"># mid处于上坡，向右侧走寻找峰值(区间为[mid,rihgt])</span></span><br><span class="line">            <span class="keyword">else</span>: left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 其中一个波峰</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure></p>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy94dWFuLXpodWFuLXNodS16dS1kZS16dWkteGlhby1zaHUtemktbGNvZi8=">剑指 Offer 11. 旋转数组的最小数字<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。给你一个可能存在 重复 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。<br>示例 1：<br>输入：<code>numbers = [3,4,5,1,2]</code><br>输出：<code>1</code><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy94dWFuLXpodWFuLXNodS16dS1kZS16dWkteGlhby1zaHUtemktbGNvZi9zb2x1dGlvbi94dWFuLXpodWFuLXNodS16dS1kZS16dWkteGlhby1zaHUtemktYnktbGVldGNvZGUtcy8=">官方题解<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span>(<span class="params">self, numbers: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        low, high = <span class="number">0</span>, <span class="built_in">len</span>(numbers)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (high-low)//<span class="number">2</span> + low</span><br><span class="line">            <span class="comment"># 最小数字 &quot;是mid&quot; 或 &quot;在mid左边&quot;</span></span><br><span class="line">            <span class="keyword">if</span> numbers[mid] &lt; numbers[high]: high = mid </span><br><span class="line">            <span class="comment"># 最小的数字在mid右边 </span></span><br><span class="line">            <span class="keyword">elif</span> numbers[mid] &gt; numbers[high]: low = mid + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 无法判断，一个一个试</span></span><br><span class="line">            <span class="keyword">else</span>: high -= <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> numbers[low]</span><br></pre></td></tr></table></figure></p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a>146. LRU 缓存</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbHJ1LWNhY2hlLw==">https://leetcode-cn.com/problems/lru-cache/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：请你设计并实现一个满足  <strong>LRU (最近最少使用)</strong> 缓存 约束的数据结构。<br>实现 <code>LRUCache</code> 类：<br><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存；<br><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。<br><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出 最久</strong>未使用的关键字。<br>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p>示例：<br>输入：<br><code>[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</code><br><code>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</code><br>输出：<code>[null, null, null, 1, null, -1, null, -1, 3, 4]</code><br>解释：<br><code>LRUCache lRUCache = new LRUCache(2);</code><br><code>lRUCache.put(1, 1);</code> // 缓存是 {1=1}<br><code>lRUCache.put(2, 2);</code> // 缓存是 {1=1, 2=2}<br><code>lRUCache.get(1);</code>    // 返回 1<br><code>lRUCache.put(3, 3);</code> // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br><code>lRUCache.get(2);</code>   // 返回 -1 (未找到)<br><code>lRUCache.put(4, 4);</code> // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br><code>lRUCache.get(1);</code>    // 返回 -1 (未找到)<br><code>lRUCache.get(3);</code>    // 返回 3<br><code>lRUCache.get(4);</code>    // 返回 4</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">0</span>, value=<span class="number">0</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    要求 查找、插入、删除(超出容量) 操作时间复杂度为 O(1)，</span></span><br><span class="line"><span class="string">    想到hamp(字典)能快速查找，链表能快速插入、删除————哈希链表(双向)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    为什么用双向链表？因为删除时只给当前节点，不用双向不知道前面节点。</span></span><br><span class="line"><span class="string">    为什么链表存储(key,val)，只存val不行吗？不行，因为容量满了，链表和hmap都要删除节点，而hmap需要key，只能从node中获取。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = <span class="built_in">dict</span>()  <span class="comment"># KN表&#123;key:Node&#125;</span></span><br><span class="line">        <span class="comment"># 使用伪头部和伪尾部节点    </span></span><br><span class="line">        self.head = DLinkedNode()  <span class="comment"># 头部存最近节点</span></span><br><span class="line">        self.tail = DLinkedNode()  <span class="comment"># 尾部为最少使用</span></span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            <span class="comment"># 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value</span><br><span class="line">            self.moveToHead(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 key 不存在，插入前处理超出容量</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt;= self.capacity:</span><br><span class="line">                <span class="comment"># 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                removed = self.removeTail()</span><br><span class="line">                <span class="comment"># 删除哈希表中对应的项</span></span><br><span class="line">                self.cache.pop(removed.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 创建一个新的节点</span></span><br><span class="line">            node = DLinkedNode(key, value)</span><br><span class="line">            <span class="comment"># 添加进哈希表</span></span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            <span class="comment"># 添加至双向链表的头部</span></span><br><span class="line">            self.addToHead(node)</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加：head后面插入node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = node</span><br><span class="line">        self.head.<span class="built_in">next</span> = node</span><br><span class="line">    <span class="comment"># 删除</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">    <span class="comment"># 删除(超出容量)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="comment"># 更新(node重新放入头部)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveToHead</span>(<span class="params">self, node</span>):</span> </span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        self.addToHead(node)</span><br></pre></td></tr></table></figure>
<h2 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a>460. LFU 缓存</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGZ1LWNhY2hlLw==">https://leetcode-cn.com/problems/lfu-cache/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：请你为 <strong>最不经常使用（LFU）</strong> 缓存算法设计并实现数据结构。实现 LFUCache 类：<br><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象。<br><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。<br><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。<br>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。<br>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 <code>put</code> 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。<br>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</span><br><span class="line">解释：</span><br><span class="line">&#x2F;&#x2F; cnt(x) &#x3D; 键 x 的使用计数</span><br><span class="line">&#x2F;&#x2F; cache&#x3D;[] 将显示最后一次使用的顺序（最左边的元素是最近的）</span><br><span class="line">LFUCache lfu &#x3D; new LFUCache(2);</span><br><span class="line">lfu.put(1, 1);   &#x2F;&#x2F; cache&#x3D;[1,_], cnt(1)&#x3D;1</span><br><span class="line">lfu.put(2, 2);   &#x2F;&#x2F; cache&#x3D;[2,1], cnt(2)&#x3D;1, cnt(1)&#x3D;1</span><br><span class="line">lfu.get(1);      &#x2F;&#x2F; 返回 1</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[1,2], cnt(2)&#x3D;1, cnt(1)&#x3D;2</span><br><span class="line">lfu.put(3, 3);   &#x2F;&#x2F; 去除键 2 ，因为 cnt(2)&#x3D;1 ，使用计数最小</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;1, cnt(1)&#x3D;2</span><br><span class="line">lfu.get(2);      &#x2F;&#x2F; 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      &#x2F;&#x2F; 返回 3</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;2, cnt(1)&#x3D;2</span><br><span class="line">lfu.put(4, 4);   &#x2F;&#x2F; 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[4,3], cnt(4)&#x3D;1, cnt(3)&#x3D;2</span><br><span class="line">lfu.get(1);      &#x2F;&#x2F; 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      &#x2F;&#x2F; 返回 3</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;1, cnt(3)&#x3D;3</span><br><span class="line">lfu.get(4);      &#x2F;&#x2F; 返回 4</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;2, cnt(3)&#x3D;3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LFUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key=<span class="number">-1</span>, val=<span class="number">-1</span></span>):</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.freq = <span class="number">1</span>  <span class="comment"># 记录频次</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedList</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = Node()</span><br><span class="line">        self.tail = Node()</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line">        self.size = <span class="number">0</span>  <span class="comment"># 双向链表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加：head后面插入node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToHead</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev = self.head</span><br><span class="line">        node.<span class="built_in">next</span> = self.head.<span class="built_in">next</span></span><br><span class="line">        self.head.<span class="built_in">next</span>.prev = node</span><br><span class="line">        self.head.<span class="built_in">next</span> = node</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 删除</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        node.prev.<span class="built_in">next</span> = node.<span class="built_in">next</span></span><br><span class="line">        node.<span class="built_in">next</span>.prev = node.prev</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 删除(超出容量)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeTail</span>(<span class="params">self</span>):</span></span><br><span class="line">        node = self.tail.prev</span><br><span class="line">        self.removeNode(node)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    KN表：&#123;key:Node&#125;。</span></span><br><span class="line"><span class="string">    FD表：记录freq对应key，key可以有多个，所以用链表，&#123;频次:链表&#125;。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.cache = &#123;&#125;  <span class="comment"># KN表</span></span><br><span class="line">        self.freq = defaultdict(DLinkedList)  <span class="comment"># FD表</span></span><br><span class="line">        self.size = <span class="number">0</span>   <span class="comment"># 元素个数</span></span><br><span class="line">        self.capacity = capacity  <span class="comment"># 容量</span></span><br><span class="line">        self.min_freq = <span class="number">0</span>  <span class="comment"># 记录最低频次，超出容量删除用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            <span class="comment"># 当前key频次+1：更新FK表,先在该频次链表中删除node,</span></span><br><span class="line">            self.freq[node.freq].removeNode(node)</span><br><span class="line">            <span class="comment"># 此频次为最低频次且为该频次链表唯一节点，最低频次也跟着+1</span></span><br><span class="line">            <span class="keyword">if</span> self.min_freq == node.freq <span class="keyword">and</span> self.freq[node.freq].size == <span class="number">0</span>:</span><br><span class="line">                self.min_freq += <span class="number">1</span></span><br><span class="line">            node.freq += <span class="number">1</span>  <span class="comment"># 频次+1</span></span><br><span class="line">            self.freq[node.freq].addToHead(node)  <span class="comment"># 加入新频次的链表</span></span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity == <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># key存在：更新val,freq(KN表,FD表)</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            self.freq[node.freq].removeNode(node)</span><br><span class="line">            <span class="keyword">if</span> self.min_freq == node.freq <span class="keyword">and</span> self.freq[node.freq].size == <span class="number">0</span>:</span><br><span class="line">                self.min_freq += <span class="number">1</span></span><br><span class="line">            node.freq += <span class="number">1</span></span><br><span class="line">            self.freq[node.freq].addToHead(node)</span><br><span class="line">        <span class="comment"># key不存在：插入新key，判断容量是否满了</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 容量满了：删除最低频次链表尾部节点(FD表,KN表)</span></span><br><span class="line">            <span class="keyword">if</span> self.size &gt;= self.capacity:</span><br><span class="line">                node = self.freq[self.min_freq].removeTail()</span><br><span class="line">                self.cache.pop(node.key)</span><br><span class="line">                self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            node = Node(key, value)</span><br><span class="line">            self.cache[key] = node</span><br><span class="line">            self.freq[<span class="number">1</span>].addToHead(node)</span><br><span class="line">            self.min_freq = <span class="number">1</span></span><br><span class="line">            self.size += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbXBsZW1lbnQtcXVldWUtdXNpbmctc3RhY2tzLw==">https://leetcode.cn/problems/implement-queue-using-stacks/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>实现 MyQueue 类：<br><code>void push(int x)</code> 将元素 x 推到队列的末尾。<br><code>int pop()</code> 从队列的开头移除并返回元素。<br><code>int peek()</code> 返回队列开头的元素。<br><code>boolean empty()</code> 如果队列为空，返回 true ；否则，返回 false。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s1 = []  <span class="comment"># in</span></span><br><span class="line">        self.s2 = []  <span class="comment"># out</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.s1.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        self.in2out()</span><br><span class="line">        <span class="keyword">return</span> self.s2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        self.in2out()</span><br><span class="line">        <span class="keyword">return</span> self.s2[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.s1 <span class="keyword">and</span> <span class="keyword">not</span> self.s2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in2out</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s2:  <span class="comment"># 只有s2为空时才把s1放入s2</span></span><br><span class="line">            <span class="keyword">while</span> self.s1:</span><br><span class="line">                self.s2.append(self.s1.pop())</span><br></pre></td></tr></table></figure></p>
<h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a>295. 数据流的中位数</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1lZGlhbi1mcm9tLWRhdGEtc3RyZWFtLw==">https://leetcode.cn/problems/find-median-from-data-stream/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。<code>[2,3,4]</code> 的中位数是 3，<code>[2,3]</code> 的中位数是 (2+3)/2=2.5。<br>设计一个支持以下两种操作的数据结构：<br><code>void addNum(int num)</code> - 从数据流中添加一个整数到数据结构中。<br><code>double findMedian()</code> - 返回目前所有元素的中位数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    中位数：它是数组中间值或中间两个值的均值，它是较小的一半元素中最大的一个，也是较大的一半元素中最小的一个。</span></span><br><span class="line"><span class="string">    只要每次维护最小的一半元素(的最大值)和最大的一半元素(的最小值)。考虑堆排序的优先队列。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    heapq默认小顶堆，若想大顶堆：加入元素要乘-1才能实现大顶堆，取出时也要乘-1还原。</span></span><br><span class="line"><span class="string">    约定奇数个元素时取大顶堆(较小部分)的顶部值，那么大顶堆的数据应该比小顶堆多，</span></span><br><span class="line"><span class="string">    因此需要比较二者的长度，若是大顶堆长度小于小顶堆，需要从小顶堆中弹出最小值到大顶堆中进行平衡。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">max</span> = []  <span class="comment">#小顶堆，元素数值都比大顶堆大(最大的一半元素)</span></span><br><span class="line">        self.<span class="built_in">min</span> = []  <span class="comment">#大顶堆，元素数值较小(最小的一半元素)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="comment"># 先加入大顶堆(较小部分)</span></span><br><span class="line">        heapq.heappush(self.<span class="built_in">min</span>, (<span class="number">-1</span>*num))  <span class="comment"># 大顶堆</span></span><br><span class="line">        <span class="comment"># 将较小部分的最大值取出，送入到较大部分</span></span><br><span class="line">        heapq.heappush(self.<span class="built_in">max</span>, <span class="number">-1</span>*self.<span class="built_in">min</span>[<span class="number">0</span>])  <span class="comment"># 小顶堆</span></span><br><span class="line">        heapq.heappop(self.<span class="built_in">min</span>)</span><br><span class="line">        <span class="comment"># 平衡两个堆的数量(大顶堆长度小于小顶堆)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.<span class="built_in">min</span>) &lt; <span class="built_in">len</span>(self.<span class="built_in">max</span>): </span><br><span class="line">            heapq.heappush(self.<span class="built_in">min</span>, <span class="number">-1</span>*self.<span class="built_in">max</span>[<span class="number">0</span>])</span><br><span class="line">            heapq.heappop(self.<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.<span class="built_in">min</span>) &gt; <span class="built_in">len</span>(self.<span class="built_in">max</span>):  <span class="comment"># 奇数个，取self.min大顶堆的顶部值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>*self.<span class="built_in">min</span>[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 偶数个，取两堆顶的平均值</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>*self.<span class="built_in">min</span>[<span class="number">0</span>] + self.<span class="built_in">max</span>[<span class="number">0</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="341-扁平化嵌套列表迭代器"><a href="#341-扁平化嵌套列表迭代器" class="headerlink" title="341. 扁平化嵌套列表迭代器"></a>341. 扁平化嵌套列表迭代器</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmxhdHRlbi1uZXN0ZWQtbGlzdC1pdGVyYXRvci8=">https://leetcode-cn.com/problems/flatten-nested-list-iterator/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个嵌套的整数列表 <code>nestedList</code> 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。实现扁平迭代器类 <code>NestedIterator</code> ：<br>（1）<code>NestedIterator(List&lt;NestedInteger&gt; nestedList)</code> 用嵌套列表 <code>nestedList</code> 初始化迭代器。<br>（2）<code>int next()</code> 返回嵌套列表的下一个整数。<br>（3）<code>boolean hasNext()</code> 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。</p>
<p>示例 1：<br>输入：<code>nestedList = [1,[4,[6]]]</code><br>输出：<code>[1,4,6]</code><br>解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: <code>[1,4,6]</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    可使用递归/迭代，这里使用迭代方法：</span></span><br><span class="line"><span class="string">    (1) 使用栈存储nestedList元素。</span></span><br><span class="line"><span class="string">    (2) 每次迭代是惰性的，只出一个元素。</span></span><br><span class="line"><span class="string">    按顺序用栈pop出nestedList元素，所以栈顶应是nestedList第一个元素，所以逆序入栈。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, nestedList: [NestedInteger]</span>):</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="comment"># 逆序入栈</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nestedList)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            self.stack.append(nestedList[i])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        返回嵌套列表的下一个整数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 逆序入栈、出栈，直到第一个元素是整数结束。</span></span><br><span class="line">        <span class="keyword">while</span> self.stack:</span><br><span class="line">            cur = self.stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> cur.isInteger(): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.stack.pop()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cur.getList())<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    self.stack.append(cur.getList()[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="855-考场就座"><a href="#855-考场就座" class="headerlink" title="855. 考场就座"></a>855. 考场就座</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXhhbS1yb29tLw==">https://leetcode-cn.com/problems/exam-room/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：在考场里，一排有 <code>N</code> 个座位，分别编号为 <code>0, 1, 2, ..., N-1</code> 。当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)返回 <code>ExamRoom(int N)</code> 类，它有两个公开的函数：其中，函数 <code>ExamRoom.seat()</code> 会返回一个 <code>int</code> （整型数据），代表学生坐的位置；函数 <code>ExamRoom.leave(int p)</code> 代表坐在座位 <code>p</code> 上的学生现在离开了考场。每次调用 <code>ExamRoom.leave(p)</code> 时都保证有学生坐在座位 <code>p</code> 上。<br>示例：<br>输入：<code>[&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]</code><br>输出：<code>[null,0,9,4,2,null,5]</code><br>解释：<br><code>ExamRoom(10) -&gt; null</code><br><code>seat() -&gt; 0</code>，没有人在考场里，那么学生坐在 0 号座位上。<br><code>seat() -&gt; 9</code>，学生最后坐在 9 号座位上。<br><code>seat() -&gt; 4</code>，学生最后坐在 4 号座位上。<br><code>seat() -&gt; 2</code>，学生最后坐在 2 号座位上。<br><code>leave(4) -&gt; null</code><br><code>seat() -&gt; 5</code>，学生最后坐在 5 号座位上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamRoom</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    N：座位个数</span></span><br><span class="line"><span class="string">    students：学生位置</span></span><br><span class="line"><span class="string">    maxdist：线段最大长度</span></span><br><span class="line"><span class="string">    pos：学生应位置</span></span><br><span class="line"><span class="string">    posi：前一个学生位置</span></span><br><span class="line"><span class="string">    posj：后一个学生位置</span></span><br><span class="line"><span class="string">    d：两个学生之间距离(线段一半长度)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        self.N = N</span><br><span class="line">        self.students = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">seat</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.students: pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxdist, pos = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j, posj <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.students):</span><br><span class="line">                <span class="keyword">if</span> j:</span><br><span class="line">                    posi = self.students[j<span class="number">-1</span>]</span><br><span class="line">                    d = (posj - posi) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> d &gt; maxdist: maxdist, pos = d, posi+d</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 最后位置作为端点时，距离</span></span><br><span class="line">            d = self.N - <span class="number">1</span> - self.students[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> d &gt; maxdist: pos = self.N - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        bisect.insort(self.students, pos)</span><br><span class="line">        <span class="keyword">return</span> pos</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leave</span>(<span class="params">self, p</span>):</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">in</span> self.students:</span><br><span class="line">            self.students.remove(p)</span><br></pre></td></tr></table></figure></p>
<h2 id="前向最大匹配算法"><a href="#前向最大匹配算法" class="headerlink" title="前向最大匹配算法"></a>前向最大匹配算法</h2><div class="tabs" id="fourth-unique-name"><ul class="nav-tabs"><li class="tab active"><a href="#fourth-unique-name-1">传统匹配</a></li><li class="tab"><a href="#fourth-unique-name-2">字典树(前缀树)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fourth-unique-name-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_segment</span>(<span class="params">text, dic</span>):</span></span><br><span class="line">    word_list = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(text):</span><br><span class="line">        longest_word = text[i]                                  <span class="comment"># 当前扫描位置的单字</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(text)+<span class="number">1</span>):                       <span class="comment"># 所有可能的结尾</span></span><br><span class="line">            word = text[i:j]                                    <span class="comment"># 从当前位置到结尾的字符串</span></span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> dic <span class="keyword">and</span> <span class="built_in">len</span>(word)&gt;<span class="built_in">len</span>(longest_word):     <span class="comment"># 在词典中且更长，更新最长词</span></span><br><span class="line">                longest_word = word                 </span><br><span class="line">        word_list.append(longest_word)                          <span class="comment"># 输出最长词</span></span><br><span class="line">        i += <span class="built_in">len</span>(longest_word)                                  <span class="comment"># 正向扫描</span></span><br><span class="line">        <span class="keyword">return</span> word_list</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="fourth-unique-name-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典树节点，节点不存储值，节点的边为字符</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.children = &#123;&#125;   <span class="comment"># key就是边，即字符</span></span><br><span class="line">        self.is_end = <span class="literal">False</span>  <span class="comment"># 该节点可否作为结束</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self, token</span>):</span>  <span class="comment"># 将输入的token存储在树中</span></span><br><span class="line">        root = self</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> token:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> root.children:</span><br><span class="line">                root.children[char] = Trie()</span><br><span class="line">            root = root.children[char]</span><br><span class="line">        root.is_end = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, text</span>):</span>  <span class="comment"># 从已经建立好的树中搜索并匹配给定句子的最大token长度</span></span><br><span class="line">        root = self</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(text):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> root.children:</span><br><span class="line">                root = root.children[c]</span><br><span class="line">            <span class="keyword">elif</span> root.is_end:  <span class="comment"># 当前节点没有c的边且is_end，结束</span></span><br><span class="line">                <span class="keyword">return</span> i  <span class="comment"># 返回结尾(已经+1了)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">dic, text</span>):</span></span><br><span class="line">    tree = Trie()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 创建树</span></span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> dic:</span><br><span class="line">        tree.build(token)</span><br><span class="line">    <span class="comment"># 前向匹配</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(text):</span><br><span class="line">        j = tree.search(text[i:])  <span class="comment"># 寻找i起始的最长匹配，返回结尾(已经+1了)</span></span><br><span class="line">        res.append(text[i:i+j])</span><br><span class="line">        i += j</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">dic = [<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;我们&#x27;</span>,<span class="string">&#x27;自然&#x27;</span>,<span class="string">&#x27;爱&#x27;</span>,<span class="string">&#x27;语言&#x27;</span>,<span class="string">&#x27;处理&#x27;</span>,<span class="string">&#x27;自然语言&#x27;</span>,<span class="string">&#x27;自然语言处理&#x27;</span>]</span><br><span class="line">text = <span class="string">&#x27;我们爱自然语言处理&#x27;</span></span><br><span class="line">print(partition(dic, text))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：[&#x27;我们&#x27;, &#x27;爱&#x27;, &#x27;自然语言处理&#x27;]</span></span><br></pre></td></tr></table></figure></div></div></div>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><ul>
<li>树和图的算法：<ul>
<li>递归：DFS用前序遍历、BFS用层序遍历。常用于简单题。</li>
<li>非递归：DFS用栈、BFS用队列。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 明确当前节点要做的事情，剩下的交给递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root: TreeNode</span>):</span></span><br><span class="line">    <span class="comment"># root要做什么？</span></span><br><span class="line">    <span class="comment"># 剩下交给递归</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    traverse(root.right)</span><br></pre></td></tr></table></figure>
<h2 id="前-中-后-层序遍历-144-094-145-102"><a href="#前-中-后-层序遍历-144-094-145-102" class="headerlink" title="前/中/后/层序遍历(144/094/145/102)"></a>前/中/后/层序遍历(144/094/145/102)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwv">144. 二叉树的前序遍历<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC8=">094. 二叉树的中序遍历<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wb3N0b3JkZXItdHJhdmVyc2FsLw==">145. 二叉树的后序遍历<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1sZXZlbC1vcmRlci10cmF2ZXJzYWwv">102. 二叉树的层序遍历<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你二叉树的根节点 root ，返回它节点值的 前序/中序/后序/层序 遍历。<br><div class="tabs" id="144"><ul class="nav-tabs"><li class="tab active"><a href="#144-1">前序</a></li><li class="tab"><a href="#144-2">中序</a></li><li class="tab"><a href="#144-3">后序</a></li><li class="tab"><a href="#144-4">层序</a></li></ul><div class="tab-content"><div class="tab-pane active" id="144-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.preorder(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 根左右</span></span><br><span class="line">        self.res.append(root.val)</span><br><span class="line">        self.preorder(root.left)</span><br><span class="line">        self.preorder(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 第一种方法</span></span><br><span class="line">        stack, res = [], []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="comment"># 注意先右后左，每次pop都是左节点</span></span><br><span class="line">            <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 第二种方法</span></span><br><span class="line">        stack, res = [], []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                res.append(root.val)  <span class="comment"># 先存结果</span></span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            root = node.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="144-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 由于python存在最大的递归深度约束，这一步是更改最大深度的限制</span></span><br><span class="line">        <span class="comment"># sys.setrecursionlimit(1500)</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.inorder(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 左根右</span></span><br><span class="line">        self.inorder(root.left)</span><br><span class="line">        self.res.append(root.val)</span><br><span class="line">        self.inorder(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, res = [], []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:  <span class="comment"># 当树节点不为空或栈中有节点时</span></span><br><span class="line">            <span class="keyword">while</span> root:  <span class="comment"># 每次找到最左节点结束</span></span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            root = node.right  <span class="comment"># 最左有右节点，那么它也是根，右侧也要根左右</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="144-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.postorder(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 左右根</span></span><br><span class="line">        self.postorder(root.left)</span><br><span class="line">        self.postorder(root.right)</span><br><span class="line">        self.res.append(root.val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, res = [], []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> root:  <span class="comment"># 每次先找到最左边的节点</span></span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 如果该元素的右边没有 或 已经访问过</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.right <span class="keyword">or</span> node.right <span class="keyword">is</span> pre:</span><br><span class="line">                res.append(node.val)  <span class="comment"># 访问中间的节点</span></span><br><span class="line">                pre = node  <span class="comment"># 且记录为访问过了</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(node) <span class="comment"># 重新加入该节点</span></span><br><span class="line">                root = node.right  <span class="comment"># 从右节点起始</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="144-4"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, q = [], collections.deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []  <span class="comment"># 每一层用tmp存储，最终结果为res</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="从上到下打印二叉树-I-II-III"><a href="#从上到下打印二叉树-I-II-III" class="headerlink" title="从上到下打印二叉树 I/II/III"></a>从上到下打印二叉树 I/II/III</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uZy1zaGFuZy1kYW8teGlhLWRhLXlpbi1lci1jaGEtc2h1LWxjb2Yv">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/<i class="fa fa-external-link-alt"></i></span>，<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uZy1zaGFuZy1kYW8teGlhLWRhLXlpbi1lci1jaGEtc2h1LWlpLWxjb2Yv">剑指 Offer 32 - II.从上到下打印二叉树 II<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">102. 二叉树的层序遍历<i class="fa fa-external-link-alt"></i></span>相同，<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uZy1zaGFuZy1kYW8teGlhLWRhLXlpbi1lci1jaGEtc2h1LWlpaS1sY29mLw==">剑指 Offer 32 - III. 从上到下打印二叉树 III<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtemlnemFnLWxldmVsLW9yZGVyLXRyYXZlcnNhbC8=">103. 二叉树的锯齿形层序遍历<i class="fa fa-external-link-alt"></i></span>相同。<br><strong>题目描述</strong>：<br><strong>I</strong>：从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。<br><strong>II</strong>：从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。<br><strong>III</strong>：请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。<br><div class="tabs" id="102"><ul class="nav-tabs"><li class="tab active"><a href="#102-1">层序遍历I</a></li><li class="tab"><a href="#102-2">层序遍历II</a></li><li class="tab"><a href="#102-3">层序遍历III</a></li></ul><div class="tab-content"><div class="tab-pane active" id="102-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, q = [], collections.deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="102-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, q = [], collections.deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="102-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        先用层序遍历，把每层结果存储，再把奇数行反向输出。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, q = [], collections.deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):  <span class="comment"># 每层元素存储到tmp，每层tmp存储到res</span></span><br><span class="line">                node = q.popleft()</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [res[i][::<span class="number">-1</span>]  <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> <span class="keyword">else</span> res[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res))]</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2h1LWRlLXppLWppZS1nb3UtbGNvZi8=">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br>示例 1：<br>输入：<code>A = [1,2,3], B = [3,1]</code><br>输出：<code>false</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span>(<span class="params">self, A: TreeNode, B: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        递归判断A的当前节点为根，能否构成整个B。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">A, B</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B: <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># B到头了，成功</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> A.val != B.val: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># A到头了/值不相等，不成功</span></span><br><span class="line">            <span class="keyword">return</span> recur(A.left, B.left) <span class="keyword">and</span> recur(A.right, B.right)  <span class="comment"># AB同时移动</span></span><br><span class="line">        <span class="comment"># AB不为空 且 A的根、左、右作为根，能否构成整个B</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(A <span class="keyword">and</span> B) <span class="keyword">and</span> (recur(A, B) <span class="keyword">or</span> self.isSubStructure(A.left, B) <span class="keyword">or</span> self.isSubStructure(A.right, B))</span><br></pre></td></tr></table></figure></p>
<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2FtZS10cmVlLw==">https://leetcode-cn.com/problems/same-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br>示例 1：<br>输入：<code>p = [1,2,3], q = [1,2,3]</code><br>输出：<code>true</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p: TreeNode, q: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q: <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 两个都为空，True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q <span class="keyword">or</span> <span class="keyword">not</span> p <span class="keyword">or</span> p.val != q.val: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 一个为空/值不相等，False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure></p>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLWJpbmFyeS10cmVlcy8=">https://leetcode-cn.com/problems/merge-two-binary-trees/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。注意: 合并过程必须从两个树的根节点开始。</p>
<p>示例 1：<br>输入：<code>root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</code><br>输出：<code>[3,4,5,5,4,null,7]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, root1: TreeNode, root2: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当前节点计算和作为新节点返回，接着计算左、右子节点，两个有一个为空，返回另一个。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1: <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root2: <span class="keyword">return</span> root1</span><br><span class="line"></span><br><span class="line">        node = TreeNode(root1.val + root2.val)</span><br><span class="line">        node.left = self.mergeTrees(root1.left, root2.left)</span><br><span class="line">        node.right = self.mergeTrees(root1.right, root2.right)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></p>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS8=">https://leetcode.cn/problems/symmetric-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个二叉树的根节点 root ， 检查它是否轴对称。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.recursion(root, root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursion</span>(<span class="params">self, root1: TreeNode, root2: TreeNode</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2: <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 都为空，为对称</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">or</span> <span class="keyword">not</span> root2 <span class="keyword">or</span> root1.val!=root2.val: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 只有一个为空/节点值不同，必定不对称</span></span><br><span class="line">        <span class="comment"># 左子树的左孩子==右子树的右孩子 and 左子树的右孩子==右子树的左孩子</span></span><br><span class="line">        <span class="keyword">return</span> self.recursion(root1.left, root2.right) <span class="keyword">and</span> self.recursion(root1.right, root2.left)</span><br></pre></td></tr></table></figure></p>
<h2 id="226-翻转二叉树-镜像"><a href="#226-翻转二叉树-镜像" class="headerlink" title="226. 翻转二叉树(镜像)"></a>226. 翻转二叉树(镜像)</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW52ZXJ0LWJpbmFyeS10cmVlLw==">https://leetcode-cn.com/problems/invert-binary-tree/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS1qaW5nLXhpYW5nLWxjb2Yv">剑指 Offer 27. 二叉树的镜像<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。请完成一个函数，输入一个二叉树，该函数输出它的镜像。<br>示例 1：<br>输入：<code>root = [4,2,7,1,3,6,9]</code><br>输出：<code>[4,7,2,9,6,3,1]</code></p>
<div class="tabs" id="226"><ul class="nav-tabs"><li class="tab active"><a href="#226-1">递归</a></li><li class="tab"><a href="#226-2">队列</a></li></ul><div class="tab-content"><div class="tab-pane active" id="226-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从下到上翻转。</span></span><br><span class="line"><span class="string">        既然返回根节点，那么一定是return root，中间要做的是递归子节点翻转，之后再翻转本节点子节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 先递归子树</span></span><br><span class="line">        left = self.invertTree(root.left)</span><br><span class="line">        right = self.invertTree(root.right)</span><br><span class="line">        <span class="comment"># 再翻转</span></span><br><span class="line">        root.left, root.right = right, left </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="226-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从上到下翻转。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="comment"># 每次都从队列中拿第一个节点</span></span><br><span class="line">            tmp = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 如果当前节点的左子树不为空，则放入队列等待后续处理</span></span><br><span class="line">            <span class="keyword">if</span> tmp.left:</span><br><span class="line">                queue.append(tmp.left)</span><br><span class="line">            <span class="comment"># 如果当前节点的右子树不为空，则放入队列等待后续处理	</span></span><br><span class="line">            <span class="keyword">if</span> tmp.right:</span><br><span class="line">                queue.append(tmp.right)</span><br><span class="line">            <span class="comment"># 交换这个节点的左右子树</span></span><br><span class="line">            tmp.left,tmp.right = tmp.right,tmp.left</span><br><span class="line">        <span class="comment"># 返回处理完的根节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv">https://leetcode-cn.com/problems/balanced-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。<br>示例 1：<br>输入：<code>root = [3,9,20,null,null,15,7]</code><br>输出：<code>true</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        计算树的高度，从低-&gt;高计算(从高-&gt;低会多算一次)，所以先递归到底，再计算。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = height(root.left)</span><br><span class="line">            right = height(root.right)</span><br><span class="line">            <span class="comment"># 左/右不是平衡，返回-1</span></span><br><span class="line">            <span class="keyword">if</span> left==<span class="number">-1</span> <span class="keyword">or</span> right==<span class="number">-1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(left-right)&gt;<span class="number">1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="built_in">max</span>(left, right)+<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> height(root) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a>654. 最大二叉树</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1iaW5hcnktdHJlZS8=">https://leetcode-cn.com/problems/maximum-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建：<br>（1）创建一个根节点，其值为 nums 中的最大值。<br>（2）递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>（3）递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> nums == []: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 找出最大值和其索引</span></span><br><span class="line">        max_num = <span class="built_in">max</span>(nums)</span><br><span class="line">        max_index = nums.index(max_num)</span><br><span class="line">        root = TreeNode(max_num) </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        root.left = self.constructMaximumBinaryTree(nums[<span class="number">0</span> : max_index])</span><br><span class="line">        root.right = self.constructMaximumBinaryTree(nums[max_index + <span class="number">1</span> :])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="112-113-路径总和-I-II"><a href="#112-113-路径总和-I-II" class="headerlink" title="112/113. 路径总和 I/II"></a>112/113. 路径总和 I/II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS8=">112. 路径总和<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paS8=">113. 路径总和 II<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，判断、找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。<strong>叶子节点</strong> 是指没有子节点的节点。<br><div class="tabs" id="112"><ul class="nav-tabs"><li class="tab active"><a href="#112-1">判断(I)</a></li><li class="tab"><a href="#112-2">找出(II)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="112-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: Optional[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 叶子节点，路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="comment"># 递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum-root.val)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="112-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: Optional[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        ret, path = [], []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root: TreeNode, target: <span class="built_in">int</span></span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            path.append(root.val)  <span class="comment"># 路径更新</span></span><br><span class="line">            target -= root.val  <span class="comment"># 更新</span></span><br><span class="line">            <span class="comment"># 如果递归当前节点为叶子节点且该条路径的值已经达到了target，则更新ret</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> target==<span class="number">0</span>: ret.append(path[:])</span><br><span class="line">            <span class="comment"># 左右子树递归</span></span><br><span class="line">            dfs(root.left, target)</span><br><span class="line">            dfs(root.right, target)</span><br><span class="line">            path.pop()  <span class="comment"># 回溯取消</span></span><br><span class="line">        dfs(root, targetSum)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。<br>示例：给定二叉树 <code>[3,9,20,null,null,15,7]</code>，返回它的最大深度 3 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当前高度 = max(左,右)+1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.maxDepth(root.left) </span><br><span class="line">        right = self.maxDepth(root.right) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span> </span><br></pre></td></tr></table></figure></p>
<h2 id="508-出现次数最多的子树元素和"><a href="#508-出现次数最多的子树元素和" class="headerlink" title="508. 出现次数最多的子树元素和"></a>508. 出现次数最多的子树元素和</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbW9zdC1mcmVxdWVudC1zdWJ0cmVlLXN1bS8=">https://leetcode-cn.com/problems/most-frequent-subtree-sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个二叉树的根结点 root ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。<br>示例 1：<br>输入: <code>root = [5,2,-3]</code><br>输出: <code>[2,-3,4]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findFrequentTreeSum</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        求出二叉树所有子树（包含根节点的树）的元素和，然后求出现次数最多的 元素和，且最多出现次数相同的 元素和 都要输出。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 递归计算节点和</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            sums = dfs(node.left) + node.val + dfs(node.right)</span><br><span class="line">            res[sums] = res.get(sums, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> sums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="comment"># 最多出现次数</span></span><br><span class="line">        max_cnt = <span class="built_in">max</span>(res.values())</span><br><span class="line">        <span class="comment"># 最多出现次 对应的 key</span></span><br><span class="line">        <span class="keyword">return</span> [key <span class="keyword">for</span> key, cnt <span class="keyword">in</span> res.items() <span class="keyword">if</span> cnt==max_cnt]   </span><br></pre></td></tr></table></figure></p>
<h2 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a>297. 二叉树的序列化与反序列化</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2VyaWFsaXplLWFuZC1kZXNlcmlhbGl6ZS1iaW5hcnktdHJlZS8=">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个<strong>字符串</strong>并且将这个<strong>字符串</strong>反序列化为原始的树结构。<br>示例 1：<br>输入：<code>root = [1,2,3,null,null,4,5]</code><br>输出：<code>[1,2,3,null,null,4,5]</code></p>
<p>注意：中序遍历无法反序列化，因为首先要找到根节点，前序遍历首节点、后序遍历尾节点为根节点，而中序遍历列表，无法找到根节点。<br><div class="tabs" id="297"><ul class="nav-tabs"><li class="tab active"><a href="#297-1">前序遍历</a></li><li class="tab"><a href="#297-2">后序遍历</a></li><li class="tab"><a href="#297-3">层序遍历</a></li></ul><div class="tab-content"><div class="tab-pane active" id="297-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根左右。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ser</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;root.val&#125;</span>,<span class="subst">&#123;ser(root.left)&#125;</span>,<span class="subst">&#123;ser(root.right)&#125;</span>&quot;</span> </span><br><span class="line">        <span class="keyword">return</span> ser(root) </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">des</span>(<span class="params">nodes</span>):</span></span><br><span class="line">            first = nodes.popleft()   <span class="comment"># 根</span></span><br><span class="line">            <span class="keyword">if</span> first <span class="keyword">and</span> first == <span class="string">&#x27;#&#x27;</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(first))</span><br><span class="line">            root.left = des(nodes)  <span class="comment"># 左</span></span><br><span class="line">            root.right = des(nodes)  <span class="comment"># 右</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        nodes = deque(data.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> des(nodes)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="297-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    左右根，反向递归。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">ser</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">&quot;#&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;ser(root.left)&#125;</span>,<span class="subst">&#123;ser(root.right)&#125;</span>,<span class="subst">&#123;root.val&#125;</span>&quot;</span> </span><br><span class="line">        <span class="keyword">return</span> ser(root) </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">des</span>(<span class="params">nodes</span>):</span></span><br><span class="line">            first = nodes.pop()  <span class="comment"># 根</span></span><br><span class="line">            <span class="keyword">if</span> first <span class="keyword">and</span> first == <span class="string">&#x27;#&#x27;</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root = TreeNode(<span class="built_in">int</span>(first))</span><br><span class="line">            root.right = des(nodes)  <span class="comment"># 右</span></span><br><span class="line">            root.left = des(nodes)  <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        nodes = deque(data.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> des(nodes)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="297-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        q = deque([root])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                res.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="built_in">str</span>(cur.val))</span><br><span class="line">            q.append(cur.left)</span><br><span class="line">            q.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(res)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        nodes = data.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nodes <span class="keyword">or</span> nodes[<span class="number">0</span>]==<span class="string">&#x27;#&#x27;</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(nodes[<span class="number">0</span>])</span><br><span class="line">        q = collections.deque([root])</span><br><span class="line">        <span class="comment"># 根左右，需同时表示</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nodes), <span class="number">2</span>):  <span class="comment"># 每次添加左右两个子节点</span></span><br><span class="line">            node = q.popleft()</span><br><span class="line">            left = nodes[i]</span><br><span class="line">            right = nodes[i+<span class="number">1</span>]   </span><br><span class="line">            <span class="keyword">if</span> left != <span class="string">&#x27;#&#x27;</span>:  <span class="comment"># 左</span></span><br><span class="line">                node.left = TreeNode(left)</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> right != <span class="string">&#x27;#&#x27;</span>:  <span class="comment"># 右</span></span><br><span class="line">                node.right = TreeNode(right)</span><br><span class="line">                q.append(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20tcHJlb3JkZXItYW5kLWlub3JkZXItdHJhdmVyc2FsLw==">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。<br>示例 1:<br>输入: <code>preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</code><br>输出: <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[<span class="built_in">int</span>], inorder: List[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        前序遍历：第一个为根节点</span></span><br><span class="line"><span class="string">        中序遍历：找到根节点索引k，其左侧为左子树(0~k-1,k个元素)，右侧为右子树(k+1~结尾)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])  <span class="comment"># 创建根节点</span></span><br><span class="line">        k = inorder.index(preorder[<span class="number">0</span>]) <span class="comment"># 找到根节点在index索引，左子树有k个元素</span></span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:k+<span class="number">1</span>], inorder[<span class="number">0</span>:k])  </span><br><span class="line">        root.right = self.buildTree(preorder[k+<span class="number">1</span>:], inorder[k+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv">https://leetcode.cn/problems/binary-tree-right-side-view/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        res, q = [], collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                tmp.append(node)</span><br><span class="line">                <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            res.append(tmp[<span class="number">-1</span>].val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="098-验证二叉搜索树"><a href="#098-验证二叉搜索树" class="headerlink" title="098. 验证二叉搜索树"></a>098. 验证二叉搜索树</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWRhdGUtYmluYXJ5LXNlYXJjaC10cmVlLw==">https://leetcode-cn.com/problems/validate-binary-search-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>（1）节点的左子树只包含 <strong>小于</strong> 当前节点的数。<br>（2）节点的右子树只包含 <strong>大于</strong> 当前节点的数。<br>（3）所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>示例 1：<br>输入：<code>root = [5,1,4,null,null,3,6]</code><br>输出：<code>false</code><br>解释：根节点的值是 5 ，但是右子节点的值是 4 。<br><div class="tabs" id="98"><ul class="nav-tabs"><li class="tab active"><a href="#98-1">递归1</a></li><li class="tab"><a href="#98-2">递归2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="98-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    pre = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        利用中序遍历[左根右]判断，二叉搜索树的中序遍历结果是递增的。</span></span><br><span class="line"><span class="string">        中序遍历时记录前一个值，当前值&gt;前一个值 时满足二叉搜索树。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 先进入左子树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isValidBST(root.left): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 当前值&lt;=前一个值，不满足二叉搜索树中序递增</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= self.pre: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.pre = root.val </span><br><span class="line">        <span class="comment"># 再进入右子树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isValidBST(root.right): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="98-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 自定义一个带min和max的函数，每次递归判断</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node:TreeNode, <span class="built_in">min</span>:TreeNode, <span class="built_in">max</span>:TreeNode</span>) -&gt; bool:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">min</span> <span class="keyword">and</span> (node.val&lt;=<span class="built_in">min</span>.val): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">max</span> <span class="keyword">and</span> (node.val&gt;=<span class="built_in">max</span>.val): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> helper(node.left, <span class="built_in">min</span>, node) <span class="keyword">and</span> helper(node.right, node, <span class="built_in">max</span>)</span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="literal">None</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2VhcmNoLWluLWEtYmluYXJ5LXNlYXJjaC10cmVlLw==">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>
<p>示例 1:<br>输入：<code>root = [4,2,7,1,3], val = 2</code><br>输出：<code>[2,1,3]</code></p>
<div class="tabs" id="700"><ul class="nav-tabs"><li class="tab active"><a href="#700-1">递归</a></li><li class="tab"><a href="#700-2">迭代</a></li></ul><div class="tab-content"><div class="tab-pane active" id="700-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> val == root.val: <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 根据搜索树左小右大，进行递归</span></span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root.left <span class="keyword">if</span> val &lt; root.val <span class="keyword">else</span> root.right, val)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="700-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> val == root.val:<span class="keyword">return</span> root</span><br><span class="line">            root = root.left <span class="keyword">if</span> val &lt; root.val <span class="keyword">else</span> root.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLXNtYWxsZXN0LWVsZW1lbnQtaW4tYS1ic3Qv">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<p>输入：<code>root = [3,1,4,null,2], k = 1</code><br>输出：<code>1</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LWRlLWRpLWtkYS1qaWUtZGlhbi1sY29mLw==">剑指 Offer 54. 二叉搜索树的第k大节点<i class="fa fa-external-link-alt"></i></span>和本题相反，求第K大，中序遍历结果是由小到大，反序由大到小，即求中序遍历倒数第k的值。<br><div class="tabs" id="230"><ul class="nav-tabs"><li class="tab active"><a href="#230-1">K小，中序递归</a></li><li class="tab"><a href="#230-2">K大，中序递归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="230-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: Optional[TreeNode], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        res记录结果，count记录经过节点数目</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.count == <span class="number">0</span>:</span><br><span class="line">                self.res = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.right)</span><br><span class="line"></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.count = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="230-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">self, root: TreeNode, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        此树的中序遍历倒序的第 k 个节点，</span></span><br><span class="line"><span class="string">        可反着中序遍历，右根左</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">            dfs(root.right)  <span class="comment"># 先右</span></span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.count == <span class="number">0</span>:</span><br><span class="line">                self.res = root.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)  <span class="comment"># 后左</span></span><br><span class="line"></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        self.count = k</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a>701. 二叉搜索树中的插入操作</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW5zZXJ0LWludG8tYS1iaW5hcnktc2VhcmNoLXRyZWUv">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p>示例 1：<br>输入：<code>root = [4,2,7,1,3], val = 5</code><br>输出：<code>[4,2,7,1,3,5]</code>/<code>[5,2,7,1,3,4]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val) <span class="comment"># 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span></span><br><span class="line">        <span class="keyword">if</span>  val &gt; root.val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val) <span class="comment"># 递归创建右子树</span></span><br><span class="line">        <span class="keyword">if</span> val &lt; root.val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val) <span class="comment"># 递归创建左子树</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a>450. 删除二叉搜索树中的节点</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGVsZXRlLW5vZGUtaW4tYS1ic3Qv">https://leetcode-cn.com/problems/delete-node-in-a-bst/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉搜索树的根节点 <code>root</code> 和一个值 <code>key</code>，删除二叉搜索树中的 <code>key</code> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：首先找到需要删除的节点；如果找到了，删除它。</p>
<p>示例 1:<br>输入：<code>root = [5,3,6,2,4,null,7], key = 3</code><br>输出：<code>[5,4,6,2,null,null,7]</code><br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。另一个正确答案是 <code>[5,2,6,null,4,null,7]</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: Optional[TreeNode], key: <span class="built_in">int</span></span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 找到节点时</span></span><br><span class="line">        <span class="keyword">if</span> key == root.val:</span><br><span class="line">            <span class="comment"># 找到节点时，其有1个/0个子节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left: <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="comment"># 找到节点时，其有2个子节点，可找 左侧最大/右侧最小 作为新节点，这里选右侧最小</span></span><br><span class="line">            minNode = self.getRightMin(root.right)</span><br><span class="line">            root.val = minNode.val</span><br><span class="line">            root.right = self.deleteNode(root.right, minNode.val)</span><br><span class="line">        <span class="comment"># 没找到节点时，递归</span></span><br><span class="line">        <span class="keyword">elif</span> key &gt; root.val:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> key &lt; root.val:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRightMin</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">while</span> node.left: node = node.left</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></p>
<h2 id="235-236-二叉-搜索树-的最近公共祖先"><a href="#235-236-二叉-搜索树-的最近公共祖先" class="headerlink" title="235/236. 二叉(搜索树)的最近公共祖先"></a>235/236. 二叉(搜索树)的最近公共祖先</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">235. 二叉搜索树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LWRlLXp1aS1qaW4tZ29uZy1nb25nLXp1LXhpYW4tbGNvZi8=">剑指 Offer 68 - I. 二叉搜索树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>，<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS10cmVlLw==">236. 二叉树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWxjb2Yv">剑指 Offer 68 - II. 二叉树的最近公共祖先<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给定一个二叉(搜索树), 找到该树中两个指定节点的最近公共祖先。最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>二叉树看这个解答：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWxjb2Yvc29sdXRpb24vbWlhbi1zaGktdGktNjgtaWktZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uLTcv">Krahets 题解<i class="fa fa-external-link-alt"></i></span>。<br><div class="tabs" id="235"><ul class="nav-tabs"><li class="tab active"><a href="#235-1">二叉搜索树</a></li><li class="tab"><a href="#235-2">二叉树</a></li></ul><div class="tab-content"><div class="tab-pane active" id="235-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当p和p在一个节点两侧时，此节点为最近公共祖先。</span></span><br><span class="line"><span class="string">        利用二叉搜索树性质，左小右大。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> p.val &lt; node.val <span class="keyword">and</span> q.val &lt; node.val:  <span class="comment"># pq都在该节点的左边</span></span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">elif</span> p.val &gt; node.val <span class="keyword">and</span> q.val &gt; node.val:  <span class="comment"># pq都在该节点的右边</span></span><br><span class="line">                node = node.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># pq在该节点两边说明node就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="235-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1.root为空，说明结束，返回None</span></span><br><span class="line"><span class="string">        2.root为p/q，说明root为最近公共祖先，返回root</span></span><br><span class="line"><span class="string">        left, right：</span></span><br><span class="line"><span class="string">            3.都为空：说明左,右子树都不包含q,p，返回None</span></span><br><span class="line"><span class="string">            4.都不为空：说明p,q在root为根的两侧，返回root</span></span><br><span class="line"><span class="string">            5.有一个为空：说明q,q都在另一个不空的树，返回不空的结果</span></span><br><span class="line"><span class="string">        5中包括了3。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 该子树没找到</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q: <span class="keyword">return</span> root  <span class="comment"># 该节点是其中某一个节点</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)  <span class="comment"># 左子树寻找公共祖先</span></span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)  <span class="comment"># 右子树寻找公共祖先</span></span><br><span class="line">        <span class="keyword">if</span> left==<span class="number">-1</span>: <span class="keyword">return</span> right  <span class="comment"># 左子树没找到，则在右子树中</span></span><br><span class="line">        <span class="keyword">if</span> right==<span class="number">-1</span>: <span class="keyword">return</span> left  <span class="comment"># 右子树没找到，则在左子树中</span></span><br><span class="line">        <span class="keyword">return</span> root  <span class="comment"># 否则是当前节点</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LXl1LXNodWFuZy14aWFuZy1saWFuLWJpYW8tbGNvZi8=">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">treeToDoublyList</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">cur</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 递归左子树</span></span><br><span class="line">            dfs(cur.left) </span><br><span class="line">            <span class="comment"># 修改节点引用：当前节点前驱、上一节点后继</span></span><br><span class="line">            <span class="keyword">if</span> self.pre:</span><br><span class="line">                cur.left = self.pre</span><br><span class="line">                self.pre.right  = cur </span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 没有pre，为头节点</span></span><br><span class="line">                self.head = cur</span><br><span class="line">            self.pre = cur <span class="comment"># 保存cur为下一节点pre</span></span><br><span class="line">            <span class="comment"># 递归右子树</span></span><br><span class="line">            dfs(cur.right) </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="comment"># 结束时处理head：最后节点的后继为head，head的前驱为最后节点</span></span><br><span class="line">        self.pre.right = self.head</span><br><span class="line">        self.head.left = self.pre</span><br><span class="line">        <span class="keyword">return</span> self.head</span><br></pre></td></tr></table></figure></p>
<h2 id="958-二叉树的完全性检验"><a href="#958-二叉树的完全性检验" class="headerlink" title="958. 二叉树的完全性检验"></a>958. 二叉树的完全性检验</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jaGVjay1jb21wbGV0ZW5lc3Mtb2YtYS1iaW5hcnktdHJlZS8=">https://leetcode.cn/problems/check-completeness-of-a-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉树的 root ，确定它是否是一个 完全二叉树 。完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        如果某层出现None节点后，出现非None节点，那么一定不是完全二叉树。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 空树一定是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        q = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> node: q.extend([node.left, node.right])</span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="keyword">not</span> <span class="built_in">any</span>(q)  <span class="comment"># 当前节点为空时，q剩余节点有非空，不是完全二叉树</span></span><br></pre></td></tr></table></figure></p>
<h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtY29tcGxldGUtdHJlZS1ub2Rlcy8=">https://leetcode-cn.com/problems/count-complete-tree-nodes/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~2^h</code> 个节点。<br>示例 1：<br>输入：<code>root = [1,2,3,4,5,6]</code><br>输出：<code>6</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        根据完全二叉树性质，其有右节点必有左节点(建树时先左后右)，</span></span><br><span class="line"><span class="string">        所以有右节点高度和左节点高度对比，能确定是不是满二叉树。</span></span><br><span class="line"><span class="string">        其次，左侧的递归一定会触发hl == hr而立即返回，不会递归下去，</span></span><br><span class="line"><span class="string">        所以只有右侧会递归，时间复杂度为log(n)。</span></span><br><span class="line"><span class="string">        总体时间复杂度：while的log(n)和递归log(n)，O(log(n)*log(n))。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = r = root</span><br><span class="line">        hl = hr = <span class="number">0</span>  <span class="comment"># 记录左右子树高度</span></span><br><span class="line">        <span class="keyword">while</span> l: </span><br><span class="line">            l = l.left</span><br><span class="line">            hl += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r:</span><br><span class="line">            r = r.right  </span><br><span class="line">            hr += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果左右子树高度相同，说明是一棵满二叉树</span></span><br><span class="line">        <span class="keyword">if</span> hl == hr: <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">pow</span>(<span class="number">2</span>,hl)<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 如果左右子树高度相同，按照普通二叉树逻辑计算</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + self.countNodes(root.left) + self.countNodes(root.right)</span><br></pre></td></tr></table></figure></p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><strong>单调递减栈</strong>：栈底到栈顶（入栈和出栈）是递减的，遇到大的pop栈中小的，再存储大的。从左到右，能得到当前值右侧第一个比其大的值。<br><strong>单调递增栈</strong>：栈底到栈顶（入栈和出栈）是递增的，遇到小的pop栈中大的，再存储小的。从左到右，能得到当前值右侧第一个比其小的值。<br><strong>注意</strong>：有些题解中的单调栈和上面解释<strong>相反</strong>，但本质都是找边界，理解核心最重要。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模板，求nums下一个更大元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums:List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">-1</span>] * n  <span class="comment"># 存放结果</span></span><br><span class="line">        stack = [] <span class="comment"># 单调递减</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算每个位置下一更大元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]]&lt;nums[i]:  <span class="comment"># num不符合单调递减</span></span><br><span class="line">                small = stack.pop()</span><br><span class="line">                res[small] = nums[i]</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tc3RhY2sv">https://leetcode.cn/problems/min-stack/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>实现 MinStack 类:<br><code>MinStack()</code> 初始化堆栈对象。<br><code>void push(int val)</code> 将元素val推入堆栈。<br><code>void pop()</code> 删除堆栈顶部的元素。<br><code>int top()</code> 获取堆栈顶部的元素。<br><code>int getMin()</code> 获取堆栈中的最小元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.s1 = []  <span class="comment"># 进入栈的元素</span></span><br><span class="line">        self.s2 = []  <span class="comment"># 每次push后，整体最小值(递减栈，栈顶(右)为最小值)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.s1.append(val) </span><br><span class="line">        <span class="comment"># push后，整体最小值放入s2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.s2 <span class="keyword">or</span> self.s2[<span class="number">-1</span>]&gt;val: </span><br><span class="line">            self.s2.append(val)</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            self.s2.append(self.s2[<span class="number">-1</span>]) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.s1.pop()</span><br><span class="line">        self.s2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.s1[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; int:</span></span><br><span class="line">         <span class="keyword">return</span> self.s2[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLWVsZW1lbnQtaS8=">https://leetcode-cn.com/problems/next-greater-element-i/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <code>0</code> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <code>下一个更大元素</code> 。<br>示例 1：<br>输入：<code>nums1 = [4,1,2], nums2 = [1,3,4,2]</code><br>输出：<code>[-1,3,-1]</code><br>解释：nums1 中每个值的下一个更大元素如下所述：<br>4 ，用加粗斜体标识，<code>nums2 = [1,3,4,2]</code>。不存在下一个更大元素，所以答案是 -1 。<br>1 ，用加粗斜体标识，<code>nums2 = [1,3,4,2]</code>。下一个更大元素是 3 。<br>2 ，用加粗斜体标识，<code>nums2 = [1,3,4,2]</code>。不存在下一个更大元素，所以答案是 -1 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        本质上nums2自己找下一更大元素，最后用nums1匹配。</span></span><br><span class="line"><span class="string">        因为nums2计算完下一最大值后，找nums1相同值对应的下一最大值，所以用哈希表存储结果(key判断相同值)。</span></span><br><span class="line"><span class="string">        res：&#123;值：值对应下一最大值&#125;。</span></span><br><span class="line"><span class="string">        stack：存值。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = &#123;&#125;  <span class="comment"># 记录nums2元素下一更大值</span></span><br><span class="line">        stack = []  <span class="comment"># 单调递减栈</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="comment"># 不是递减，num为栈中所有元素下一更大值</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>]&lt;num:  </span><br><span class="line">                small = stack.pop()</span><br><span class="line">                res[small] = num</span><br><span class="line">            stack.append(num)</span><br><span class="line">        <span class="comment"># 在nums1中找到res对应的值</span></span><br><span class="line">        <span class="keyword">return</span> [res[num] <span class="keyword">if</span> num <span class="keyword">in</span> res <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure></p>
<h2 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a>503. 下一个更大元素 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLWVsZW1lbnQtaWkv">https://leetcode-cn.com/problems/next-greater-element-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个<strong>循环数组</strong> <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <code>nums</code> 中每个元素的 <strong>下一个更大元素</strong> 。数字 <code>x</code> 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。<br>示例 1:<br>输入: <code>nums = [1,2,1]</code><br>输出: <code>[2,-1,2]</code><br>解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环数组，在计算 nums[i] 时，也要把该序列的前 n-1 个元素考虑进去，最远走n+n-1步。</span></span><br><span class="line"><span class="string">        下标按n折半取余就是循环下标。</span></span><br><span class="line"><span class="string">        res：下标对应值的下一最大值。</span></span><br><span class="line"><span class="string">        stack：存下标。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">-1</span>] * n</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*n<span class="number">-1</span>):</span><br><span class="line">            idx = i%n</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]]&lt;nums[idx]:</span><br><span class="line">                res[stack.pop()] = nums[idx]</span><br><span class="line">            stack.append(idx)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a>1019. 链表中的下一个更大节点</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLW5vZGUtaW4tbGlua2VkLWxpc3Qv">https://leetcode-cn.com/problems/next-greater-node-in-linked-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个长度为 <code>n</code> 的链表 <code>head</code>。对于列表中的每个节点，查找下一个 <strong>更大节点</strong> 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 <strong>严格大于</strong> 它的值。返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个节点( 从1开始 )的下一个更大的节点的值。如果第 <code>i</code> 个节点没有下一个更大的节点，设置 <code>answer[i] = 0</code> 。</p>
<p>示例 1：<br>输入：<code>head = [2,1,5]</code><br>输出：<code>[5,5,0]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLW5vZGUtaW4tbGlua2VkLWxpc3Qvc29sdXRpb24vcHl0aG9uLWRhbi1kaWFvLXpoYW4tYnktamFja3dlbmVyLw==">jackvin题解<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLW5vZGUtaW4tbGlua2VkLWxpc3Qvc29sdXRpb24vMTAxOS1saWFuLWJpYW8temhvbmctZGUteGlhLXlpLWdlLWdlbmctZGEtamllLWRpYW4v">tuotuoli题解<i class="fa fa-external-link-alt"></i></span>。</p>
<p><strong>题目解析</strong>：</p>
<ul>
<li>题目是链表，可以转成列表(模拟栈)。</li>
<li><strong>正向思维</strong>：假如列表是<code>[5,4,7,4,3,6]</code>，<strong>正序</strong>入栈是<code>[5,4]</code>这样单调递减的，直到不是单调递减的<code>[7]</code>，表示<code>[7]</code>比栈顶大且索引是最小的，此时pop栈顶<code>[4]</code>, 记录<code>[4]</code>对应索引值结果为<code>[7]</code>，再判断栈顶<code>[5]&lt;=[7]</code>，也pop栈顶<code>[5]</code>, 记录<code>[5]</code>对应索引值结果为<code>[7]</code>，直到 <strong>栈为空</strong> 或 <strong>栈顶&gt;当前值</strong> 再继续把当前值入栈比较。</li>
<li><strong>逆向思维</strong>：列表<strong>逆序</strong>入栈，列表同上，栈起始值应为<code>[0]</code>, <code>[6]</code>为最后一个元素（后面没有比它大的了所以对应位置结果直接写<code>[0]</code>），入栈<code>[0,6]</code>，当遇到<strong>栈顶&gt;当前元素</strong>（<code>[6]&gt;[3]</code>），表示<code>[3]</code>后面第一个大于它的是<code>[6]</code>，此时<code>[3]</code>先入栈，再更新列表<code>[3]</code>为<code>[6]</code>。</li>
</ul>
<div class="tabs" id="1019"><ul class="nav-tabs"><li class="tab active"><a href="#1019-1">正向单调栈</a></li><li class="tab"><a href="#1019-2">逆向单调栈</a></li></ul><div class="tab-content"><div class="tab-pane active" id="1019-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span>(<span class="params">self, head: ListNode</span>) -&gt; List[int]:</span></span><br><span class="line">        cur = head</span><br><span class="line">        ans = []  <span class="comment"># 存结果</span></span><br><span class="line">        stack = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 当 栈不为空，且 当前节点值&gt;栈最后一个值 时，存储</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">1</span>] &lt; cur.val:</span><br><span class="line">                ans[stack[<span class="number">-1</span>][<span class="number">0</span>]] = cur.val</span><br><span class="line">                stack.pop()</span><br><span class="line">            stack.append((i, cur.val))  <span class="comment"># 入栈(索引, 值)</span></span><br><span class="line">            ans.append(<span class="number">0</span>)  <span class="comment"># 每入栈一个，就在结果中添加一个占位值0</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="1019-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span>(<span class="params">self, head: ListNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 链表转列表，起始栈为[0]，栈存储当前元素之后的元素</span></span><br><span class="line">        vals, stack = [], [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            vals.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 逆序遍历   </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vals)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 栈顶元素&lt;=当前元素，表示栈顶不是要找的元素，pop掉</span></span><br><span class="line">            <span class="keyword">while</span> stack[<span class="number">-1</span>] <span class="keyword">and</span> vals[i] &gt;= stack[<span class="number">-1</span>]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="comment"># 栈顶元素&gt;当前元素，表示栈顶是当前元素下一个更大值，先入栈，再更新</span></span><br><span class="line">            stack.append(vals[i])</span><br><span class="line">            vals[i] = stack[<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vals</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGFpbHktdGVtcGVyYXR1cmVzLw==">https://leetcode-cn.com/problems/daily-temperatures/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指在第 <code>i</code> 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<p>示例 1:<br>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    栈记录索引pre，遇到第一个温度比其高的索引i，相差天数：i-pre</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span>(<span class="params">self, temperatures: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[stack[<span class="number">-1</span>]]&lt;temperatures[i]:</span><br><span class="line">                pre = stack.pop()</span><br><span class="line">                res[pre] = i - pre</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure></p>
<h2 id="907-子数组的最小值之和"><a href="#907-子数组的最小值之和" class="headerlink" title="907. 子数组的最小值之和"></a>907. 子数组的最小值之和</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VtLW9mLXN1YmFycmF5LW1pbmltdW1zLw==">https://leetcode-cn.com/problems/sum-of-subarray-minimums/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code> 的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。由于答案可能很大，因此 返回答案模 <code>10^9+7</code> 。<br>示例 1：<br>输入：<code>arr = [3,1,2,4]</code><br>输出：<code>17</code><br>解释：<br>子数组为 <code>[3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]</code>。<br>最小值为 <code>3，1，2，4，1，1，2，1，1，1</code>，和为 <code>17</code>。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VtLW9mLXN1YmFycmF5LW1pbmltdW1zL3NvbHV0aW9uL3hpYW8tYmFpLWxhbmctZG9uZy1odWEteGlhbmctamllLWJhby16aGUtNDg5cS8=">超小白 讲解<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VtLW9mLXN1YmFycmF5LW1pbmltdW1zL3NvbHV0aW9uL3B5dGhvbjMtdG9uZy04NHRpLXp1aS1kYS16aGktZmFuZy10dS1ieS01ZXJzdy8=">Justin Yuan 代码<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubarrayMins</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        arr = [<span class="number">-1</span>] + arr + [<span class="number">-1</span>]  <span class="comment"># 防止左侧越界、防止右侧留存在栈中(栈不为空结束)</span></span><br><span class="line">        stack, res = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="comment"># 确定右边界：当前值作为最小值，右边界就是比其小的（这中间都是比其大的）</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> arr[i]&lt;arr[stack[<span class="number">-1</span>]]:</span><br><span class="line">                cur = stack.pop() <span class="comment"># 当前值索引</span></span><br><span class="line">                <span class="comment"># 下面stack[-1]为左边界，res=当前值*贡献次数(右边界到当前值个数*当前值到左边界个数)</span></span><br><span class="line">                res += arr[cur]*(i-cur)*(cur-stack[<span class="number">-1</span>]) </span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a>402. 移掉 K 位数字</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWstZGlnaXRzLw==">https://leetcode-cn.com/problems/remove-k-digits/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。<br>示例 1 ：<br>输入：<code>num = &quot;1432219&quot;, k = 3</code><br>输出：<code>&quot;1219&quot;</code><br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWstZGlnaXRzL3NvbHV0aW9uL3lpLXpoYW8tY2hpLWJpYW4tbGkta291LXNpLWRhby10aS1tYS1tYS16YWkteWUtYi01Lw==">fe-lucifer 题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span>(<span class="params">self, num: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        remain = <span class="built_in">len</span>(num)-k</span><br><span class="line">        <span class="comment"># 单调递增栈，遇到小的把大的弹出，弹出个数为k个结束</span></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; digit:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(digit)</span><br><span class="line">        <span class="comment"># 保留栈中前n-k个数，最后结果左边去0即为正常数</span></span><br><span class="line">        <span class="comment"># 如果结果为&#x27;&#x27;，应当返回&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stack[:remain]).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="768-最多能完成排序的块-II"><a href="#768-最多能完成排序的块-II" class="headerlink" title="768. 最多能完成排序的块 II"></a>768. 最多能完成排序的块 II</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LWNodW5rcy10by1tYWtlLXNvcnRlZC1paS8=">https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<code>arr</code> 是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。我们最多能将数组分成多少块？</p>
<p>示例 1:<br>输入: <code>arr = [5,4,3,2,1]</code><br>输出: <code>1</code><br>解释: 将数组分成2块或者更多块，都无法得到所需的结果。例如，分成 <code>[5, 4], [3, 2, 1]</code> 的结果是 <code>[4, 5, 1, 2, 3]</code>，这不是有序的数组。<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LWNodW5rcy10by1tYWtlLXNvcnRlZC1paS9zb2x1dGlvbi96dWktZHVvLW5lbmctd2FuLWNoZW5nLXBhaS14dS1kZS1rdWFpLWlpLWRlbmctamllLS8=">Krahets 题解<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxChunksToSorted</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="comment"># 栈递增，找到右侧小值时，小值向前推到小于等于它为止(此块最小值&gt;前一个块最大值)</span></span><br><span class="line">            <span class="comment"># stack[-1]为当前块最大值(最后保存此值代表当前块)</span></span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> num &lt; stack[<span class="number">-1</span>]: </span><br><span class="line">                head = stack.pop()</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> num &lt; stack[<span class="number">-1</span>]: stack.pop()</span><br><span class="line">                stack.append(head)</span><br><span class="line">            <span class="keyword">else</span>: stack.append(num)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stack)</span><br></pre></td></tr></table></figure></p>
<h2 id="011-盛最多水的容器-双指针"><a href="#011-盛最多水的容器-双指针" class="headerlink" title="011. 盛最多水的容器(双指针)"></a>011. 盛最多水的容器(双指针)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWluZXItd2l0aC1tb3N0LXdhdGVyLw==">https://leetcode.cn/problems/container-with-most-water/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个数组 <code>height</code>，长度为 <code>n</code>，每个数代表坐标轴中的一个点的高度，<code>height[i]</code> 是在第 <code>i</code> 点的高度，请问，从中选 2 个高度与 x 轴组成的容器最多能容纳多少水。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用双指针，比接雨水简单些。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            area = <span class="built_in">min</span>(height[left], height[right])*(right-left)</span><br><span class="line">            res = <span class="built_in">max</span>(res, area)</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt;= height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="042-接雨水"><a href="#042-接雨水" class="headerlink" title="042. 接雨水"></a>042. 接雨水</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHJhcHBpbmctcmFpbi13YXRlci8=">https://leetcode-cn.com/problems/trapping-rain-water/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>示例 1：<br>输入：<code>height = [0,1,0,2,1,0,1,3,2,1,2,1]</code><br>输出：<code>6</code><br>解释：上面是由数组 <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code> 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 </p>
<p><strong>题目解析</strong>：</p>
<ul>
<li>雨水量等于 <strong>两边柱子最高高度的最小值-当前柱子高度</strong>，即<code>min(max(left),max(right))-height[i]</code>。</li>
<li>积水只能在低处形成，当后面柱子高度比前面柱子低时，无法接雨水，所以使用<strong>单调递减栈</strong>存储可能储水的柱子，当找到一根比前面高的柱子，就可以计算接到的雨水。</li>
</ul>
<div class="tabs" id="42"><ul class="nav-tabs"><li class="tab active"><a href="#42-1">单调栈</a></li><li class="tab"><a href="#42-2">双指针</a></li></ul><div class="tab-content"><div class="tab-pane active" id="42-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height)):</span><br><span class="line">            <span class="comment"># 栈不为空 + (当前高度&gt;前一个高度)</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[i]&gt;height[stack[<span class="number">-1</span>]]:</span><br><span class="line">                <span class="comment"># 3个值计算一次：</span></span><br><span class="line">                <span class="comment"># 当前值(右侧最高处)+栈倒数第一个(最矮的地方)+栈倒数第二个(左侧最高处)</span></span><br><span class="line">                top = stack.pop()  <span class="comment"># 最矮的地方</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:<span class="keyword">break</span>  <span class="comment"># 栈可能只有一个值，此时不用计算</span></span><br><span class="line">                left = stack[<span class="number">-1</span>]  <span class="comment"># 左侧最高处</span></span><br><span class="line">                <span class="comment"># 宽度 = 高索引-低索引-1</span></span><br><span class="line">                currWidth = i - left - <span class="number">1</span>  </span><br><span class="line">                <span class="comment"># 高度 = min(左侧最高处,右侧最高处)-最矮的地方</span></span><br><span class="line">                currHeight = <span class="built_in">min</span>(height[left], height[i]) - height[top] </span><br><span class="line">                ans += currWidth * currHeight  <span class="comment"># 累加雨水</span></span><br><span class="line">            stack.append(i)  <span class="comment"># 添加当前值索引</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="42-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        left, right：左右索引。</span></span><br><span class="line"><span class="string">        leftMax, rightMax：height[0~left]最高值，height[right~n-1]最高值。</span></span><br><span class="line"><span class="string">        ans：接雨水总量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">        leftMax = rightMax = <span class="number">0</span>  <span class="comment"># 存储左、右两侧最高值，当成左边界和右边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># 更新左右两侧最高值</span></span><br><span class="line">            leftMax = <span class="built_in">max</span>(leftMax, height[left])</span><br><span class="line">            rightMax = <span class="built_in">max</span>(rightMax, height[right])</span><br><span class="line">            <span class="comment"># 当前左高度&lt;右高度，从左-&gt;右累加(按左柱子高度接雨水)</span></span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                ans += leftMax - height[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 否则，从右-&gt;左累加(按右柱子高度接雨水)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += rightMax - height[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="084-柱状图中最大的矩阵"><a href="#084-柱状图中最大的矩阵" class="headerlink" title="084. 柱状图中最大的矩阵"></a>084. 柱状图中最大的矩阵</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtLw==">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定 <code>n</code> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。求在该柱状图中，能够勾勒出来的矩形的最大面积。<br>示例 1:<br>输入：<code>heights = [2,1,5,6,2,3]</code><br>输出：<code>10</code><br>解释：最大的矩形为图中红色区域，面积为 10</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtL3NvbHV0aW9uLzg0LXpodS16aHVhbmctdHUtemhvbmctenVpLWRhLWRlLWp1LXhpbmctZHVvLWNob25nLw==">力扣加加题解<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtL3NvbHV0aW9uL2RvbmctaHVhLXlhbi1zaGktZGFuLWRpYW8temhhbi04NHpodS16aHUtMDN3My8=">编程狂想曲 动画演示<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目解析</strong>：我们需要找到<strong>左右两侧最近的高度小于 当前柱子高度 的柱子</strong>，这是当前柱子能向左右扩张的边界(能计算宽度)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span>(<span class="params">self, heights: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]  <span class="comment"># 加2个哨兵，防止stack[-1]越界、栈不为空结束</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(heights)):</span><br><span class="line">            <span class="comment"># 找到栈顶柱子为高的右边界(比栈顶矮的为边界)      </span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]]&gt;heights[i]:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                <span class="comment"># 此时，stack[-1]为栈顶柱子tmp左边界</span></span><br><span class="line">                <span class="comment"># 面积 = max(上次最大面积, 当前柱子为高的面积: (右边界-左边界-1) * (当前柱子高))</span></span><br><span class="line">                res = <span class="built_in">max</span>(res, (i-stack[<span class="number">-1</span>]<span class="number">-1</span>) * heights[tmp])</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p><strong>双指针</strong>指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（特殊情况甚至可以多个），两个指针或是同方向访问两个链表(普通)、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞/左右指针），从而达到我们需要的目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">链表有4种类型：</span><br><span class="line">- 判断链表中是否含有环？</span><br><span class="line">    - 141. 环形链表</span><br><span class="line">- 已知链表中有环，返回这个环的起始位置。</span><br><span class="line">    - 142. 环形链表 II</span><br><span class="line">- 寻找无环单链表中点。</span><br><span class="line">    - 234. 回文链表</span><br><span class="line">    - 143. 重排链表</span><br><span class="line">- 寻找单链表的倒数第k个元素。</span><br><span class="line">    - 19. 删除链表的倒数第N个节点</span><br><span class="line"></span><br><span class="line">字符串有4种类型：</span><br><span class="line">- 二分搜索(可算成一大类，单独列出)</span><br><span class="line">- n数之和</span><br><span class="line">- 反转数组</span><br><span class="line">- 滑动窗口(可算成一大类，单独列出)</span><br></pre></td></tr></table></figure></p>
<h2 id="160-相交链表-普通"><a href="#160-相交链表-普通" class="headerlink" title="160. 相交链表(普通)"></a>160. 相交链表(普通)</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZXJzZWN0aW9uLW9mLXR3by1saW5rZWQtbGlzdHMv">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。两个链表在节点 <code>c1</code> 开始相交：<code>A=[a1,a2,c1,c2,c3]，B=[b1,b2,b3,c1,c2,c3]</code>，题目数据 <strong>保证</strong> 整个链式结构中<strong>不存在环</strong>。注意，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p>示例 1：<br>输入：<code>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</code><br>输出：<code>Intersected at &#39;8&#39;</code><br>解释：相交节点的值为 <code>8</code> （注意，如果两个链表相交则不能为 <code>0</code>）。<br>从各自的表头开始算起，链表 <code>A</code> 为 <code>[4,1,8,4,5]</code>，链表 <code>B</code> 为 <code>[5,6,1,8,4,5]</code>。<br>在 <code>A</code> 中，相交节点前有 <code>2</code> 个节点；在 <code>B</code> 中，相交节点前有 <code>3</code> 个节点。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZXJzZWN0aW9uLW9mLXR3by1saW5rZWQtbGlzdHMvc29sdXRpb24veGlhbmctamlhby1saWFuLWJpYW8tYnktbGVldGNvZGUtc29sdXRpby1hOGpuLw==">官方题解<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZXJzZWN0aW9uLW9mLXR3by1saW5rZWQtbGlzdHMvc29sdXRpb24vaW50ZXJzZWN0aW9uLW9mLXR3by1saW5rZWQtbGlzdHMtc2h1YW5nLXpoaS16aGVuLWwv">jyd题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        ha, hb = headA, headB</span><br><span class="line">        <span class="comment"># 假设ha长m(不相交部分长a)，hb长n(不相交部分长b)，相交部分长度c。</span></span><br><span class="line">        <span class="comment"># 当两指针相遇时停止：此时ha走了a+c+b，hb走了b+c+a。</span></span><br><span class="line">        <span class="keyword">while</span> ha != hb:</span><br><span class="line">            <span class="comment"># a走到尾部，从b头部开始</span></span><br><span class="line">            ha = ha.<span class="built_in">next</span> <span class="keyword">if</span> ha <span class="keyword">else</span> headB</span><br><span class="line">            <span class="comment"># b走到尾部，从a头部开始</span></span><br><span class="line">            hb = hb.<span class="built_in">next</span> <span class="keyword">if</span> hb <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> ha</span><br></pre></td></tr></table></figure></p>
<h2 id="165-比较版本号-普通"><a href="#165-比较版本号-普通" class="headerlink" title="165. 比较版本号(普通)"></a>165. 比较版本号(普通)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21wYXJlLXZlcnNpb24tbnVtYmVycy8=">https://leetcode.cn/problems/compare-version-numbers/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个版本号 version1 和 version2 ，请你比较它们。版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。<br>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。<br>返回规则：如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1，除此之外返回 0。<br>示例 1：<br>输入：<code>version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;</code><br>输出：<code>0</code><br>解释：忽略前导零，”01” 和 “001” 都表示相同的整数 “1”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareVersion</span>(<span class="params">self, version1: <span class="built_in">str</span>, version2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        n, m = <span class="built_in">len</span>(version1), <span class="built_in">len</span>(version2)</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;n <span class="keyword">or</span> j&lt;m:  <span class="comment"># 直到某个字符串结束</span></span><br><span class="line">            num1 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;n <span class="keyword">and</span> version1[i]!=<span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                num1 = num1 * <span class="number">10</span> + <span class="built_in">int</span>(version1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span>  <span class="comment"># 跳过点号</span></span><br><span class="line"></span><br><span class="line">            num2 = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j&lt;m <span class="keyword">and</span> version2[j]!=<span class="string">&#x27;.&#x27;</span>:  <span class="comment"># 从下一个点前截取数字</span></span><br><span class="line">                num2 = num2 * <span class="number">10</span> + <span class="built_in">int</span>(version2[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span>  <span class="comment"># 跳过点号</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> num1 != num2: <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> num1&gt;num2 <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 版本号相同</span></span><br></pre></td></tr></table></figure></p>
<h2 id="026-删除有序数组中的重复项-快慢"><a href="#026-删除有序数组中的重复项-快慢" class="headerlink" title="026. 删除有序数组中的重复项(快慢)"></a>026. 删除有序数组中的重复项(快慢)</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtYXJyYXkv">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。将最终结果插入 nums 的前 k 个位置后返回 k 。<strong>不要使用额外的空间</strong>，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br>示例 1：<br>输入：<code>nums = [1,1,2]</code><br>输出：<code>2, nums = [1,2,_]</code><br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        删除数组重复元素，且要O(1)空间复杂度，那么可考虑把要删除的元素移动到尾部，然后pop。</span></span><br><span class="line"><span class="string">        快慢指针：slow位置为存储下一个不重复元素，fast找到一个不重复元素就填到slow位置，并让slow前进一步，</span></span><br><span class="line"><span class="string">                  这样fast走完，nums[0~slow-1]就是不重复元素。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        slow = fast = <span class="number">1</span>  <span class="comment"># 保持 相对顺序，从1开始</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[fast<span class="number">-1</span>]:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow  <span class="comment"># 长度为slow</span></span><br></pre></td></tr></table></figure></p>
<h2 id="141-环形链表-快慢"><a href="#141-环形链表-快慢" class="headerlink" title="141. 环形链表(快慢)"></a>141. 环形链表(快慢)</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv">https://leetcode-cn.com/problems/linked-list-cycle/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。<br>如果链表中存在环 ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p>示例 1：<br>输入：<code>head = [3,2,0,-4], pos = 1</code><br>输出：<code>true</code><br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUvc29sdXRpb24vaHVhbi14aW5nLWxpYW4tYmlhby1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">官方题解<i class="fa fa-external-link-alt"></i></span>。</p>
<p><strong>方法一：哈希表法</strong></p>
<ul>
<li>时间复杂度：$O(n)$，对于含有 <code>n</code> 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 $O(1)$ 的时间。</li>
<li>空间复杂度：$O(n)$，空间取决于添加到哈希表中的元素数目，最多可以添加 <code>n</code> 个元素。</li>
</ul>
<p><strong>方法二：快慢双指针法</strong></p>
<ul>
<li>时间复杂度：$O(n)$，让我们将 <code>n</code> 设为链表中结点的总数。为了分析时间复杂度，我们分别考虑下面两种情况：<ul>
<li>链表中不存在环：快指针将会首先到达尾部，其时间取决于列表的长度，也就是 $O(n)$ 。</li>
<li>链表中存在环：我们将慢指针的移动过程划分为 <code>非环部分</code> 与 <code>环形部分</code> 两个阶段：<ol>
<li>慢指针在走完<code>非环部分</code>阶段后将进入<code>环形部分</code>：此时，快指针已经进入环中 $\text{迭代次数} = \text{非环部分长度} = n$。</li>
<li>两个指针都在环形区域中：考虑两个在环形赛道上的运动员，快跑者每次移动两步而慢跑者每次只移动一步，其速度的差值为 1，因此需要经过 $\dfrac{\text{二者之间距离}}{\text{速度差值}}$ 次循环后，快跑者可以追上慢跑者。这个距离几乎就是 $\text{环形部分长度 k}$ ，且速度差值为 $1$ ，我们得出这样的结论 $\text{迭代次数} \approx \text{环形部分长度 k}$。因此，在最糟糕的情形下，时间复杂度为 $O(n+k)$，即 $O(n)$ 。</li>
</ol>
</li>
</ul>
</li>
<li>空间复杂度：只使用了慢指针和快指针两个结点，所以空间复杂度为 $O(1)$。</li>
</ul>
<div class="tabs" id="141"><ul class="nav-tabs"><li class="tab active"><a href="#141-1">快慢双指针</a></li><li class="tab"><a href="#141-2">哈希表</a></li></ul><div class="tab-content"><div class="tab-pane active" id="141-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这里while循环：</span></span><br><span class="line"><span class="string">        1. fast and fast.next：</span></span><br><span class="line"><span class="string">            - 长度为奇数：slow停在中间位置</span></span><br><span class="line"><span class="string">            - 长度为偶数：slow停在中间偏右位置</span></span><br><span class="line"><span class="string">        1. fast.next and fast.next.next：</span></span><br><span class="line"><span class="string">            - 长度为奇数：slow停在中间位置</span></span><br><span class="line"><span class="string">            - 长度为偶数：slow停在中间偏左位置</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 空链表非环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="comment"># 快指针结束在None点，此时不是环</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:  <span class="comment"># 也可以while fast.next and fast.next.next:</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="141-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        dictx = &#123;&#125;</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> dictx:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            dictx[cur] = <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="142-环形链表-II-快慢"><a href="#142-环形链表-II-快慢" class="headerlink" title="142. 环形链表 II(快慢)"></a>142. 环形链表 II(快慢)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkv">https://leetcode-cn.com/problems/linked-list-cycle-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<br>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 -1，则在该链表中没有环。注意：<code>pos</code> 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p>示例 1：<br>输入：<code>head = [3,2,0,-4], pos = 1</code><br>输出：返回索引为 <code>1</code> 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkvc29sdXRpb24vaHVhbi14aW5nLWxpYW4tYmlhby1paS1ieS1sZWV0Y29kZS8=">官方题解<i class="fa fa-external-link-alt"></i></span><br><strong>方法一：哈希表法</strong></p>
<ul>
<li>时间复杂度：$O(n)$<blockquote>
<p>不管是成环还是不成环的输入，算法肯定都只会访问每个节点一次。对于非成环列表这是显而易见的，因为第 <code>n</code> 个节点指向 <code>null</code> ，这会让循环退出。对于循环列表， <code>if</code> 条件满足时会导致函数的退出，因为它指向了某个已经访问过的节点。两种情况下，访问的节点数最多都是 <code>n</code> 个，所以运行时间跟节点数目成线性关系。</p>
</blockquote>
</li>
<li>空间复杂度：$O(n)$<blockquote>
<p>不管成环或者不成环的输入，我们都需要将每个节点插入 <code>Set</code> 中一次。两者唯一的区别是最后访问的节点后是 <code>null</code> 还是一个已经访问过的节点。因此，由于 <code>Set</code> 包含 <code>n</code> 个不同的节点，所需空间与节点数目也是线性关系的。</p>
</blockquote>
</li>
</ul>
<p><strong>方法二：Floyd 算法（快慢指针法）</strong><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkvZGlzY3Vzcy80NDgzMw==">LostSummer233 题解<i class="fa fa-external-link-alt"></i></span> </p>
<div class="tabs" id="142"><ul class="nav-tabs"><li class="tab active"><a href="#142-1">快慢指针</a></li><li class="tab"><a href="#142-2">哈希表</a></li></ul><div class="tab-content"><div class="tab-pane active" id="142-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="comment"># while-else语法：while条件不满足执行else，while里面遇到break，跳出while-else语句。</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 此时slow走了k步(head-&gt;slow)，fast走了2k步(那么slow-&gt;fast(相遇点)也为k步，即环为k步)</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast: <span class="keyword">break</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> <span class="comment"># 不是环，结束</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 假设入口chead-&gt;slow为m步，那么head-&gt;chead为k-m步，因为环为k步，所以相遇点fast-&gt;chead也为k-m步</span></span><br><span class="line">        <span class="comment"># 即，head和相遇点fast同速走到相遇，此时就是入口chead了！</span></span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="142-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                visited.add(node)</span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="234-回文链表-快慢"><a href="#234-回文链表-快慢" class="headerlink" title="234. 回文链表(快慢)"></a>234. 回文链表(快慢)</h2><p><strong>难度</strong>：简单<br><strong>题⽬链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1saW5rZWQtbGlzdC8=">https://leetcode-cn.com/problems/palindrome-linked-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<p>示例1:<br>1-&gt;2-&gt;2-&gt;1<br>输入：head = [1,2,2,1]<br>输出：true</p>
<p>示例2:<br>1-&gt;2<br>输入：head = [1,2]<br>输出：false</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1saW5rZWQtbGlzdC8=">面试题 02.06<i class="fa fa-external-link-alt"></i></span>相同。<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1saW5rZWQtbGlzdC9zb2x1dGlvbi9odWktd2VuLWxpYW4tYmlhby1ieS1sZWV0Y29kZS8=">官方题解<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1saW5rZWQtbGlzdC9zb2x1dGlvbi9kb25nLWh1YS15YW4tc2hpLTIzNC1odWktd2VuLWxpYW4tYmlhby1ieS11c2VyNzQzOS8=">wangnima题解<i class="fa fa-external-link-alt"></i></span>，官方题解代码更工程漂亮，wangnima的讲解更细。</p>
<p>时间复杂度$O(n)$。<br>空间复杂度$O(1)$。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        链表分left和right两部分(快慢找中点)，翻转right后(翻转链表)，对比left和right是否相同。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        left_end = self.find_mid(head)</span><br><span class="line">        <span class="comment"># 判断是否回文</span></span><br><span class="line">        right = self.reverse_list(left_end.<span class="built_in">next</span>)</span><br><span class="line">        left = head</span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right: </span><br><span class="line">            <span class="keyword">if</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span>  </span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 还原链表并返回结果(r在前面记录了初始right)</span></span><br><span class="line">        <span class="comment"># left_end.next = self.reverse_list(r) </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse_list</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        cur = head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_mid</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        # 奇数：slow停在中间(slow需要再向前走一步，才为right头节点)</span></span><br><span class="line"><span class="string">        # 偶数：slow停在中间偏右(slow为right头节点)</span></span><br><span class="line"><span class="string">        while fast and fast.next:</span></span><br><span class="line"><span class="string">            ...</span></span><br><span class="line"><span class="string">        # 偶数时，fast停在None</span></span><br><span class="line"><span class="string">        # 奇数时，fast停在非None，slow需要走一步</span></span><br><span class="line"><span class="string">        if fast: slow = slow.next</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="comment"># 奇数：slow停在中间</span></span><br><span class="line">        <span class="comment"># 偶数：slow停在中间偏左</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></p>
<h2 id="143-重排链表-快慢"><a href="#143-重排链表-快慢" class="headerlink" title="143. 重排链表(快慢)"></a>143. 重排链表(快慢)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVvcmRlci1saXN0Lw==">https://leetcode-cn.com/problems/reorder-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 下标表示为：<code>0,1...n-1,n</code>，请将其重新排列后变为：<code>0,n,1,n-1...</code>，不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1：<br>输入：<code>head = [1,2,3,4]</code><br>输出：<code>[1,4,2,3]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVvcmRlci1saXN0L3NvbHV0aW9uL3hpYW5nLXhpLXRvbmctc3UtZGUtc2ktbHUtZmVuLXhpLWR1by1qaWUtZmEtYnktMzQv">windiang题解<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目解析</strong>：<strong>寻找链表中点 + 链表逆序 + 合并链表</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        mid = self.middleNode(head)</span><br><span class="line">        l1 = head</span><br><span class="line">        l2 = self.reverseList(mid.<span class="built_in">next</span>)</span><br><span class="line">        mid.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># l1结尾置None</span></span><br><span class="line">        <span class="comment"># l1从head开始，l2从后半反转后pre开始</span></span><br><span class="line">        self.mergeList(l1, l2)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="comment"># 偶数：slow停在中间节点偏左</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeList</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>):</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            l1_tmp = l1.<span class="built_in">next</span></span><br><span class="line">            l2_tmp = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            l1.<span class="built_in">next</span> = l2</span><br><span class="line">            l1 = l1_tmp</span><br><span class="line"></span><br><span class="line">            l2.<span class="built_in">next</span> = l1</span><br><span class="line">            l2 = l2_tmp</span><br></pre></td></tr></table></figure></p>
<h2 id="328-奇偶链表-快慢"><a href="#328-奇偶链表-快慢" class="headerlink" title="328. 奇偶链表(快慢)"></a>328. 奇偶链表(快慢)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vZGQtZXZlbi1saW5rZWQtbGlzdC8=">https://leetcode.cn/problems/odd-even-linked-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 <strong>奇数</strong> ， 第二个节点的索引为 <strong>偶数</strong> ，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题。<br>示例 1:<br>输入: <code>head = [1,2,3,4,5]</code><br>输出: <code>[1,3,5,2,4]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这里定义slow为奇数，fast为偶数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> head</span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line">        fasthead = fast <span class="comment"># 保存偶数链头节点用于合并</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow.<span class="built_in">next</span> = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast.<span class="built_in">next</span> = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = fasthead</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p>
<h2 id="019-删除链表的倒数第N个节点-快慢"><a href="#019-删除链表的倒数第N个节点-快慢" class="headerlink" title="019. 删除链表的倒数第N个节点(快慢)"></a>019. 删除链表的倒数第N个节点(快慢)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLW50aC1ub2RlLWZyb20tZW5kLW9mLWxpc3Qv">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。<br>示例 1：<br>输入：<code>head = [1,2,3,4,5], n = 2</code><br>输出：<code>[1,2,3,5]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLW50aC1ub2RlLWZyb20tZW5kLW9mLWxpc3Qvc29sdXRpb24vc2hhbi1jaHUtbGlhbi1iaWFvLWRlLWRhby1zaHUtZGktbmdlLWppZS1kaWFuLWJ5LWwv">官方题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        slow 和 fast 之间有 n+1 跳(用哑节点)，这样fast为None时，slow停在删除节点的前一个节点。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow = dhead = ListNode(<span class="number">-1</span>, head) </span><br><span class="line">        fast = head</span><br><span class="line">        <span class="comment"># fast先走n步，注意fast可能走不到n</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> fast: fast = fast.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 同步走到fast为None结束，此时slow下一个节点为要删除节点</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 删除slow下一个节点</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dhead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p>
<h2 id="344-反转字符串-左右"><a href="#344-反转字符串-左右" class="headerlink" title="344. 反转字符串(左右)"></a>344. 反转字符串(左右)</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1zdHJpbmcv">https://leetcode-cn.com/problems/reverse-string/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 <code>O(1)</code> 的额外空间解决这一问题。<br>示例 1：<br>输入：<code>s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</code><br>输出：<code>[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: List[<span class="built_in">str</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="125-验证回文串-左右"><a href="#125-验证回文串-左右" class="headerlink" title="125. 验证回文串(左右)"></a>125. 验证回文串(左右)</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFsaW5kcm9tZS8=">https://leetcode-cn.com/problems/valid-palindrome/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述：</strong>给定一个字符串，验证它是否是回文串，只考虑<strong>字母</strong>和<strong>数字</strong>字符，可以<strong>忽略</strong>字母的<strong>大小写</strong>。说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例 1:<br>输入: <code>&quot;A man, a plan, a canal: Panama&quot;</code><br>输出: <code>true</code><br>解释：<code>&quot;amanaplanacanalpanama&quot;</code> 是回文串</p>
<p><strong>题目解析</strong>：核心是比较reversed string 和 原本的 string 是否相等。<br><div class="tabs" id="125"><ul class="nav-tabs"><li class="tab active"><a href="#125-1">双指针</a></li><li class="tab"><a href="#125-2">字符串处理</a></li><li class="tab"><a href="#125-3">正则</a></li></ul><div class="tab-content"><div class="tab-pane active" id="125-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># left,right跳过非字母数字</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="keyword">not</span> s[left].isalnum():left += <span class="number">1</span>     </span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> <span class="keyword">not</span> s[right].isalnum():right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> s[left].lower() != s[right].lower(): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                left, right = left+<span class="number">1</span>, right<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="125-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self,s</span>):</span></span><br><span class="line">        sgood = <span class="string">&quot;&quot;</span>.join(ch.lower() <span class="keyword">for</span> ch <span class="keyword">in</span> s <span class="keyword">if</span> ch.isalnum())</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="125-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re.sub()用法：https://www.jianshu.com/p/8c1d1a38f9b9</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        newString = re.sub(<span class="string">&quot;[^0-9a-zA-Z]+&quot;</span>, <span class="string">&quot;&quot;</span>, s)</span><br><span class="line">        <span class="keyword">return</span> newString.lower() == newString.lower()[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="015-三数之和-左右"><a href="#015-三数之和-左右" class="headerlink" title="015. 三数之和(左右)"></a>015. 三数之和(左右)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvM3N1bS8=">https://leetcode-cn.com/problems/3sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题⽬描述</strong>：给你一个包含<code>n</code>个整数的数组<code>nums</code>，判断<code>nums</code>中是否存在三个元素<code>a，b，c</code> ，使得<code>a + b + c = 0</code>？请你找出所有和为0且不重复的三元组。注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：<br>输入：<code>nums = [-1,0,1,2,-1,-4]</code><br>输出：<code>[[-1,-1,2],[-1,0,1]]</code></p>
<p><strong>复杂度分析</strong>：<br>（1）时间复杂度：排序$O(nlogn)$，遍历数组$O(n)$，双指针遍历$O(n)$，总体：$O(nlogn)+O(n)*O(n) \to O(n^2)$。<br>（2）空间复杂度：$O(1)$。</p>
<div class="tabs" id="015"><ul class="nav-tabs"><li class="tab active"><a href="#015-1">模板</a></li><li class="tab"><a href="#015-2">题解</a></li></ul><div class="tab-content"><div class="tab-pane active" id="015-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以把0换成target，当成模板用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums)&lt;<span class="number">3</span>): <span class="keyword">return</span> []</span><br><span class="line">        res, n = [], <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">return</span> res  <span class="comment"># 最小值都大于0，不可能出现三数之和为0</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:<span class="keyword">continue</span>  <span class="comment"># 跳过相同值(需要和上⼀次枚举的数不相同)</span></span><br><span class="line">            l, r = i+<span class="number">1</span>, n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;r:  <span class="comment"># 左右循环计算</span></span><br><span class="line">                sums = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> sums &gt; <span class="number">0</span>: r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sums &lt; <span class="number">0</span>: l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i],nums[l],nums[r]])  <span class="comment"># 3个数和为0，加入res</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> nums[l]==nums[l<span class="number">-1</span>]:l += <span class="number">1</span> <span class="comment"># nums[l]跳过相同值</span></span><br><span class="line">                    <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> nums[r]==nums[r+<span class="number">1</span>]:r -= <span class="number">1</span> <span class="comment"># nums[r]跳过相同值</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="015-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三个循环，其中第二和第三是并列的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举 first</span></span><br><span class="line">        <span class="keyword">for</span> first <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> first&gt;<span class="number">0</span> <span class="keyword">and</span> nums[first] == nums[first<span class="number">-1</span>]:<span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 枚举 third 对应的指针初始指向数组的最右端</span></span><br><span class="line">            third = n - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 枚举 second</span></span><br><span class="line">            <span class="keyword">for</span> second <span class="keyword">in</span> <span class="built_in">range</span>(first+<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># b的值需要和上一次的数不相同</span></span><br><span class="line">                <span class="keyword">if</span> second&gt;first+<span class="number">1</span> <span class="keyword">and</span> nums[second] == nums[second<span class="number">-1</span>]:<span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 需要保证 second 的指针在 third 的指针的左侧</span></span><br><span class="line">                <span class="keyword">while</span> second&lt;third <span class="keyword">and</span> nums[second]+nums[third]+nums[first] &gt; <span class="number">0</span>:third -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果指针重合，随着 second 后续的增加</span></span><br><span class="line">                <span class="comment"># 就不会有满足 first+second+third=0 并且 second&lt;third 的 third 了，可以退出循环</span></span><br><span class="line">                <span class="keyword">if</span> second == third:<span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[second]+nums[third]+nums[first] == <span class="number">0</span>:</span><br><span class="line">                    ans.append([nums[first], nums[second], nums[third]])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div></div></div>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模板：s中找包含t</span></span><br><span class="line">need, window = &#123;&#125;, &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">    s[c] = s.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="comment"># valid:每满足need的一项的频数，就+1。</span></span><br><span class="line"><span class="comment"># valid==len(need)时表明window完全覆盖了子串t</span></span><br><span class="line">valid = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">    ch = s[right]</span><br><span class="line">    right += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ch <span class="keyword">in</span> need:</span><br><span class="line">        window[ch] = window.get(ch, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> need[ch] == window[ch]:</span><br><span class="line">            valid += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> 收缩结束条件:</span><br><span class="line">        <span class="comment"># 判断符合条件/更新结果变量</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment"># 不符合条件/更新完变量，缩小窗口</span></span><br><span class="line">        d = s[left]</span><br><span class="line">        left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> d <span class="keyword">in</span> need:     </span><br><span class="line">            <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                valid -= <span class="number">1</span></span><br><span class="line">            window[d] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> 结果</span><br></pre></td></tr></table></figure>
<h2 id="003-无重复字符的最长子串"><a href="#003-无重复字符的最长子串" class="headerlink" title="003. 无重复字符的最长子串"></a>003. 无重复字符的最长子串</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p>示例 1:<br>输入: <code>s = &quot;pwwkew&quot;</code><br>输出: <code>3</code><br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 <strong>子串</strong> 的长度，”pwke” 是一个<strong>子序列</strong>，不是子串。<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy9zb2x1dGlvbi9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzLWItMi8=">Ikaruga 图画<i class="fa fa-external-link-alt"></i></span>。</p>
<div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><a href="#3-1">模板</a></li><li class="tab"><a href="#3-2">for循环</a></li></ul><div class="tab-content"><div class="tab-pane active" id="3-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        hmap：&#123;字符:出现次数&#125;，判断是否出现重复字符。</span></span><br><span class="line"><span class="string">        窗口大小[left, right)，right右移扩大窗口(直到超出字符串)，当出现重复字符缩小窗口(left右移)，</span></span><br><span class="line"><span class="string">        每次移动后计算窗口大小。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        mlen, left, right, maps = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s): </span><br><span class="line">            <span class="comment"># right右移扩大窗口</span></span><br><span class="line">            ch = s[right]</span><br><span class="line">            maps[ch] = maps.get(ch,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 出现重复字符缩小窗口(left右移)</span></span><br><span class="line">            <span class="keyword">while</span> maps[ch] &gt; <span class="number">1</span>: </span><br><span class="line">                d = s[left]</span><br><span class="line">                maps[d] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 计算窗口大小</span></span><br><span class="line">            mlen = <span class="built_in">max</span>(mlen, right-left)</span><br><span class="line">        <span class="keyword">return</span> mlen</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="3-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 最大长度，左边界</span></span><br><span class="line">        mlen, left = <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">        maps = &#123;&#125; <span class="comment"># 存储无重复字符</span></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)): <span class="comment"># right为右边界</span></span><br><span class="line">            <span class="comment"># right字符在窗口中出现过，left右移一位。始终保证窗口为无重复字串</span></span><br><span class="line">            left = <span class="built_in">max</span>(left, maps.get(s[right],<span class="number">-1</span>)+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 无重复长度=right-left+1，即窗口[left, right]</span></span><br><span class="line">            mlen = <span class="built_in">max</span>(mlen, right-left+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 更新maps</span></span><br><span class="line">            maps[s[right]] = right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mlen</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a>239. 滑动窗口最大值</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zbGlkaW5nLXdpbmRvdy1tYXhpbXVtLw==">https://leetcode.cn/problems/sliding-window-maximum/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = collections.deque()  <span class="comment"># 队列(左-&gt;右递减)</span></span><br><span class="line">        res, i = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="comment"># 窗口加入nums[i]，确保q[0]为窗口最大值</span></span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[<span class="number">-1</span>]]: q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">while</span> i-q[<span class="number">0</span>]+<span class="number">1</span> &gt; k: q.popleft()  <span class="comment"># 超出窗口范围的去掉</span></span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span> &gt;= k: res.append(nums[q[<span class="number">0</span>]])  <span class="comment"># 窗口建成，计算窗口最大值</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb24taW4tc3RyaW5nLw==">https://leetcode-cn.com/problems/permutation-in-string/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code>；否则，返回 <code>false</code>。换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p>
<p>示例 1：<br>输入：<code>s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</code><br>输出：<code>true</code><br>解释：s2 包含 s1 的排列之一 (“ba”).<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># need: 需要凑齐的字符</span></span><br><span class="line">        <span class="comment"># window: 记录窗口中的字符</span></span><br><span class="line">        need, window = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s1:</span><br><span class="line">            need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 区间[left, right)</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># valid:每满足need的一项的频数，就+1。</span></span><br><span class="line">        <span class="comment"># valid==len(need)时表明window完全覆盖了子串s1</span></span><br><span class="line">        valid = <span class="number">0</span>     </span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s2):</span><br><span class="line">            ch = s2[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 需要当前字符，更新窗口字符、数量</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> need:         </span><br><span class="line">                window[ch] = window.get(ch, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[ch] == need[ch]:</span><br><span class="line">                    valid += <span class="number">1</span></span><br><span class="line">            <span class="comment"># window长度和s1相等时，判断符合条件、优化left</span></span><br><span class="line">            <span class="keyword">while</span> right-left &gt;= <span class="built_in">len</span>(s1):</span><br><span class="line">                <span class="comment"># 判断符合条件</span></span><br><span class="line">                <span class="keyword">if</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="comment"># 不符合条件，缩小窗口</span></span><br><span class="line">                d = s2[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:     </span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                        valid -= <span class="number">1</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1hbGwtYW5hZ3JhbXMtaW4tYS1zdHJpbmcv">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>示例 1:<br>输入: <code>s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;</code><br>输出: <code>[0,6]</code><br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; List[int]:</span></span><br><span class="line">        need, window = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> p:</span><br><span class="line">            need[c] = need.get(c,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        valid = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            ch = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> need:</span><br><span class="line">                window[ch] = window.get(ch,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[ch] == need[ch]:valid += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right-left &gt;= <span class="built_in">len</span>(p):</span><br><span class="line">                <span class="keyword">if</span> valid == <span class="built_in">len</span>(need):res.append(left)</span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:</span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:valid -= <span class="number">1</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res     </span><br></pre></td></tr></table></figure></p>
<h2 id="076-最小覆盖子串"><a href="#076-最小覆盖子串" class="headerlink" title="076. 最小覆盖子串"></a>076. 最小覆盖子串</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS13aW5kb3ctc3Vic3RyaW5nLw==">https://leetcode-cn.com/problems/minimum-window-substring/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。<br>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：<br>输入：<code>s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</code><br>输出：<code>&quot;BANC&quot;</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="comment"># need: 需要凑齐的字符</span></span><br><span class="line">        <span class="comment"># window: 记录窗口中的字符</span></span><br><span class="line">        need, window = &#123;&#125;, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            need[c] = need.get(c, <span class="number">0</span>) + <span class="number">1</span>    <span class="comment"># need = &#123;字符:出现次数&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 区间[left, right)</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="comment"># valid: window满足need字符数量，valid==len(need)时表明window完全覆盖了子串t</span></span><br><span class="line">        valid = <span class="number">0</span>     </span><br><span class="line">        <span class="comment"># 最小覆盖子串起始位置、长度(初始大于len(s)都行)</span></span><br><span class="line">        start, min_len = <span class="number">0</span>, <span class="built_in">len</span>(s)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; <span class="built_in">len</span>(s):</span><br><span class="line">            c = s[right]</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 需要当前字符，更新窗口字符、数量</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> need:         </span><br><span class="line">                window[c] = window.get(c, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> window[c] == need[c]:</span><br><span class="line">                    valid += <span class="number">1</span></span><br><span class="line">            <span class="comment"># window必须完全覆盖子串t时，优化left</span></span><br><span class="line">            <span class="keyword">while</span> valid == <span class="built_in">len</span>(need):</span><br><span class="line">                <span class="comment"># 更新字串起始位置、长度</span></span><br><span class="line">                <span class="keyword">if</span> right-left &lt; min_len:   </span><br><span class="line">                    start = left</span><br><span class="line">                    min_len = right-left</span><br><span class="line">                <span class="comment"># 将要移除的字符</span></span><br><span class="line">                d = s[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="comment"># d在need中出现，更新窗口window，更新该字符满足条件-&gt;不满足</span></span><br><span class="line">                <span class="keyword">if</span> d <span class="keyword">in</span> need:     </span><br><span class="line">                    <span class="keyword">if</span> window[d] == need[d]:</span><br><span class="line">                        valid -= <span class="number">1</span></span><br><span class="line">                    window[d] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start+min_len] <span class="keyword">if</span> min_len != <span class="built_in">len</span>(s)+<span class="number">1</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>动态规划</strong>：基本思想是将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于<strong>重复出现的子问题</strong>，只在第一次遇到的时候对它进行求解，并把<strong>答案保存</strong>起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果。</p>
<p><strong>动态规划</strong>：用于<strong>求最值</strong>类题目，解决穷举方法中<strong>重复</strong>计算的问题，一般要留一个“<strong>备忘录</strong>”(DP table)优化重复计算，在此基础上使用“<strong>最优子结构</strong>”就是完整的动态规划。遇到此类问题思考方式：<strong>穷举-&gt;最简单情况、状态、选择、dp数组(备忘录)-&gt;状态转移方程</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">状态：dp[状态]</span><br><span class="line">    只涉及一个字符串：dp[i]表示以s[i]结尾的最长...</span><br><span class="line">    涉及两个字符串：dp加空串，dp[i][j]表示以s1[i-1]、s2[j-1]结尾的最长...(dp索引i指向的字符等于s1[i-1])</span><br><span class="line">选择：不同选择，影响当前状态存储的结果</span><br><span class="line">dp数组：根据选择、状态，找到子状态变到现状态公式，一般都是max</span><br><span class="line"></span><br><span class="line">状态压缩：前提是，当前状态，只依赖前几个状态，那么只用一维数组记录前几个状态，特殊的可用变量记录。将二维压缩为一维。</span><br></pre></td></tr></table></figure></p>
<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maWJvbmFjY2ktbnVtYmVyLw==">https://leetcode.cn/problems/fibonacci-number/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：斐波那契数列，该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</p>
<p>先来看看什么是<strong>重叠子问题</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，</span></span><br><span class="line"><span class="string">后面的每一项数字都是前面两项数字的和。也就是：</span></span><br><span class="line"><span class="string">F(0) = 0，F(1) = 1</span></span><br><span class="line"><span class="string">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span><br><span class="line"><span class="string">给定 n ，请计算 F(n) 。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例 1：</span></span><br><span class="line"><span class="string">输入：n = 2</span></span><br><span class="line"><span class="string">输出：1</span></span><br><span class="line"><span class="string">解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 暴力递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.fib(n<span class="number">-1</span>) + self.fib(n<span class="number">-2</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归中的重复子问题：计算f(20)时，需要f(19)和f(18)，计算f(19)时需要f(18)和f(17)，f(18)被多计算了一次！</span></span><br><span class="line"><span class="string">递归时间复杂度：O(2^n)，指数级复杂度。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 动态规划</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">每次计算出子问题答案，存入“备忘录”，每遇到一个问题先去“备忘录”查看，以前计算过的，直接把答案拿来用。</span></span><br><span class="line"><span class="string">可以使用数组、哈希表(字典)作为“备忘录”。</span></span><br><span class="line"><span class="string">时间复杂度：每个子问题计算一次，O(n)。</span></span><br><span class="line"><span class="string">动态规划：自底向上。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"><span class="comment"># 优化动态规划</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">技巧”状态压缩“：斐波那契计算n时，只需要n-1和n-2，所以“备忘录”存当前n的前两个就行。</span></span><br><span class="line"><span class="string">时间复杂度：降至O(1)。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">2</span> :<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># pre：n-2，cur：n-1 </span></span><br><span class="line">        pre, cur = <span class="number">1</span>, <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n+<span class="number">1</span>):</span><br><span class="line">            res = pre + cur</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = res</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure></p>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2Uv">https://leetcode-cn.com/problems/coin-change/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。<br>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。<br>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：<br>输入：<code>coins = [1, 2, 5], amount = 11</code><br>输出：<code>3</code><br>解释：11 = 5 + 5 + 1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">amount最少的硬币个数可以由 “amount-1 + 一个硬币” 得到。</span></span><br><span class="line"><span class="string">状态：amount</span></span><br><span class="line"><span class="string">选择：硬币种类，每种选/不选</span></span><br><span class="line"><span class="string">dp数组：dp[amount]，先判断amount能不能用当前硬币凑，再确定：</span></span><br><span class="line"><span class="string">       (1) 选：dp[i-coin]+1</span></span><br><span class="line"><span class="string">       (2) 不选：dp[amount]不变</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 外层for遍历所有状态</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(amount+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 内层for遍历所有选择)，最小值</span></span><br><span class="line">            <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">                <span class="keyword">if</span> coin &gt; i : <span class="keyword">continue</span>  <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 外层for遍历所有选择</span></span><br><span class="line"><span class="string">for coin in coins:</span></span><br><span class="line"><span class="string">    # 内层for遍历所有(有效)状态时，最小值</span></span><br><span class="line"><span class="string">    for i in range(coin, amount+1):</span></span><br><span class="line"><span class="string">        dp[i] = min(dp[i], dp[i-coin]+1)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW4tY29zdC1jbGltYmluZy1zdGFpcnMv">https://leetcode.cn/problems/min-cost-climbing-stairs/<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCostClimbingStairs</span>(<span class="params">self, cost: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i]表示到达i阶的最小花费</span></span><br><span class="line"><span class="string">        选择：跨1阶/2阶</span></span><br><span class="line"><span class="string">        dp数组：dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])</span></span><br><span class="line"><span class="string">                到i阶，可从 i-1(花费cost[i-1]) 或 i-2(花费cost[i-2]) 上来。</span></span><br><span class="line"><span class="string">        初始状态：dp[0]=dp[1]=0</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>]+cost[i- <span class="number">1</span>], dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 状态压缩</span></span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        pre = cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            res = <span class="built_in">min</span>(pre+cost[i<span class="number">-2</span>], cur+cost[i<span class="number">-1</span>])</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="070-爬楼梯"><a href="#070-爬楼梯" class="headerlink" title="070. 爬楼梯"></a>070. 爬楼梯</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==">https://leetcode-cn.com/problems/climbing-stairs/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcWluZy13YS10aWFvLXRhaS1qaWUtd2VuLXRpLWxjb2Yv">面试题10- II.青蛙跳台阶问题<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdGhyZWUtc3RlcHMtcHJvYmxlbS1sY2NpLw==">面试题 08.01. 三步问题<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？<br>示例 1：<br>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。（1）1 阶 + 1 阶 （2） 2 阶</p>
<div class="tabs" id="070"><ul class="nav-tabs"><li class="tab active"><a href="#070-1">爬楼梯</a></li><li class="tab"><a href="#070-2">三步问题</a></li></ul><div class="tab-content"><div class="tab-pane active" id="070-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i]表示到i阶时，有多少种方法。</span></span><br><span class="line"><span class="string">        初始状态：空台阶dp[0]=1，1阶dp[1]=1</span></span><br><span class="line"><span class="string">        选择：跨1阶/2阶</span></span><br><span class="line"><span class="string">        dp数组：计算dp[i]时，等于跨1阶/2阶方法和。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>) </span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="070-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">waysToStep</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i]表示到i阶时，有多少种方法。</span></span><br><span class="line"><span class="string">        初始状态：空台阶dp[0]=1，1阶dp[1]=1，2阶dp[2]=2</span></span><br><span class="line"><span class="string">        选择：跨1阶/2阶/3阶</span></span><br><span class="line"><span class="string">        dp数组：计算dp[i]时，等于跨1阶/2阶/3阶方法和。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>) </span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = (dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>] + dp[i<span class="number">-3</span>]) % <span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">return</span> dp[n] </span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a>120. 三角形最小路径和</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHJpYW5nbGUv">https://leetcode-cn.com/problems/triangle/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个三角形 triangle ，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<p>输入：<code>triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]</code><br>输出：<code>11</code><br>解释：自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示到位置[i][j]最小路径和。</span></span><br><span class="line"><span class="string">初始状态：左侧、右侧，都只有一种走法</span></span><br><span class="line"><span class="string">        左侧：dp[i][0] = dp[i-1][0] + triangle[i][0]</span></span><br><span class="line"><span class="string">        右侧：dp[i][i] = dp[i-1][i-1] + triangle[i][i]</span></span><br><span class="line"><span class="string">选择：ij遍历</span></span><br><span class="line"><span class="string">dp数组：计算dp[i][j]时，dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(triangle)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) + triangle[i][j]</span><br><span class="line">            dp[i][i] = dp[i<span class="number">-1</span>][i<span class="number">-1</span>] + triangle[i][i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[n<span class="number">-1</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="062-不同路径"><a href="#062-不同路径" class="headerlink" title="062. 不同路径"></a>062. 不同路径</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bmlxdWUtcGF0aHMv">https://leetcode.cn/problems/unique-paths/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i][j] 表示到[i,j]位置路径数。</span></span><br><span class="line"><span class="string">        选择：向下/向右</span></span><br><span class="line"><span class="string">        dp数组：dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"><span class="string">                当前路径数 = 左侧路径数 + 上侧路径数</span></span><br><span class="line"><span class="string">        初始状态：第0行只能从左侧到当前位置，dp[0][.]=1</span></span><br><span class="line"><span class="string">                 第0列只能从上侧到当前位置，dp[.][0]=1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp = [[<span class="number">1</span>]*n] + [[<span class="number">1</span>]+[<span class="number">0</span>]*(n<span class="number">-1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m<span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="064-最小路径和"><a href="#064-最小路径和" class="headerlink" title="064. 最小路径和"></a>064. 最小路径和</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXBhdGgtc3VtLw==">https://leetcode.cn/problems/minimum-path-sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i][j]表示到[i,j]位置时，路径最小数字总和。</span></span><br><span class="line"><span class="string">        选择：从上/左(dp[i-1][j]/dp[i][j-1])到当前位置</span></span><br><span class="line"><span class="string">        dp数组：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</span></span><br><span class="line"><span class="string">        初始状态：dp[0][0]=grid[0][0]，</span></span><br><span class="line"><span class="string">                  第0行只能从左侧到当前位置，dp[0][j] = dp[0][j-1] + grid[0][j]</span></span><br><span class="line"><span class="string">                  第0列只能从上侧到当前位置，dp[i][0] = dp[i-1][0] + grid[i][0]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYS1zaHUtemktZmFuLXlpLWNoZW5nLXppLWZ1LWNodWFuLWxjb2Yv">剑指 Offer 46. 把数字翻译成字符串<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzA0NmE1NWU2Y2QyNzRjZmZiODhmYzMyZGJhNjk1NjY4">BM69 把数字翻译成字符串<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。<br><div class="tabs" id="a"><ul class="nav-tabs"><li class="tab active"><a href="#a-1">剑指Offer.46</a></li><li class="tab"><a href="#a-2">BM69</a></li></ul><div class="tab-content"><div class="tab-pane active" id="a-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i] 表示i结尾，有多少种翻译方法，dp长度为 n+1，dp[i]对应num[i-1]。</span></span><br><span class="line"><span class="string">        选择：当前数字单独翻译/和前一个数字一起翻译</span></span><br><span class="line"><span class="string">        dp数组：dp[i]=dp[i-1]+dp[i-2]   10*num[i-2]+num[i-1]的区间为[10,25]</span></span><br><span class="line"><span class="string">               dp[i]=dp[i-1]           10*num[i-2]+num[i-1]的区间为[0,10)or(25~)</span></span><br><span class="line"><span class="string">        初始状态：dp[0]=dp[1]=1，因为dp[2]可能为2(dp[1]+dp[0])，dp[1]只有1个数字翻译方法为1，那么dp[0]就设为1。   </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="built_in">str</span>(num)</span><br><span class="line">        n = <span class="built_in">len</span>(num)</span><br><span class="line">        dp = [<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># dp[i]对应num[i-1]，dp[i-1]对应num[i-2]</span></span><br><span class="line">            <span class="comment"># if 10 &lt;= int(num[i-2:i]) &lt;= 25:</span></span><br><span class="line">            <span class="keyword">if</span> num[i<span class="number">-2</span>]==<span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> (num[i<span class="number">-2</span>]==<span class="string">&#x27;2&#x27;</span><span class="keyword">and</span> num[i<span class="number">-1</span>]&lt;<span class="string">&#x27;6&#x27;</span>):</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 状态压缩</span></span><br><span class="line">        num = <span class="built_in">str</span>(num)</span><br><span class="line">        n = <span class="built_in">len</span>(num)</span><br><span class="line">        res = pre = cur = <span class="number">1</span>  <span class="comment"># pre对应dp[i-2], cur对应dp[i-1]，res对应dp[i]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> num[i<span class="number">-2</span>]==<span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> (num[i<span class="number">-2</span>]==<span class="string">&#x27;2&#x27;</span><span class="keyword">and</span> num[i<span class="number">-1</span>]&lt;<span class="string">&#x27;6&#x27;</span>):</span><br><span class="line">                res = cur + pre</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = cur</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="a-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self , num: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        翻译不是从0开始：</span></span><br><span class="line"><span class="string">        (1) 10和20只有1种翻译</span></span><br><span class="line"><span class="string">        (2) 160无法翻译。</span></span><br><span class="line"><span class="string">        (3) dp[i]=dp[i-1]+dp[i-2]  10*num[i-2]+num[i-1]的区间为[11,19]or[21,26]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="string">&quot;0&quot;</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(num)</span><br><span class="line">        dp = [<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 排除只有一种可能的10和20</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="string">&quot;10&quot;</span> <span class="keyword">or</span> num == <span class="string">&quot;20&quot;</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="comment">#当0的前面不是1或2时，无法译码，0种</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(num)):</span><br><span class="line">            <span class="keyword">if</span> num[i]==<span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> num[i<span class="number">-1</span>]!=<span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> num[i<span class="number">-1</span>]!=<span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># dp[i]对应num[i-1]，dp[i-1]对应num[i-2]</span></span><br><span class="line">            <span class="keyword">if</span> (num[i<span class="number">-2</span>]==<span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> num[i<span class="number">-1</span>]!=<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> (num[i<span class="number">-2</span>]==<span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> num[i<span class="number">-1</span>]&gt;<span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> num[i<span class="number">-1</span>]&lt;<span class="string">&#x27;7&#x27;</span>):</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="053-最大子数组和"><a href="#053-最大子数组和" class="headerlink" title="053. 最大子数组和"></a>053. 最大子数组和</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=">https://leetcode-cn.com/problems/maximum-subarray/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>nums</code> ，请你找出一个具有<code>最大和的连续子数组</code>（子数组最少包含一个元素），返回其最大和。<strong>子数组</strong> 是数组中的一个<strong>连续</strong>部分。<br>示例 1：<br>输入：<code>nums = [-2,1,-3,4,-1,2,1,-5,4]</code><br>输出：<code>6</code><br>解释：连续子数组 <code>[4,-1,2,1]</code> 的和最大，为 6 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：d[i] nums[i]结尾子数组最大和</span></span><br><span class="line"><span class="string">        选择：因为连续数组，只能选择dp[i-1]+nums[i] 或 nums[i]</span></span><br><span class="line"><span class="string">        dp数组：dp[i] = max(nums[i], dp[i-1]+nums[i])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        状态压缩：dp[i] 仅和 dp[i-1] 相关，用pre记录dp[i-1]，cur记录dp[i]，代码中还可再省略cur。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i], dp[i<span class="number">-1</span>]+nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 状态压缩</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre = maxs = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            pre = <span class="built_in">max</span>(pre+nums[i], nums[i])</span><br><span class="line">            maxs = <span class="built_in">max</span>(pre, maxs)</span><br><span class="line">        <span class="keyword">return</span> maxs</span><br></pre></td></tr></table></figure>
<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlLw==">https://leetcode-cn.com/problems/longest-increasing-subsequence/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>nums</code> ，找到其中最<strong>长严格递增子序列</strong>的长度。<strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。<br>示例 1：<br>输入：<code>nums = [10,9,2,5,3,7,101,18]</code><br>输出：<code>4</code><br>解释：最长递增子序列是 <code>[2,3,7,101]</code>，因此长度为 <code>4</code> 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：nums[i]结尾，最长递增子序列长度</span></span><br><span class="line"><span class="string">        选择：nums[j], j为比nums[i]小的值在nums的索引</span></span><br><span class="line"><span class="string">        dp数组：dp[i] = max(dp[i], dp[j]+1)，返回max(dp)</span></span><br><span class="line"><span class="string">        初始状态：dp[0~n-1]=1，初始时最长子序列长度为1，只有自己。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums) <span class="comment"># 初始值为1，最长递增子序列只有自己</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)): </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure></p>
<h2 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数"></a>673. 最长递增子序列的个数</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlLw==">https://leetcode.cn/problems/number-of-longest-increasing-subsequence/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个未排序的整数数组 nums ， 返回最长递增子序列的个数 。注意 这个数列必须是 严格 递增的。<br>示例 1:<br>输入: <code>[1,3,5,4,7]</code><br>输出: <code>2</code><br>解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加一个dp数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：</span></span><br><span class="line"><span class="string">            dp[i]：到nums[i]为止的最长递增子序列长度</span></span><br><span class="line"><span class="string">            count[i]：到nums[i]为止的最长递增子序列个数</span></span><br><span class="line"><span class="string">        选择：</span></span><br><span class="line"><span class="string">            如果dp[j]+1 &gt; dp[i],说明最长递增子序列的长度增加了,dp[i]=dp[j]+1,长度增加,数量和cnt[j]一样(cnt[i]=cnt[j])</span></span><br><span class="line"><span class="string">            如果dp[j]+1 == dp[i],说明最长递增子序列的长度没增加,但出现了长度一样的情况,数量增加cnt[j]个(cnt[i]+=cnt[j])</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * n  <span class="comment"># 初始值为1，最长递增子序列只有自己</span></span><br><span class="line">        cnt = [<span class="number">1</span>] * n  <span class="comment"># 初始值为1，最长递增子序列只有自己，数量为1</span></span><br><span class="line">        mlen = msum = <span class="number">0</span>  <span class="comment"># mlen：最长最长递增子序列长度，msum：长度为mlen的子序列数量</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    <span class="keyword">if</span> dp[j]+<span class="number">1</span> &gt; dp[i]:</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>  <span class="comment"># 更新最长长度</span></span><br><span class="line">                        cnt[i] = cnt[j]  <span class="comment"># 数量和cnt[j]一样</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[j]+<span class="number">1</span> == dp[i]:</span><br><span class="line">                        cnt[i] += cnt[j]  <span class="comment"># 数量增加cnt[j]个</span></span><br><span class="line">        <span class="comment"># 找到最长长度，统计最长长度数量</span></span><br><span class="line">        mlen = <span class="built_in">max</span>(dp)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> dp[i] == mlen: </span><br><span class="line">                    msum += cnt[i]</span><br><span class="line">        <span class="keyword">return</span> msum</span><br></pre></td></tr></table></figure></p>
<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv">https://leetcode-cn.com/problems/longest-common-subsequence/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzZkMjk2MzhjODViYjRmZmQ4MGMwMjBmZTI0NGJhZjEx">BM65 最长公共子序列(二)<i class="fa fa-external-link-alt"></i></span>；<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlL2YzM2Y1YWRjNTVmNDQ0YmFhMGUwY2E4N2FkOGE2YWFj">BM66 最长公共子串<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的 <strong>最长公共子序列</strong> 的长度。如果不存在 公共子序列 ，返回 <code>0</code> 。一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。<strong>子串</strong>：必须是连续的块。<strong>子序列</strong>：可以是非连续的块。<br>示例 1：<br>输入：<code>text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;</code><br>输出：<code>3</code><br>解释：最长公共子序列是 “ace” ，它的长度为 3 。<br><div class="tabs" id="1143"><ul class="nav-tabs"><li class="tab active"><a href="#1143-1">最长公共子序列</a></li><li class="tab"><a href="#1143-2">最长公共子序列(返回字符)</a></li><li class="tab"><a href="#1143-3">最长公共子串(返回字符)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="1143-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i][j]表示 s1[0~i-1] 和 s2[0~j-1] 两个字符串 最长公共子序列 的长度</span></span><br><span class="line"><span class="string">            s1 和 s2 长度为 m, n，dp表初始化加空串，dp需要存储(m+1)*(n+1)个，下标为[0~m][0~n]</span></span><br><span class="line"><span class="string">            dp[0][.] 和 dp[.][0] 都有一个为空串，所以lcs的初值都为0</span></span><br><span class="line"><span class="string">            s1 和 s2 字符索引为 [0~m-1],[0~n-1]，对应dp表索引为[1~m][1~n]</span></span><br><span class="line"><span class="string">        选择：计算 s[i] 和 s[j] 时，有两种选择：</span></span><br><span class="line"><span class="string">            s[i]==s2[j]：该字符一定在公共子序列中。</span></span><br><span class="line"><span class="string">            s[i]!=s2[j]：至少一个(s1[i] 或 s2[j])不在公共子序列中。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># dp长度和text1、text2长度不同：text1和text2字符索引为[0~m-1][0~n-1]，对应dp表索引为[1~m][1~n]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]:  <span class="comment"># dp[i]对应text1[i-1]字符</span></span><br><span class="line">                    <span class="comment"># 取 左上 最长公共子序列 的长度 + 1</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>  </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 取 左/上 最长公共子序列长度 最大值</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="1143-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LCS</span>(<span class="params">self , s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2)</span><br><span class="line">        dp = [[<span class="string">&#x27;&#x27;</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]:  <span class="comment"># dp[i]对应s1[i-1]字符</span></span><br><span class="line">                    <span class="comment"># 取(左上)最长公共子序列字符串 + 当前字符</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + s1[i<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 取(左/上)最长公共子序列字符串</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(dp[i<span class="number">-1</span>][j]) &gt;= <span class="built_in">len</span>(dp[i][j<span class="number">-1</span>]):</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n] <span class="keyword">if</span> dp[m][n] <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="1143-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LCS</span>(<span class="params">self , str1: <span class="built_in">str</span>, str2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(str1), <span class="built_in">len</span>(str2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        mlen, end = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>  <span class="comment"># 字串必须连续，不相等重置为0</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] &gt; mlen:  <span class="comment"># 更新最长长度，字符下标</span></span><br><span class="line">                    mlen = dp[i][j]</span><br><span class="line">                    end = i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> str1[end-mlen+<span class="number">1</span>: end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="647-回文子串-个数"><a href="#647-回文子串-个数" class="headerlink" title="647. 回文子串(个数)"></a>647. 回文子串(个数)</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21pYy1zdWJzdHJpbmdzLw==">https://leetcode.cn/problems/palindromic-substrings/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 s ，请你统计并返回这个字符串中 <strong>回文子串的数目</strong>。<br>示例 1：<br>输入：<code>s = &quot;aaa&quot;</code><br>输出：<code>6</code><br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示s[i~j]是否为回文字符串。</span></span><br><span class="line"><span class="string">初始状态：不需要加空串。只有一个字符(i==j)时结果为True; i&gt;j越界没有字符，结果为False。最终结束在dp[0][n-1]。</span></span><br><span class="line"><span class="string">选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">dp数组：再判断s[i]是否等于s[j]情况：</span></span><br><span class="line"><span class="string">            只有一个字符：dp[i][i] = True</span></span><br><span class="line"><span class="string">            两个字符相等：</span></span><br><span class="line"><span class="string">                        只有两个字符：dp[i][j] = True</span></span><br><span class="line"><span class="string">                        三个及以上字符：dp[i][j] = dp[i+1][j-1]</span></span><br><span class="line"><span class="string">                        三个及以上字符，假如求&quot;abcba&quot;，&quot;axxxa&quot;边上两个字符相等，只需看&quot;bcb&quot;的是否为回文串</span></span><br><span class="line"><span class="string">            两个字符不相等：dp[i][j] = False</span></span><br><span class="line"><span class="string">        需要左下位置信息，最终结果dp[0][n-1]，所以斜着(左上-&gt;右下)或反着(i从下-&gt;上,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(s)):  <span class="comment"># 从i开始</span></span><br><span class="line">                <span class="comment"># s[i]和s[j]相等，并且字符数&lt;=2，是回文串</span></span><br><span class="line">                <span class="comment"># 三个及以上字符，s[i]和s[j]相等，且dp[i+1][j-1]==True，是回文串</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (j-i+<span class="number">1</span>&lt;=<span class="number">2</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>]):</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="005-最长回文子串"><a href="#005-最长回文子串" class="headerlink" title="005. 最长回文子串"></a>005. 最长回文子串</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21pYy1zdWJzdHJpbmcv">https://leetcode-cn.com/problems/longest-palindromic-substring/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlL2I0NTI1ZDFkODQ5MzRjZjI4MDQzOWFlZWNjMzZmNGFm">BM73 最长回文子串<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：给你一个字符串 <code>s</code>，找到 <code>s</code> 中<strong>最长的回文子串</strong>。<br>示例 1：<br>输入：<code>s = &quot;babad&quot;</code><br>输出：<code>&quot;bab&quot;</code><br>解释：”aba” 同样是符合题意的答案。</p>
<div class="tabs" id="5"><ul class="nav-tabs"><li class="tab active"><a href="#5-1">动态规划</a></li><li class="tab"><a href="#5-2">中心扩展</a></li><li class="tab"><a href="#5-3">BM73 最长回文子串(长度)</a></li></ul><div class="tab-content"><div class="tab-pane active" id="5-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示s[i~j]是否为回文字符串。</span></span><br><span class="line"><span class="string">初始状态：不需要加空串。只有一个字符(i==j)时结果为True; i&gt;j越界没有字符，结果为False。最终结束在dp[0][n-1]。</span></span><br><span class="line"><span class="string">选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">dp数组：再判断s[i]是否等于s[j]情况：</span></span><br><span class="line"><span class="string">            只有一个字符：dp[i][i] = True</span></span><br><span class="line"><span class="string">            两个字符相等：</span></span><br><span class="line"><span class="string">                        只有两个字符：dp[i][j] = True</span></span><br><span class="line"><span class="string">                        三个及以上字符：dp[i][j] = dp[i+1][j-1]</span></span><br><span class="line"><span class="string">                        三个及以上字符，假如求&quot;abcba&quot;，&quot;axxxa&quot;边上两个字符相等，只需看&quot;bcb&quot;的是否为回文串</span></span><br><span class="line"><span class="string">            两个字符不相等：dp[i][j] = False</span></span><br><span class="line"><span class="string">        需要左下位置信息，最终结果dp[0][n-1]，所以斜着(左上-&gt;右下)或反着(i从下-&gt;上,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        mlen, begin = <span class="number">1</span>, <span class="number">0</span>  <span class="comment"># 最长回文串长度，最长回文串起始位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> j-i+<span class="number">1</span>&lt;=<span class="number">2</span>:  <span class="comment"># i和j相等，并且字符数&lt;=2，是回文串</span></span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="comment">#dp[i][j]表示子串 s[i..j]，若是回文串，更新串长度、起始位置</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j-i+<span class="number">1</span> &gt; mlen:</span><br><span class="line">                    mlen = j-i+<span class="number">1</span></span><br><span class="line">                    begin = i</span><br><span class="line">        <span class="keyword">return</span> s[begin: begin+mlen]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="5-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    以每个字符为中心，向两边扩展。这里有两种情况，回文串为奇数、偶数，所以扩展的中心可以有字符，也可以为空。</span></span><br><span class="line"><span class="string">    时间复杂度：O(n^2)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span>(<span class="params">self, s, left, right</span>):</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回回文串 [左边界,右边界]</span></span><br><span class="line">        <span class="keyword">return</span> left+<span class="number">1</span>, right<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):  <span class="comment"># 以每个点为中心</span></span><br><span class="line">            <span class="comment"># 分奇数长度和偶数长度向两边扩展</span></span><br><span class="line">            left1, right1 = self.expandAroundCenter(s, i, i)  <span class="comment"># 奇数回文串，中心为s[i]</span></span><br><span class="line">            left2, right2 = self.expandAroundCenter(s, i, i+<span class="number">1</span>)  <span class="comment"># 偶数回文串，中心为s[i]和s[i+1]</span></span><br><span class="line">            <span class="comment"># 计算两种回文串长度，若比记录的长就更新</span></span><br><span class="line">            <span class="keyword">if</span> right1-left1 &gt; end-start:  <span class="comment"># 回文串长度：右-左+1，都有+1可省略</span></span><br><span class="line">                start, end = left1, right1</span><br><span class="line">            <span class="keyword">if</span> right2-left2 &gt; end-start:</span><br><span class="line">                start, end = left2, right2</span><br><span class="line">        <span class="keyword">return</span> s[start: end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="5-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    以每个字符为中心，向两边扩展。这里有两种情况，回文串为奇数、偶数，所以扩展的中心可以有字符，也可以为空。</span></span><br><span class="line"><span class="string">    时间复杂度：O(n^2)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">self, s: <span class="built_in">str</span>, begin: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 每个中心点开始扩展</span></span><br><span class="line">        <span class="keyword">while</span> begin &gt;= <span class="number">0</span> <span class="keyword">and</span> end &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[begin] == s[end]:</span><br><span class="line">            begin -= <span class="number">1</span></span><br><span class="line">            end += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> end-begin<span class="number">-1</span>  <span class="comment"># 返回长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLongestPalindrome</span>(<span class="params">self , A: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        maxlen = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 以每个点为中心</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)<span class="number">-1</span>):  <span class="comment"># len(A)也行</span></span><br><span class="line">            <span class="comment"># 分奇数长度和偶数长度向两边扩展</span></span><br><span class="line">            maxlen = <span class="built_in">max</span>(maxlen, <span class="built_in">max</span>(self.fun(A, i, i), self.fun(A, i, i+<span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> maxlen</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21pYy1zdWJzZXF1ZW5jZS8=">https://leetcode-cn.com/problems/longest-palindromic-subsequence/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。<br>示例 1：<br>输入：<code>s = &quot;bbbab&quot;</code><br>输出：<code>4</code><br>解释：一个可能的最长回文子序列为 “bbbb” 。</p>
<p>这里注意<strong>回文子串</strong>、<strong>回文子序列</strong>区别：<br>（1）<strong>回文子串</strong>：dp存储True、False判断，这样可保证新串是连续的；<br>（2）<strong>回文子序列</strong>：dp存储长度，这样在新序列中可以继承子序列长度，新序列可以非连续的。<br><div class="tabs" id="516"><ul class="nav-tabs"><li class="tab active"><a href="#516-1">动态规划</a></li><li class="tab"><a href="#516-2">状态压缩</a></li></ul><div class="tab-content"><div class="tab-pane active" id="516-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示s[i~j]中，最长回文子序列长度。最终结果dp[0][n-1]。</span></span><br><span class="line"><span class="string">初始状态：不需要加空串。只有一个字符(i==j)时结果为1; i&gt;j越界没有字符，结果为0。</span></span><br><span class="line"><span class="string">选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">dp数组：假如知道&quot;bcb&quot;，就可以求&quot;abcba&quot;，只需&quot;bcb&quot;的最长回文序列长度，判断s[i]是否等于s[j]情况：</span></span><br><span class="line"><span class="string">            两个字符相等：两个字符都加入回文序列，int(s[i]==s[j])*2。</span></span><br><span class="line"><span class="string">            两个字符不相等：两个字符单独加入回文序列，取长的那个，max(dp[i+1][j], dp[i][j-1])。</span></span><br><span class="line"><span class="string">        需要左下、左、下，三个位置信息，最终结果dp[0][n-1]，所以斜着(左上-&gt;右下)或反着(i从下-&gt;上,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i][i] = <span class="number">1</span>  <span class="comment"># 只有一个字符(i==j)时结果为1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>  <span class="comment"># 左下</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>])  <span class="comment"># 下、左</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="516-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">去掉[i]这个维度，只用[j]。计算s[j]时：</span></span><br><span class="line"><span class="string">    dp[j-1]: 当前左边的元素(dp[i][j-1])</span></span><br><span class="line"><span class="string">    dp[j]: 没覆盖前的值，代表当前下边的元素(dp[i+1][j])</span></span><br><span class="line"><span class="string">    next: 在计算给s[j+1]用，代表s[j+1]左下的元素(dp[i+1][j-1])</span></span><br><span class="line"><span class="string">    pre：s[j+1]时使用，记录上次循环next中存储的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [<span class="number">0</span>] * n </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            pre = <span class="number">0</span>  <span class="comment"># i次循环的左下初值   </span></span><br><span class="line">            dp[i] = <span class="number">1</span>  <span class="comment"># 只有一个字符(i==j)时结果为1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="built_in">next</span> = dp[j]</span><br><span class="line">                left = dp[j<span class="number">-1</span>]</span><br><span class="line">                down = dp[j]</span><br><span class="line">                left_down = pre</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[j] = left_down + <span class="number">2</span>  <span class="comment"># </span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(down, left)  <span class="comment"># 下、左</span></span><br><span class="line">                pre = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="1312-成为回文串的最少插入次数"><a href="#1312-成为回文串的最少插入次数" class="headerlink" title="1312. 成为回文串的最少插入次数"></a>1312. 成为回文串的最少插入次数</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1pbnNlcnRpb24tc3RlcHMtdG8tbWFrZS1hLXN0cmluZy1wYWxpbmRyb21lLw==">https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。「回文串」是正读和反读都相同的字符串。</p>
<p>示例 1：<br>输入：<code>s = &quot;zzazz&quot;</code><br>输出：<code>0</code><br>解释：字符串 “zzazz” 已经是回文串了，所以不需要做任何插入操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minInsertions</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示字符串s[i~j]，成为回文串的最少插入次数。 最终求dp[0][n-1]大小。</span></span><br><span class="line"><span class="string">初始状态：当i==j时，只有一个字符已经是回文串，插入次数为0，dp[i][j]=0</span></span><br><span class="line"><span class="string">选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">dp数组：知道dp[i+1][j-1]，求dp[i][j]? dp[i+1][j-1]已经是回文串了，只需看s[i]和s[j]字符：</span></span><br><span class="line"><span class="string">        (1) 两个字符相等：不需要插入，dp[i][j]=dp[i+1][j-1]。</span></span><br><span class="line"><span class="string">        (2) 两个字符不相等：需要插入</span></span><br><span class="line"><span class="string">            (1) 两个字符都插入：s[i]插入到s[j]右侧，s[j]插入到s[i]右侧，s[i~j]必为回文串。dp[i+1][j-1]+2</span></span><br><span class="line"><span class="string">            (2) 只插入一个字符：比如&#x27;aa&#x27;左侧/右侧插入&#x27;a&#x27;；选择最小的那个。min(dp[i+1][j], dp[i][j-1]) + 1</span></span><br><span class="line"><span class="string">            其中&quot;只插入一个字符&quot;包括了&quot;两个字符都插入&quot;的情况，代码中可省略&quot;两个字符都插入&quot;。</span></span><br><span class="line"><span class="string">        需要左下、左、下，三个位置信息，最终结果dp[0][n-1]，所以斜着(左上-&gt;右下)或反着(i从下-&gt;上,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># dp已经初始化, i从n-2开始</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] <span class="comment"># 跳过</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 左插入s[j]字符(dp[i+1][j])，右插入s[i]字符(dp[i][j-1])</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j]) + <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h2 id="072-编辑距离"><a href="#072-编辑距离" class="headerlink" title="072. 编辑距离"></a>072. 编辑距离</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZWRpdC1kaXN0YW5jZS8=">https://leetcode-cn.com/problems/edit-distance/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你两个单词 <code>word1</code> 和 <code>word2</code>， 请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的<strong>最少操作数</strong>。<br>你可以对一个单词进行如下三种操作：插入一个字符、删除一个字符、替换一个字符。</p>
<p>示例 1：<br>输入：<code>word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</code><br>输出：<code>3</code><br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p>
<div class="tabs" id="72"><ul class="nav-tabs"><li class="tab active"><a href="#72-1">动态规划</a></li><li class="tab"><a href="#72-2">状态压缩</a></li></ul><div class="tab-content"><div class="tab-pane active" id="72-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i][j]表示word1[0~i-1]和word2[0~j-1]的编辑距离。最终结果dp[m][n]。</span></span><br><span class="line"><span class="string">        初始状态：dp的i==0、j==0加空串，dp[i][0]初始值为i(j为空串,距离为i)，dp[0][j]初始值为j(i为空串,距离为j)。</span></span><br><span class="line"><span class="string">        选择：i和j向两边扩展</span></span><br><span class="line"><span class="string">        dp数组：计算dp[i][j]，判断s1[i-1]是否等于s2[j-1]情况：</span></span><br><span class="line"><span class="string">            (1) 两个字符相等：dp[i][j]=dp[i-1][j-1]，当前字符不需要编辑。</span></span><br><span class="line"><span class="string">            (2) 两个字符不相等：</span></span><br><span class="line"><span class="string">                (1) 插入：s1[0~i-1]到s2[0~j-2]距离 + s[i-1]后面插入s[j-1], dp[i][j-1] + 1。</span></span><br><span class="line"><span class="string">                (2) 删除：s1[0~i-2]到s2[0~j-1]距离 + s[i-1]字符删除,       dp[i-1][j] + 1。    </span></span><br><span class="line"><span class="string">                (3) 替换：s1[0~i-2]到s2[0~j-2]距离 + s[i-1]替换为s[j-1],   dp[i-1][j-1] + 1。   </span></span><br><span class="line"><span class="string">        插入解释：经过dp[i][j-1]编辑后，s1[0~i-1]和s2[0~j-2]相同了，再经过插入操作，s1[0~i-1]和s2[0~j-1]相同了。</span></span><br><span class="line"><span class="string">        需要左、上、左上位置信息，最终结果dp[m][n]，所以正着(i从上-&gt;下,j从左-&gt;右)遍历。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        <span class="comment"># 有一个字符串为空串</span></span><br><span class="line">        <span class="keyword">if</span> m * n == <span class="number">0</span>: <span class="keyword">return</span> m + n</span><br><span class="line">        dp = [ [<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 边界状态初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>): dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>): dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="comment"># 计算所有 DP 值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                left = dp[i][j<span class="number">-1</span>] + <span class="number">1</span>  <span class="comment"># 插入</span></span><br><span class="line">                up = dp[i<span class="number">-1</span>][j] + <span class="number">1</span>  <span class="comment"># 删除</span></span><br><span class="line">                left_up = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>  <span class="comment"># 替换</span></span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]  <span class="comment"># 当前字符不需要编辑</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(left, up, left_up)  <span class="comment"># 三种选择，取编辑距离最小的</span></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="72-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示word1的前i个字符和word2的前j个字符的编辑距离。</span></span><br><span class="line"><span class="string">状态压缩：用一维数组,表示原来二维数组中的一行,然后我们就反复覆盖里面的值。计算s[j]时：</span></span><br><span class="line"><span class="string">          dp[j-1]: 当前左边的元素(dp[i][j-1])</span></span><br><span class="line"><span class="string">          dp[j]: 没覆盖前的值，代表当前上边的元素(dp[i-1][j])</span></span><br><span class="line"><span class="string">          next: 在计算给s[j+1]用，代表s[j+1]左上的元素(dp[i-1][j-1])</span></span><br><span class="line"><span class="string">          pre：s[j+1]时使用，记录上次循环next中存储的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = <span class="built_in">list</span>(<span class="built_in">range</span>(n+<span class="number">1</span>)) <span class="comment"># dp[0]行初始值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            pre = dp[<span class="number">0</span>]  <span class="comment"># i次循环的左上初值</span></span><br><span class="line">            dp[<span class="number">0</span>] = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="built_in">next</span> = dp[j]  <span class="comment"># 记录下来，作为s[j+1]的左上</span></span><br><span class="line">                left = dp[j<span class="number">-1</span>] + <span class="number">1</span>  <span class="comment"># s1[i] -&gt; s2[j-1] -&gt; 插入</span></span><br><span class="line">                up = dp[j] + <span class="number">1</span>  <span class="comment"># s1[i-1] -&gt; s2[j] -&gt; s1[i]删除</span></span><br><span class="line">                left_up = pre + <span class="number">1</span>  <span class="comment"># s1[i-1] -&gt; s2[j-1] -&gt; 替换</span></span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[j] = pre  <span class="comment"># 跳过</span></span><br><span class="line">                <span class="keyword">else</span>: </span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(left, up, left_up)  </span><br><span class="line">                pre = <span class="built_in">next</span>  <span class="comment"># 用于下次循环</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a>354. 俄罗斯套娃信封问题</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcnVzc2lhbi1kb2xsLWVudmVsb3Blcy8=">https://leetcode-cn.com/problems/russian-doll-envelopes/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个<strong>二维整数数组</strong> <code>envelopes</code> ，其中 <code>envelopes[i] = [wi, hi]</code> ，表示第 <code>i</code> 个信封的宽度和高度。<br>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。<br>请计算 <strong>最多能有多少个</strong> 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。<br>注意：不允许旋转信封。<br>示例 1：<br>输入：<code>envelopes = [[5,4],[6,4],[6,7],[2,3]]</code><br>输出：<code>3</code><br>解释：最多信封的个数为 3, 组合为: <code>[2,3] =&gt; [5,4] =&gt; [6,7]</code>。</p>
<p>二分法比较烧脑，可看<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcnVzc2lhbi1kb2xsLWVudmVsb3Blcy9zb2x1dGlvbi9qaW4temhpLXRhby13YS10dS1qaWUtZ3VvLWNoZW5nLWJ5LXphb3poLXJ1YmYv">zaozhe 题解<i class="fa fa-external-link-alt"></i></span>详细解释。<br><div class="tabs" id="354"><ul class="nav-tabs"><li class="tab active"><a href="#354-1">动态规划</a></li><li class="tab"><a href="#354-2">二分搜索+动态规划</a></li></ul><div class="tab-content"><div class="tab-pane active" id="354-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超出时间限制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i] envelopes[i]为最大信封，套娃信封个数</span></span><br><span class="line"><span class="string">        选择：所有比envelopes[i]小的信封</span></span><br><span class="line"><span class="string">        先对信封排序：按宽度由小-&gt;大，宽相等的按高度由大-&gt;小，最后只需对高度求最长递增子序列</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 宽度由小-&gt;大，宽相等的按高度由大-&gt;小</span></span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        dp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(envelopes)):</span><br><span class="line">            dp.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> envelopes[j][<span class="number">1</span>] &lt; envelopes[i][<span class="number">1</span>]: </span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="354-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i]表示当最长序列长度为i时最外面一层信封的最小h</span></span><br><span class="line"><span class="string">        选择：所有比envelopes[i]小的信封</span></span><br><span class="line"><span class="string">        先对信封排序：按宽度由小-&gt;大，宽相等的按高度由大-&gt;小，最后只需对高度求最长递增子序列</span></span><br><span class="line"><span class="string">        dp值是严格单调递增的，因为越长的子序列的末尾元素显然越大。</span></span><br><span class="line"><span class="string">        当h_i大于dp中的最大值，说明可以添加h_i组成更长的序列</span></span><br><span class="line"><span class="string">        否则把h_i当作最外层最小h，替换掉首个比h_i大的h：</span></span><br><span class="line"><span class="string">            从dp中找出比h_i小的最大元素dp[index]，使 dp[index]&lt; h_i &lt;dp[index+1]</span></span><br><span class="line"><span class="string">            那么h_i可以接在dp[index]后面，形成长度为 index+1 序列，更新 dp[index+1]=h_i</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 宽度由小-&gt;大，宽相等的按高度由大-&gt;小</span></span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        dp = [envelopes[<span class="number">0</span>][<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(envelopes)):</span><br><span class="line">            <span class="comment"># 3.8新增语法，:=表示先赋值给中间变量num，再去判断</span></span><br><span class="line">            <span class="keyword">if</span> (num := envelopes[i][<span class="number">1</span>]) &gt; dp[<span class="number">-1</span>]:</span><br><span class="line">                dp.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 二分查找：(dp必须已排序)在dp数组中插入num，返回插入位置(有重复插入左侧)</span></span><br><span class="line">                index = bisect.bisect_left(dp, num)  <span class="comment"># 这里插入位置默认为index+1了</span></span><br><span class="line">                dp[index] = num</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(dp)</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="010-正则表达式匹配"><a href="#010-正则表达式匹配" class="headerlink" title="010. 正则表达式匹配"></a>010. 正则表达式匹配</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVndWxhci1leHByZXNzaW9uLW1hdGNoaW5nLw==">https://leetcode-cn.com/problems/regular-expression-matching/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>.</code> 和 <code>*</code> 的正则表达式匹配。<code>.</code> 匹配任意单个字符。<code>*</code> 匹配零个或多个前面的那一个元素。所谓匹配，是要涵盖 整个 字符串 <code>s</code> 的，而不是部分字符串。</p>
<p>本题较为复杂，可参考 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVndWxhci1leHByZXNzaW9uLW1hdGNoaW5nL3NvbHV0aW9uL2h1aS1zdS1oZS1kb25nLXRhaS1ndWktaHVhLWJ5LW1sLXppbWluZ21lbmcv">腐烂的橘子 题解<i class="fa fa-external-link-alt"></i></span>中的解释。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示s[0~i-1]和p[0~j-1]是否匹配，这里行列添加空串，所以dp的i,j的字符，对应s的i-1,j-1字符。</span></span><br><span class="line"><span class="string">初始状态：行列加空串，只有dp[0][0] = True。</span></span><br><span class="line"><span class="string">选择：i和j向后扩展，结果为dp[m][n]。</span></span><br><span class="line"><span class="string">dp数组：计算dp[i][j]时，判断当前两个字符s[i-1]和p[j-1]情况：</span></span><br><span class="line"><span class="string">        (1) 如果p[j-1]为&#x27;.&#x27;：相当于s[i-1] == p[j-1]，取决于dp[i-1][j-1]是否匹配</span></span><br><span class="line"><span class="string">        (2) 如果p[j-1]为字符：</span></span><br><span class="line"><span class="string">            (1) s[i-1] != p[j-1]：无法继续匹配，False</span></span><br><span class="line"><span class="string">            (2) s[i-1] == p[j-1]：取决于dp[i-1][j-1]是否匹配</span></span><br><span class="line"><span class="string">        (3) 如果p[j-1]为&#x27;*&#x27;，看p[j-2]和s[i-1]：</span></span><br><span class="line"><span class="string">            (1) p[j-2] == &#x27;.&#x27;：   &#x27;*&#x27;可匹配0次/多次(dp[i][j-2]/dp[i-1][j])。</span></span><br><span class="line"><span class="string">            (2) s[i-1] == p[j-2]：&#x27;*&#x27;可匹配0次/多次(dp[i][j-2]/dp[i-1][j])。</span></span><br><span class="line"><span class="string">            (3) s[i-1] != p[j-2]：&#x27;*&#x27;只能匹配0次，dp[i][j-2]。</span></span><br><span class="line"><span class="string">            匹配0次：忽略p[j-2]和p[j-1]，看s[i-1]和p[j-3]能否匹配，dp[i][j-2]。</span></span><br><span class="line"><span class="string">            匹配多次：将s[i-1]前面的与p[j-1]重新比较，dp[i-1][j]。</span></span><br><span class="line"><span class="string">p[j-1]为&#x27;*&#x27;时，为什么看p[j-2]和s[i-1]？因为此时p[j-1]是和p[j-2]为一体的了并且以p[j-2]的字符为主。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">and</span> <span class="built_in">len</span>(p) == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="comment">#当S为空，P不空，要看P是否为 a*b*这种结构</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] <span class="keyword">or</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> p[j<span class="number">-2</span>] == s[i<span class="number">-1</span>] <span class="keyword">or</span> p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j] <span class="keyword">or</span> dp[i][j<span class="number">-2</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure></p>
<h2 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a>887. 鸡蛋掉落</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VwZXItZWdnLWRyb3Av">https://leetcode-cn.com/problems/super-egg-drop/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你 <code>k</code> 枚相同的鸡蛋，并可以使用一栋从第 <code>1</code> 层到第 <code>n</code> 层共有 <code>n</code> 层楼的建筑。已知存在楼层 <code>f</code> ，满足 <code>0 &lt;= f &lt;= n</code> ，任何从 <strong>高于</strong> <code>f</code> 的楼层落下的鸡蛋都会碎，从 <code>f</code> 楼层或比它低的楼层落下的鸡蛋都不会破。每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 <code>x</code> 扔下（满足 <code>1 &lt;= x &lt;= n</code>）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 <strong>重复使用</strong> 这枚鸡蛋。给定 <code>k</code> 个鸡蛋，楼层数 <code>n</code>，请你计算并返回要确定 <code>f</code> <strong>确切的值</strong> 的 <strong>最小操作(扔鸡蛋)次数</strong> 是多少？ 换句话说，<strong>最坏</strong>情况下，<strong>至少</strong>扔几次蛋，才能确定楼层 <code>f</code> ？<strong>最坏</strong>：仍蛋的次数，在最坏情况下，是最少的。</p>
<p>示例 1：<br>输入：<code>k = 1, n = 2</code><br>输出：<code>2</code><br>解释：鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。<br>如果它没碎，那么肯定能得出 f = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提示：如果不加鸡蛋数量限制，可用二分搜索得到最小操作次数。本题用动态规划。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：“dp[n][k]=m 表示有k个蛋，共n层楼，最小操作次数m”，转换下思维：</span></span><br><span class="line"><span class="string">              “dp[m][k]=n 表示有k个蛋，最多仍m次，能确定f所在的最高楼层数n”；</span></span><br><span class="line"><span class="string">              确定m的上限，一定是 &lt;=n 的(线性扫描)。</span></span><br><span class="line"><span class="string">        初始状态：只能仍1次，不管蛋多少个，最高确定1层楼；</span></span><br><span class="line"><span class="string">                  只有1个蛋，最高确定层数等于仍的次数。</span></span><br><span class="line"><span class="string">        选择：无论在哪层仍蛋，只有2种结果：碎了测楼下，没碎测楼上。所以不需要考虑选择在哪仍蛋。</span></span><br><span class="line"><span class="string">        dp表：无论楼上楼下，总楼层数 = 楼上的楼层数 + 楼下的楼层数 + 1(当前楼层)</span></span><br><span class="line"><span class="string">              蛋没碎：当前楼层上方可以有 dp[m-1][k] 层。</span></span><br><span class="line"><span class="string">              蛋碎：当前楼层下方可以有 dp[m-1][k-1] 层。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(k+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 只能仍1次，不管蛋多少个，最高确定1层楼。</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        m = <span class="number">-1</span>  <span class="comment"># 存储最终结果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):  <span class="comment"># 次数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k+<span class="number">1</span>):  <span class="comment"># 蛋数</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span> + dp[i<span class="number">-1</span>][j] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>] </span><br><span class="line">            <span class="keyword">if</span> dp[i][k] &gt;= n: <span class="comment"># 首次达到目标楼层数，取出最小操作次数m</span></span><br><span class="line">                m = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure>
<h2 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a>312. 戳气球</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYnVyc3QtYmFsbG9vbnMv">https://leetcode-cn.com/problems/burst-balloons/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：有 <code>n</code> 个气球，编号为 <code>0</code> 到 <code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code> 相邻的两个气球的序号。如果 <code>i - 1</code> 或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。求所能获得硬币的最大数量。</p>
<p>示例 1：<br>输入：<code>nums = [3,1,5,8]</code><br>输出：<code>167</code><br>解释：<br><code>nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []</code><br><code>coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        在nums两边加上值为1的虚拟气球，nums长度为len(nums)+2。</span></span><br><span class="line"><span class="string">        状态：dp[i][j]表示i~j之间(nums[i+1~j-1])气球被戳破后，最大硬币数量。求dp[0][n+1]值。</span></span><br><span class="line"><span class="string">        初始状态：当 j &lt;= i+1 时，区间中没有气球，硬币值为0。</span></span><br><span class="line"><span class="string">        选择：设k为i~j之间最后被戳破的气球，那么k的选择可以是i~j之间任意一个。</span></span><br><span class="line"><span class="string">        dp数组：dp[i][j] = dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j]</span></span><br><span class="line"><span class="string">                dp[i][k]：表示i~k之间求被戳破的硬币值。</span></span><br><span class="line"><span class="string">                dp[k][j]：表示k~j之间求被戳破的硬币值。</span></span><br><span class="line"><span class="string">                nums[i]*nums[k]*nums[j]：表示k在i~j之间，最后被戳破的硬币值。</span></span><br><span class="line"><span class="string">        最终求dp[0][n+1]，所以倒着遍历/斜着遍历，这里选择倒着遍历(i从下-&gt;上，j从左-&gt;右)。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">2</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">2</span>)]</span><br><span class="line">        nums = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):      <span class="comment"># n-1 -&gt; 0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">2</span>, n+<span class="number">2</span>):   <span class="comment"># i+2 -&gt; n+1</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, j):   <span class="comment"># i+1 &lt;= k &lt;= j-1</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(</span><br><span class="line">                                    dp[i][j],</span><br><span class="line">                                    dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j]</span><br><span class="line">                               )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLw==">https://leetcode-cn.com/problems/house-robber/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvR3UwYzJULw==">剑指 Offer II 089. 房屋偷盗<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。<br>示例 1：<br>输入：<code>[1,2,3,1]</code><br>输出：<code>4</code><br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<div class="tabs" id="198"><ul class="nav-tabs"><li class="tab active"><a href="#198-1">动态规划</a></li><li class="tab"><a href="#198-2">状态压缩</a></li></ul><div class="tab-content"><div class="tab-pane active" id="198-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：从前向后偷，dp[i]表示偷到 i 间时，最多偷的钱。</span></span><br><span class="line"><span class="string">初始状态：添加空，dp数组长度为 n+1，dp[i]对应nums[i-1]。</span></span><br><span class="line"><span class="string">选择：当前计算dp[i]时，对应的是nums[i-1]间：</span></span><br><span class="line"><span class="string">     (1) 偷：dp[i] = nums[i-1] + dp[i-2]</span></span><br><span class="line"><span class="string">     (2) 不偷：dp[i] = dp[i-1]</span></span><br><span class="line"><span class="string">     取结果最大的。</span></span><br><span class="line"><span class="string">初始状态：dp[0]=0，dp[1]=nums[0]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>], dp[i<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i]表示从第 i 间房开始偷，能偷多少。求dp[0]</span></span><br><span class="line"><span class="string">初始状态：跳过最后一间房子，结束dp[n] = 0</span></span><br><span class="line"><span class="string">选择：偷/不偷</span></span><br><span class="line"><span class="string">dp数组：当前第 i 间房子开始：</span></span><br><span class="line"><span class="string">        (1) 偷：dp[i] = nums[i] + dp[i+2]</span></span><br><span class="line"><span class="string">        (2) 不偷：dp[i] = dp[i+1]</span></span><br><span class="line"><span class="string">        取结果最大的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n+<span class="number">2</span>)</span><br><span class="line">        dp[n] = <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i]+dp[i+<span class="number">2</span>], dp[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="198-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意到dp[i]只和dp[i-1]、dp[i-2]有关，用常量记录。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">         <span class="comment"># dp1记录dp[i-2]、dp2记录dp[i]和dp[i-1](dp2更新前的值)</span></span><br><span class="line">        dp1, dp2 = nums[<span class="number">0</span>], <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]+<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">            dp1, dp2 = dp2, <span class="built_in">max</span>(nums[i]+dp1, dp2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp2</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">注意到dp[i]只和dp[i+1]、dp[i+2]有关，用常量记录。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 记录dp[i+1]、dp[i+2]</span></span><br><span class="line">        dp1, dp2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dpi = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dpi = <span class="built_in">max</span>(nums[i]+dp2, dp1)</span><br><span class="line">            dp2 = dp1</span><br><span class="line">            dp1 = dpi  <span class="comment"># 当前计算的 i，为下一轮 i-1 时刻的 i+1</span></span><br><span class="line">        <span class="keyword">return</span> dpi</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a>213. 打家劫舍 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpLw==">https://leetcode-cn.com/problems/house-robber-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。<br>示例 1：<br>输入：<code>nums = [2,3,2]</code><br>输出：<code>3</code><br>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。<br><div class="tabs" id="213"><ul class="nav-tabs"><li class="tab active"><a href="#213-1">动态规划</a></li><li class="tab"><a href="#213-2">递归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="213-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        从前向后偷，dp[i]表示偷到 i 间时，最多偷的钱。</span></span><br><span class="line"><span class="string">        此时第一家与最后一家不能同时取到：</span></span><br><span class="line"><span class="string">        (1) 偷第一家的钱，不偷最后一家的钱。初始状态与状态转移不变，只是遍历的时候数组最后一位不去遍历。</span></span><br><span class="line"><span class="string">        (2) 偷最后一家的钱，不偷第一家的钱。初始状态改为dp[1]=0，第一家就不要了，然后遍历的时候，到数组最后一位。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 第一次循环</span></span><br><span class="line">        dp1 = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">0</span>]  <span class="comment"># 选择偷了第一家</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):  <span class="comment"># 最后一家不能偷</span></span><br><span class="line">            dp1[i] = <span class="built_in">max</span>(dp1[i<span class="number">-1</span>], nums[i<span class="number">-1</span>]+dp1[i<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二次循环</span></span><br><span class="line">        dp2 = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        dp2[<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># 不偷第一家</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):  <span class="comment"># 可以偷最后一家</span></span><br><span class="line">            dp2[i] = <span class="built_in">max</span>(dp2[i<span class="number">-1</span>], nums[i<span class="number">-1</span>]+dp2[i<span class="number">-2</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1[n<span class="number">-1</span>], dp2[n])  <span class="comment"># 选择最大值</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="213-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        第一间和最后一间不能同时取钱，有三种结果：</span></span><br><span class="line"><span class="string">        (1) 第一间和最后一间都不取</span></span><br><span class="line"><span class="string">        (2) 第一间到倒数第二间之间取(取第一间就不能取最后一间)，robRange(0, n-2)</span></span><br><span class="line"><span class="string">        (3) 第二间到最后一间之间取(取最后一间就不能取第一间)，robRange(1, n-1)</span></span><br><span class="line"><span class="string">        结果为这三种情况获得的最多钱，注意(2)(3)情况已经包含了第一种情况，可不写(1)。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">robRange</span>(<span class="params">start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">            dp1 = nums[start]</span><br><span class="line">            dp2 = <span class="built_in">max</span>(nums[start], nums[start+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start+<span class="number">2</span>, end+<span class="number">1</span>):</span><br><span class="line">                dp1, dp2 = dp2, <span class="built_in">max</span>(nums[i]+dp1, dp2)</span><br><span class="line">            <span class="keyword">return</span> dp2</span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]+<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="built_in">max</span>(robRange(<span class="number">0</span>, n<span class="number">-2</span>), robRange(<span class="number">1</span>, n<span class="number">-1</span>))</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a>337. 打家劫舍 III</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpaS8=">https://leetcode-cn.com/problems/house-robber-iii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为<code>root</code> 。除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警</strong>。定二叉树的 <code>root</code> 。返回 <strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额 。</p>
<p>示例 1:<br>输入: <code>root = [3,2,3,null,3,null,1]</code><br>输出: <code>7</code><br>解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7<br><div class="tabs" id="337"><ul class="nav-tabs"><li class="tab active"><a href="#337-1">动态规划</a></li><li class="tab"><a href="#337-2">递归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="337-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line">hamp = <span class="built_in">dict</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当前节点 i：</span></span><br><span class="line"><span class="string">        (1) 偷：i.left.left/right, i.right.left/right</span></span><br><span class="line"><span class="string">        (2) 不偷：i.left/right</span></span><br><span class="line"><span class="string">        注意，节点可能为空的情况。</span></span><br><span class="line"><span class="string">        定义一个hmap记录重叠部分。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">in</span> hamp: <span class="keyword">return</span> hamp[root]</span><br><span class="line">        <span class="comment"># 偷</span></span><br><span class="line">        do_it = root.val + (self.rob(root.left.left)+self.rob(root.left.right) <span class="keyword">if</span> root.left <span class="keyword">else</span> <span class="number">0</span>) \</span><br><span class="line">                         + (self.rob(root.right.left)+self.rob(root.right.right) <span class="keyword">if</span> root.right <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 不偷</span></span><br><span class="line">        not_do = self.rob(root.left) + self.rob(root.right)</span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">max</span>(do_it, not_do)  <span class="comment"># 选择收益最大的</span></span><br><span class="line">        hamp[root] = res <span class="comment"># 更新hamp</span></span><br><span class="line">        print(root.val, do_it, not_do, hamp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="337-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 当前节点选择 [不偷,偷] 得到的最大金额。</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">DFS</span>(<span class="params">node</span>):</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># 左孩子和右孩子最优情况</span></span><br><span class="line">                left = DFS(node.left)</span><br><span class="line">                right = DFS(node.right)</span><br><span class="line">                <span class="comment"># 当前节点不偷（可偷子节点）</span></span><br><span class="line">                <span class="comment"># 当前节点偷（当前节点值+子节点不偷的值(left[0]+right[0])）]</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="built_in">max</span>(left)+<span class="built_in">max</span>(right), node.val+left[<span class="number">0</span>]+right[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># 返回小偷盗取金额的最大值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(DFS(root))</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLw==">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。<br><div class="tabs" id="121"><ul class="nav-tabs"><li class="tab active"><a href="#121-1">动态规划</a></li><li class="tab"><a href="#121-2">遍历</a></li></ul><div class="tab-content"><div class="tab-pane active" id="121-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i][0]/dp[i][1] 分别表示第i天 不持股/持股 到该天为止的最大收益。</span></span><br><span class="line"><span class="string">        初始状态：第一天不持股，则总收益为0，dp[0][0]=0；</span></span><br><span class="line"><span class="string">                  第一天持股，则总收益为买股票的花费，此时为负数，dp[0][1]=−prices[0]。</span></span><br><span class="line"><span class="string">        dp数组：如果当天不持股：</span></span><br><span class="line"><span class="string">                (1) 前面的若干天中卖掉了/还没买：因此到此为止的总收益和前一天相同，dp[i-1][0]。</span></span><br><span class="line"><span class="string">                (2) 当天才卖掉：到此为止的总收益为 前一天持股+当前卖掉，dp[i−1][1]+prices[i]。</span></span><br><span class="line"><span class="string">                dp[i][0] = max(dp[i−1][0], dp[i−1][1]+prices[i])</span></span><br><span class="line"><span class="string">                如果当天持股：</span></span><br><span class="line"><span class="string">                (1) 前面若干天中买了股票当天还没卖：因此收益与前一天相同，dp[i−1][1]。</span></span><br><span class="line"><span class="string">                (2) 当天买入：此时收益为负的股价，−prices[i]。</span></span><br><span class="line"><span class="string">                dp[i][1] = max(dp[i−1][1], −prices[i])</span></span><br><span class="line"><span class="string">        最终受益肯定卖出的高，dp[n-1][0] &gt; dp[n-1][1]，所以只看dp[n-1][0]即可。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>  <span class="comment">#第一天不持股，总收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]  <span class="comment"># 第一天持股，总收益为减去该天的股价</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])  <span class="comment"># 第i天不持股收益</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i])  <span class="comment"># 第i天持股收益</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>]  <span class="comment"># 最后一天不持股，到该天为止的最大收益</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="121-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        到当前price时卖出，最大利润=pirce-之前最小price，遍历时更新minprice即可。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        minprice = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)  <span class="comment"># 记录到当前price时，前面最小price</span></span><br><span class="line">        maxprofit = <span class="number">0</span>  <span class="comment"># 记录到当前price时，最大利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price-minprice)</span><br><span class="line">            minprice = <span class="built_in">min</span>(minprice, price)</span><br><span class="line">        <span class="keyword">return</span> maxprofit</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="122-买卖股票的最佳时机Ⅱ"><a href="#122-买卖股票的最佳时机Ⅱ" class="headerlink" title="122. 买卖股票的最佳时机Ⅱ"></a>122. 买卖股票的最佳时机Ⅱ</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpLw==">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。返回 你能获得的 <strong>最大</strong> 利润 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        状态：dp[i][0]/dp[i][1] 分别表示第i天 不持股/持股 到该天为止的最大收益。</span></span><br><span class="line"><span class="string">        初始状态：第一天不持股，则总收益为0，dp[0][0]=0；</span></span><br><span class="line"><span class="string">                  第一天持股，则总收益为买股票的花费，此时为负数，dp[0][1]=−prices[0]。</span></span><br><span class="line"><span class="string">        dp数组：如果当天不持股：</span></span><br><span class="line"><span class="string">                (1) 前面的若干天中卖掉了/还没买：因此到此为止的总收益和前一天相同，dp[i-1][0]。</span></span><br><span class="line"><span class="string">                (2) 当天才卖掉：到此为止的总收益为 前一天持股+当前卖掉，dp[i−1][1]+prices[i]。</span></span><br><span class="line"><span class="string">                dp[i][0] = max(dp[i−1][0], dp[i−1][1]+prices[i])</span></span><br><span class="line"><span class="string">                如果当天持股：</span></span><br><span class="line"><span class="string">                (1) 前面若干天中买了股票当天还没卖：因此收益与前一天相同，dp[i−1][1]。</span></span><br><span class="line"><span class="string">                (2) 当天买入：前一天没持股-买入的花费，dp[i-1][0]−prices[i]。</span></span><br><span class="line"><span class="string">                dp[i][1] = max(dp[i−1][1], dp[i-1][0]−prices[i])</span></span><br><span class="line"><span class="string">        最终受益肯定卖出的高，dp[n-1][0] &gt; dp[n-1][1]，所以只看dp[n-1][0]即可。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>  <span class="comment">#第一天不持股，总收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]  <span class="comment"># 第一天持股，总收益为减去该天的股价</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])  <span class="comment"># 第i天不持股收益</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i])  <span class="comment"># 第i天持股收益</span></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>]  <span class="comment"># 最后一天不持股，到该天为止的最大收益</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 状态压缩</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp0 = <span class="number">0</span>  <span class="comment"># 第一天不持股，总收益为0</span></span><br><span class="line">        dp1 = -prices[<span class="number">0</span>]  <span class="comment"># 第一天持股，总收益为减去该天的股价</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            newdp0 = <span class="built_in">max</span>(dp0, dp1+prices[i])  <span class="comment"># 第i天不持股收益</span></span><br><span class="line">            newdp1 = <span class="built_in">max</span>(dp1, dp0-prices[i])  <span class="comment"># 第i天持股收益</span></span><br><span class="line">            dp0 = newdp0</span><br><span class="line">            dp1 = newdp1</span><br><span class="line">        <span class="keyword">return</span> dp0  <span class="comment"># 最后一天不持股，到该天为止的最大收益</span></span><br></pre></td></tr></table></figure></p>
<h2 id="123-买卖股票的最佳时机Ⅲ"><a href="#123-买卖股票的最佳时机Ⅲ" class="headerlink" title="123. 买卖股票的最佳时机Ⅲ"></a>123. 买卖股票的最佳时机Ⅲ</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpaS8=">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        最多可以完成两笔交易，在当天结束可能出现状态：</span></span><br><span class="line"><span class="string">        (1) dp[i][0]：一次没有买过；</span></span><br><span class="line"><span class="string">        (2) dp[i][1]：只进行过一次买操作；</span></span><br><span class="line"><span class="string">        (3) dp[i][2]：进行了一次买操作和一次卖操作，即完成了一笔交易；</span></span><br><span class="line"><span class="string">        (4) dp[i][3]：在完成了一笔交易的前提下，进行了第二次买操作；</span></span><br><span class="line"><span class="string">        (5) dp[i][4]：进行了二次买操作和二次卖操作，完成了全部两笔交易。</span></span><br><span class="line"><span class="string">        初始状态：初始没买，则总收益为0，dp[0][0]=0；</span></span><br><span class="line"><span class="string">                 初始买了，则总收益为买股票的花费，此时为负数，dp[0][1]=−prices[0]。</span></span><br><span class="line"><span class="string">         dp数组：</span></span><br><span class="line"><span class="string">                一次没有买过：dp[i][0] = dp[i−1][0]，其实这个收益始终为0。</span></span><br><span class="line"><span class="string">                第一次买：</span></span><br><span class="line"><span class="string">                (1) 前面若干天中买了股票当天还没卖：因此收益与前一天相同，dp[i−1][1]。</span></span><br><span class="line"><span class="string">                (2) 当天买入：前一天没持股-买入的花费，dp[i-1][0]−prices[i]。</span></span><br><span class="line"><span class="string">                dp[i][1] = max(dp[i−1][1], dp[i-1][0]−prices[i]) </span></span><br><span class="line"><span class="string">                一次买和卖：</span></span><br><span class="line"><span class="string">                (1) 之前就卖出只是还没买入第二次：dp[i−1][2]。</span></span><br><span class="line"><span class="string">                (2) 第一次买后，当天卖出第一次：dp[i−1][1]+prices[i]。</span></span><br><span class="line"><span class="string">                dp[i][2] = max(dp[i−1][2], dp[i−1][1]+prices[i])</span></span><br><span class="line"><span class="string">                完成了一笔交易，第二次买：</span></span><br><span class="line"><span class="string">                (1) 早在之前就买入了第二次，只是还没卖出：dp[i−1][3]。</span></span><br><span class="line"><span class="string">                (2) 一次买和卖后，当天买入了第二次：dp[i−1][2]−prices[i]。</span></span><br><span class="line"><span class="string">                dp[i][3] = max(dp[i−1][3], dp[i−1][2]−prices[i])</span></span><br><span class="line"><span class="string">                完成了全部两笔交易：</span></span><br><span class="line"><span class="string">                (1) 早在之前就卖出了第二次：dp[i−1][4]。</span></span><br><span class="line"><span class="string">                (2) 完成了一笔交易，第二次买后，当天再卖出第二次：dp[i−1][3]+prices[i]。</span></span><br><span class="line"><span class="string">                dp[i][4] = max(dp[i−1][4], dp[i−1][3]+prices[i])</span></span><br><span class="line"><span class="string">        最终受益看 第一、二次卖出收益 和 0收益 谁高，因为有可能没有收益。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices) </span><br><span class="line">        dp = [[<span class="number">-10000</span>]*<span class="number">5</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 一次没有买过</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]  <span class="comment"># 第一次买</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]  <span class="comment"># dp[i][0]收益全是0，可不看</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i])</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i])</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">4</span>], dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">2</span>], <span class="number">0</span>, dp[n<span class="number">-1</span>][<span class="number">4</span>])  <span class="comment"># 选取最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 状态压缩</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        buy1 = buy2 = -prices[<span class="number">0</span>] </span><br><span class="line">        sell1 = sell2 = <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># dp[i][0]全是0，可压缩掉</span></span><br><span class="line">            buy1 = <span class="built_in">max</span>(buy1, -prices[i])        <span class="comment"># dp[i][1]</span></span><br><span class="line">            sell1 = <span class="built_in">max</span>(sell1, buy1+prices[i])  <span class="comment"># dp[i][2]</span></span><br><span class="line">            buy2 = <span class="built_in">max</span>(buy2, sell1-prices[i])   <span class="comment"># dp[i][3]</span></span><br><span class="line">            sell2 = <span class="built_in">max</span>(sell2, buy2+prices[i])  <span class="comment"># dp[i][4]</span></span><br><span class="line">        <span class="keyword">return</span> sell2</span><br></pre></td></tr></table></figure></p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><strong>题目描述</strong>：给你一个可装载重量为 <code>W</code> 的背包和 <code>N</code> 个物品，每个物品有重量和价值两个属性。其中第 <code>i</code> 个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack</span>(<span class="params">W: <span class="built_in">int</span>, N: <span class="built_in">int</span>, wt: List[<span class="built_in">int</span>], val: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">提示：背包问题的典型套路是，状态的定义！</span></span><br><span class="line"><span class="string">状态：dp[i][w]表示前 i 个物品，背包载重为 w，最多装的价值。求dp[N][W]值。</span></span><br><span class="line"><span class="string">初始状态：dp[0][..] = 0、dp[..][0] = 0</span></span><br><span class="line"><span class="string">选择：当前物品，能装/不能装。</span></span><br><span class="line"><span class="string">dp数组：当前物品 i：</span></span><br><span class="line"><span class="string">       (1) 能装进背包：装/不装 择优，dp[i][w] = max(dp[i-1][w-wt[i-1]] + val[i-1], dp[i-1][w])</span></span><br><span class="line"><span class="string">       (2) 不能装进背包：dp[i][w] = dp[i-1][w]</span></span><br><span class="line"><span class="string">       i从1开始，对应wt和val是从0开始。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(W+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):  <span class="comment"># 物品</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W+<span class="number">1</span>):  <span class="comment"># 载重</span></span><br><span class="line">            <span class="keyword">if</span> w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>:  <span class="comment"># 不能装，只有不装这一种结果</span></span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w]</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 能装，装/不装 择优</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][w-wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>], dp[i<span class="number">-1</span>][w])</span><br><span class="line">    <span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure></p>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWVxdWFsLXN1YnNldC1zdW0v">https://leetcode-cn.com/problems/partition-equal-subset-sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。<br>示例 1：<br>输入：<code>nums = [1,5,11,5]</code><br>输出：<code>true</code><br>解释：数组可以分割成 <code>[1, 5, 5]</code> 和 <code>[11]</code> 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">转化为背包问题：既然要分2个和相等的子集，那么一个子集的和就是nums的和sum除以2，问题转化为：</span></span><br><span class="line"><span class="string">“载重为sum/2的背包，N个物品，每个物品重量为nums[i]，问是否存在一种装法，能恰好将背包装满？”</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示前 i 个物品，载重为 j 时，能不能将背包装满(True/False)。求dp[len(nums)][sum/2]的值。</span></span><br><span class="line"><span class="string">初始状态：dp[0][..] = False、dp[..][0] = True</span></span><br><span class="line"><span class="string">选择：当前物品，能装/不能装。</span></span><br><span class="line"><span class="string">dp数组：当前物品 i：</span></span><br><span class="line"><span class="string">       (1) 能装进背包：装/不装 择优，dp[i][j] = dp[i-1][j-nums[i-1]] or dp[i-1][j]</span></span><br><span class="line"><span class="string">       (2) 不能装进背包：dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="string">       i从1开始，对应nums是从0开始。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        total = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span>: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 和为奇数时不能分</span></span><br><span class="line">            </span><br><span class="line">        target = total // <span class="number">2</span></span><br><span class="line">        maxNum = <span class="built_in">max</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> maxNum &gt; target: <span class="keyword">return</span> <span class="literal">False</span>  <span class="comment"># 最大值大于目标值，不可能分成2个目标值</span></span><br><span class="line">            </span><br><span class="line">        dp = [[<span class="literal">False</span>] * (target+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># target为0，相当于装满了</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j-nums[i<span class="number">-1</span>] &lt; <span class="number">0</span>:  <span class="comment"># 不能装</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]] <span class="keyword">or</span> dp[i<span class="number">-1</span>][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][target]</span><br></pre></td></tr></table></figure></p>
<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2UtMi8=">https://leetcode-cn.com/problems/coin-change-2/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。请你计算并返回可以<strong>凑成总金额的硬币组合数</strong>。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。</p>
<p>示例 1：<br>输入：<code>amount = 5, coins = [1, 2, 5]</code><br>输出：<code>4</code><br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p>
<div class="tabs" id="518"><ul class="nav-tabs"><li class="tab active"><a href="#518-1">动态规划</a></li><li class="tab"><a href="#518-2">状态压缩</a></li></ul><div class="tab-content"><div class="tab-pane active" id="518-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">转化为背包问题：“载重为amount的背包，N个物品(coins个数)，每个物品重量为coins[i]，每个物品的数量无限，</span></span><br><span class="line"><span class="string">                 问是存在几种装法，能恰好将背包装满？”</span></span><br><span class="line"><span class="string">                 因为物品的数量无限，所以又叫完全背包问题。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">增加空状态，dp[i]对应coins[i-1]。</span></span><br><span class="line"><span class="string">状态：dp[i][j]表示只用前 i 个物品(包括i)，载重为 j 时，能恰好成功的装法有多少。求dp[N][amount]值。</span></span><br><span class="line"><span class="string">初始状态：空物品为0种装法(dp[0][..]=0)，空包为1种装法(dp[..][0]=1)</span></span><br><span class="line"><span class="string">选择：能装/不能装</span></span><br><span class="line"><span class="string">dp数组：当前第 i 个物品：</span></span><br><span class="line"><span class="string">        (1) 装进：那么取前 i 个物品，凑出j-coins[i-1]。dp[i][j] = dp[i][j-coins[i-1]]</span></span><br><span class="line"><span class="string">        (2) 不装进：那么取前 i-1 个物品，凑出j。dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="string">        要求的是总共有多少装法，最终的dp[i][j]是上面两种选择结果的和。dp[i][j] = dp[i][j-coins[i-1]] + dp[i-1][j]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="number">0</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]  <span class="comment"># 空物品为0种装法</span></span><br><span class="line">        <span class="comment"># 初始状态,空包为1种装法</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):  <span class="comment"># 前i个物品</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):  <span class="comment"># 载重j</span></span><br><span class="line">                <span class="keyword">if</span> j-coins[i<span class="number">-1</span>]&gt;=<span class="number">0</span>:  <span class="comment"># 能装</span></span><br><span class="line">                    dp[i][j] = dp[i][j-coins[i<span class="number">-1</span>]] + dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:  <span class="comment"># 不能装</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[n][amount]</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="518-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">状态压缩：注意到 i 只与当前i行和i-1行有关，可压缩维度i，dp只记录j。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [<span class="number">0</span>]*(amount+<span class="number">1</span>)   <span class="comment"># 空物品为0种装法</span></span><br><span class="line">        <span class="comment"># 初始状态,空包为1种装法</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):  <span class="comment"># 前i个物品</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):  <span class="comment"># 载重j</span></span><br><span class="line">                <span class="keyword">if</span> j-coins[i<span class="number">-1</span>]&gt;=<span class="number">0</span>:  <span class="comment"># 能装</span></span><br><span class="line">                    dp[j] = dp[j-coins[i<span class="number">-1</span>]] + dp[j]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure></div></div></div>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>贪心算法是一种特殊的动态规划，拥有一些特殊性质，可以<strong>进一步降低动态规划的时间复杂度</strong>。</p>
<h2 id="056-合并区间"><a href="#056-合并区间" class="headerlink" title="056. 合并区间"></a>056. 合并区间</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1pbnRlcnZhbHMv">https://leetcode.cn/problems/merge-intervals/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 先按照区间首位排序</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="comment"># 如果列表为空，或者当前区间与上一区间不重合，直接添加</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">                res.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则就可以与上一区间进行合并</span></span><br><span class="line">                res[<span class="number">-1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(res[<span class="number">-1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21lLw==">https://leetcode-cn.com/problems/longest-palindrome/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个包含大写字母和小写字母的字符串 <code>s</code> ，返回 通过这些字母构造成的 <strong>最长的回文串</strong> 。在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。<br>示例 1:<br>输入:<code>s = &quot;abccccdd&quot;</code><br>输出:<code>7</code><br>解释: 我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">回文串长度为奇数，除中心字符外，两侧字符串相同；长度为偶数，两侧字符串相同。</span></span><br><span class="line"><span class="string">奇数时，只有中间字符为1次，其余字符为偶数次；偶数时，所有字符为偶数次。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">构建时，每个字符使用偶数次，若剩余字符，选一个放中间。</span></span><br><span class="line"><span class="string">每个字符可放 count(ch) // 2 * 2 次，遇到第一个奇数ch，放入ans作为中间字符(ans变为奇数)，之后奇数字符不再放入。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        count = collections.Counter(s)</span><br><span class="line">        <span class="keyword">for</span> cnt <span class="keyword">in</span> count.values():</span><br><span class="line">            ans += cnt // <span class="number">2</span> * <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> ans % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> cnt % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<h2 id="055-跳跃游戏"><a href="#055-跳跃游戏" class="headerlink" title="055. 跳跃游戏"></a>055. 跳跃游戏</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLw==">https://leetcode-cn.com/problems/jump-game/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个非负整数数组 nums ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。<br>示例 1：<br>输入：<code>nums = [2,3,1,1,4]</code><br>输出：<code>true</code><br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        rightmost：当前 i 位置，最远能跳到的位置max(rightmost, i+nums[i])。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n, rightmost = <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            rightmost = <span class="built_in">max</span>(rightmost, i+nums[i])</span><br><span class="line">            <span class="comment"># 最远到 i 位置，会卡住跳不动了</span></span><br><span class="line">            <span class="keyword">if</span> rightmost &lt;= i: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> rightmost &gt;= n<span class="number">-1</span>  <span class="comment"># 能跳到边界</span></span><br></pre></td></tr></table></figure></p>
<h2 id="045-跳跃游戏-II"><a href="#045-跳跃游戏-II" class="headerlink" title="045. 跳跃游戏 II"></a>045. 跳跃游戏 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLWlpLw==">https://leetcode-cn.com/problems/jump-game-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。<br>示例 1:<br>输入: <code>nums = [2,3,1,1,4]</code><br>输出: <code>2</code><br>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        maxPos：从索引 i~end 起跳，最远能到的距离。</span></span><br><span class="line"><span class="string">        end：在索引 i，最多能跳到索引 end。</span></span><br><span class="line"><span class="string">        step：记录跳跃次数。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        maxPos, end, step = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n<span class="number">-1</span>):  <span class="comment"># 可不访问最后一个元素</span></span><br><span class="line">            maxPos = <span class="built_in">max</span>(maxPos, i+nums[i])</span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                end = maxPos</span><br><span class="line">                step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure></p>
<h2 id="主持人调度Ⅱ"><a href="#主持人调度Ⅱ" class="headerlink" title="主持人调度Ⅱ"></a>主持人调度Ⅱ</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzRlZGY2ZTZkMDE1NTQ4NzBhMTJmMjE4Yzk0ZThhMjk5">BM96 主持人调度（二）<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：有 <code>n</code> 个活动即将举办，每个活动都有开始时间与活动的结束时间，第 <code>i</code> 个活动的开始时间是 <code>starti</code> ,第 <code>i</code> 个活动的结束时间是 <code>endi</code> ,举办某个活动就需要为该活动准备一个活动主持人。一位活动主持人在同一时间只能参与一个活动。并且活动主持人需要全程参与活动，换句话说，一个主持人参与了第 <code>i</code> 个活动，那么该主持人在 <code>(starti,endi)</code> 这个时间段不能参与其他任何活动。求为了成功举办这 <code>n</code> 个活动，最少需要多少名主持人。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minmumNumberOfHost</span>(<span class="params">self , n: <span class="built_in">int</span>, startEnd: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        利用辅助数组获取单独各个活动开始的时间和结束时间，然后分别开始时间和结束时间进行排序，方便后面判断是否相交。</span></span><br><span class="line"><span class="string">        遍历n个活动，如果某个活动开始的时间大于之前活动结束的时候，当前主持人就够了，活动结束时间往后一个。</span></span><br><span class="line"><span class="string">        若是出现之前活动结束时间晚于当前活动开始时间的，则需要增加主持人。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        start = <span class="built_in">sorted</span>(startEnd, key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        end = <span class="built_in">sorted</span>(startEnd, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span>  <span class="comment"># 上一轮结束的活动</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 当前活动开始时间&gt;=上一轮结束的时间，主持人不变</span></span><br><span class="line">            <span class="keyword">if</span> start[i][<span class="number">0</span>] &gt;= end[j][<span class="number">1</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 上一轮结束的时间&gt;当前活动开始时间，则需要增加主持人</span></span><br><span class="line">                res += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="分糖果问题"><a href="#分糖果问题" class="headerlink" title="分糖果问题"></a>分糖果问题</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzc2MDM5MTA5ZGQwYjQ3ZTk5NGMwOGQ4MzE5ZmFhMzUy">BM95 分糖果问题<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：一群孩子做游戏，现在请你根据游戏得分来发糖果，要求如下：1. 每个孩子不管得分多少，起码分到一个糖果。2. 任意两个相邻的孩子之间，得分较多的孩子必须拿多一些糖果。(若相同则无此限制)。给定一个数组 arrarr 代表得分数组，请返回最少需要多少糖果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">self , arr: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        要想分出最少的糖果，利用贪心思想：</span></span><br><span class="line"><span class="string">        (1) 相邻位置没有增加的情况下，大家都分到1，</span></span><br><span class="line"><span class="string">        (2) 相邻位置有增加的情况下，分到糖果数加1就好。</span></span><br><span class="line"><span class="string">        什么情况下会增加糖果，相邻位置有得分差异，可能是递增可能是递减，</span></span><br><span class="line"><span class="string">        如果是递增的话，糖果依次加1，如果是递减糖果依次减1？这不符合最小，因为减到最后一个递减的位置可能不是1，</span></span><br><span class="line"><span class="string">        必须从1开始加才是最小，那我们可以从最后一个递减的位置往前反向加1。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 记录每个位置的糖果数，初始为1</span></span><br><span class="line">        nums = [<span class="number">1</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="comment"># 从左到右遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="comment"># 如果右边在递增，每次增加一个</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i<span class="number">-1</span>]:</span><br><span class="line">                nums[i] = nums[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="comment">#从右到左遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 如果左边更大但是糖果数更小</span></span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[i+<span class="number">1</span>] <span class="keyword">and</span> nums[i] &lt;= nums[i+<span class="number">1</span>]:</span><br><span class="line">                nums[i] = nums[i+<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure></p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaGFub3RhLWxjY2kv">面试题 08.06. 汉诺塔问题<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。<br>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。<br>你需要原地修改栈。<br>示例1:<br>输入：<code>A = [2, 1, 0], B = [], C = []</code><br>输出：<code>C = [2, 1, 0]</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaGFub3RhLWxjY2kvc29sdXRpb24vdHUtamllLXlpLW51by10YS1kZS1ndS1zaGktanUtc2h1by1kYW5nLTY0Z2UtcGFuLXov">Pumpkin题解<i class="fa fa-external-link-alt"></i></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hanota</span>(<span class="params">self, A: List[<span class="built_in">int</span>], B: List[<span class="built_in">int</span>], C: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        定义一个move函数，把n个盘子分两部分：最底层的1个盘子 + 其余n-1个盘子。</span></span><br><span class="line"><span class="string">        (1) 把n-1个盘子从A移动到B(借助C)</span></span><br><span class="line"><span class="string">        (2) 把最底层的1个盘子(A.pop())移动到C</span></span><br><span class="line"><span class="string">        (3) 把n-1个盘子从B移动到C(借助A)</span></span><br><span class="line"><span class="string">        不断重复上述操作，直到盘子n为1。</span></span><br><span class="line"><span class="string">        n：盘子数</span></span><br><span class="line"><span class="string">        A：起始</span></span><br><span class="line"><span class="string">        B：中间过渡</span></span><br><span class="line"><span class="string">        C：结束</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">n, A, B, C</span>):</span></span><br><span class="line">            <span class="comment"># 只有一个直接移动到C</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                C.append(A.pop())</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 先把A上面n-1个盘子从A移到B(通过C)</span></span><br><span class="line">                move(n<span class="number">-1</span>, A, C, B)  </span><br><span class="line">                <span class="comment"># 将A最后一个移到C</span></span><br><span class="line">                C.append(A.pop())         </span><br><span class="line">                <span class="comment"># 再将B上面n-1个盘子从B移到C(通过A)          </span></span><br><span class="line">                move(n<span class="number">-1</span>,B, A, C) </span><br><span class="line">              </span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        move(n, A, B, C)</span><br></pre></td></tr></table></figure></p>
<h2 id="969-煎饼排序"><a href="#969-煎饼排序" class="headerlink" title="969. 煎饼排序"></a>969. 煎饼排序</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFuY2FrZS1zb3J0aW5nLw==">https://leetcode-cn.com/problems/pancake-sorting/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 <code>s</code> ，请使用 煎饼翻转 完成对数组的排序。一次煎饼翻转：<code>arr = [3,2,1,4]</code> ，选择 <code>k = 3</code> 进行一次煎饼翻转，反转子数组 <code>[3,2,1]</code> ，得到 <code>arr = [1,2,3,4]</code> 。以数组形式返回能使 <code>arr</code> 有序的煎饼翻转操作所对应的 <code>k</code> 值序列。<br>示例 1：<br>输入：<code>[3,2,4,1]</code><br>输出：<code>[4,2,4,3]</code><br>解释：我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。<br>初始状态 arr = [3, 2, 4, 1]<br>第一次翻转后（k = 4）：arr = [1, 4, 2, 3]<br>第二次翻转后（k = 2）：arr = [4, 1, 2, 3]<br>第三次翻转后（k = 4）：arr = [3, 2, 1, 4]<br>第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。 </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFuY2FrZS1zb3J0aW5nL3NvbHV0aW9uLzk2OS1qaWFuLWJpbmctcGFpLXh1LWRpLWd1aS1oZS1kaWUtZGFpLWItdmR2NS8=">倔强渣渣 题解<i class="fa fa-external-link-alt"></i></span>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pancakeSort</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        和汉诺塔类似，首先找到最大值i，把i翻转到最底层，这样规模缩减为n-1层，递归即可。</span></span><br><span class="line"><span class="string">        (1) 找到烧饼中最大的那个。</span></span><br><span class="line"><span class="string">        (2) 把这个最大的移到最底下。</span></span><br><span class="line"><span class="string">        (3) 递归调用函数pancakeSort(cakes[:-1])，当n==1时，排序1个烧饼不需要翻转。</span></span><br><span class="line"><span class="string">        需要注意，数组索引从0开始，返回的k是从1开始。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sortcakes</span>(<span class="params">cakes</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cakes)==<span class="number">1</span>: <span class="keyword">return</span></span><br><span class="line">            idx = cakes.index(<span class="built_in">max</span>(cakes))</span><br><span class="line">            k = idx + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第一次翻转，把最大的煎饼翻到最上面</span></span><br><span class="line">            cakes = cakes[:k][::<span class="number">-1</span>] + cakes[k:]</span><br><span class="line">            <span class="comment"># 第二次翻转，将最大的煎饼翻到最下面</span></span><br><span class="line">            cakes = cakes[::<span class="number">-1</span>]</span><br><span class="line">            res.extend([k, <span class="built_in">len</span>(cakes)])  <span class="comment"># 每次需要两次翻转(k和len(cakes))</span></span><br><span class="line">            sortcakes(cakes[:<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        sortcakes(arr)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="回溯-DFS"><a href="#回溯-DFS" class="headerlink" title="回溯/DFS"></a>回溯/DFS</h1><p><strong>回溯</strong>：也是解决穷举问题，相比动态规划更简单直接。回溯本质是一个决策树的遍历过程：<br>（1）路径：已经做出的选择。<br>（2）选择列表：你当前可以做的选择。<br>（3）结束条件：到达决策底层，无法再做选择的条件。<br><strong>深度优先搜索(DFS)</strong>：一般用于树或者图的遍历，其他有分支的（如二维矩阵）也适用。它的原理是从初始点开始，一直沿着同一个分支遍历，直到该分支结束，然后回溯到上一级继续沿着一个分支走到底，如此往复，直到所有的节点都有被访问到。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">res = []  <span class="comment"># 存储所有路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        res.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        将 选择 从 选择列表 中移除</span><br><span class="line">        路径.append(选择)</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        路径.remove(选择)</span><br><span class="line">        将 选择 恢复到 选择列表 </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 也可也加判断，过滤掉不合法选择</span></span><br><span class="line">    <span class="comment"># 这样就省去了“将 选择 从 选择列表 中移除/恢复”操作</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        <span class="keyword">if</span> 选择 <span class="keyword">in</span> 路径: <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        路径.append(选择)</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        路径.remove(选择)</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">无重复元素：直接判断元素是否出现在路径(全排列)，下标控制每次路径选择起点(子集)。</span><br><span class="line">有重复元素：排序后去掉没按顺序生成的路径(全排列&#x2F;子集)，全排列需要visited保证每个元素只用一次。</span><br><span class="line">下标控制选择起点，避免使用前面元素造成重复(如[1,2,3],[3,2,1])。</span><br><span class="line">有重复元素一定要按顺序生成路径。</span><br></pre></td></tr></table></figure></p>
<h2 id="046-全排列"><a href="#046-全排列" class="headerlink" title="046. 全排列"></a>046. 全排列</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLw==">https://leetcode-cn.com/problems/permutations/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbi1pLWxjY2kv">面试题 08.07. 无重复字符串的排列组合<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<br>（1）给定一个<strong>不含重复数字</strong>的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。<br>（2）无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。<br>示例 1：<br>输入：<code>nums = [1,2,3]</code><br>输出：<code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></p>
<p>示例1:<br>输入：<code>S = &quot;qwe&quot;</code><br>输出：<code>[&quot;qwe&quot;, &quot;qew&quot;, &quot;wqe&quot;, &quot;weq&quot;, &quot;ewq&quot;, &quot;eqw&quot;]</code><br><div class="tabs" id="46"><ul class="nav-tabs"><li class="tab active"><a href="#46-1">全排列</a></li><li class="tab"><a href="#46-2">字符串的排列</a></li></ul><div class="tab-content"><div class="tab-pane active" id="46-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        路径：记录在track中</span></span><br><span class="line"><span class="string">        选择列表：nums中不存在于track的元素</span></span><br><span class="line"><span class="string">        结束条件：nums中所有元素全在track中出现</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track)==n:  <span class="comment"># 结束条件</span></span><br><span class="line">                res.append(track[:]) <span class="comment"># 必须使用切片，不然存入的只是指针</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 排除不合法选择</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> track: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                <span class="comment"># 进入下一层决策树</span></span><br><span class="line">                backtrack(track)</span><br><span class="line">                <span class="comment"># 取消选择</span></span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res, track, n = [], [], <span class="built_in">len</span>(nums)</span><br><span class="line">        backtrack(track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="46-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track)==n:  <span class="comment"># 结束条件</span></span><br><span class="line">                res.append(<span class="string">&#x27;&#x27;</span>.join(track[:])) <span class="comment"># 必须使用切片，不然存入的只是指针</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 排除不合法选择</span></span><br><span class="line">                <span class="keyword">if</span> s[i] <span class="keyword">in</span> track: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                track.append(s[i])</span><br><span class="line">                <span class="comment"># 进入下一层决策树</span></span><br><span class="line">                backtrack(track)</span><br><span class="line">                <span class="comment"># 取消选择</span></span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res, track, n = [], [], <span class="built_in">len</span>(S)</span><br><span class="line">        s = <span class="built_in">sorted</span>(<span class="built_in">list</span>(S))</span><br><span class="line">        backtrack(track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="047-全排列-II"><a href="#047-全排列-II" class="headerlink" title="047. 全排列 II"></a>047. 全排列 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLWlpLw==">https://leetcode-cn.com/problems/permutations-ii/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wZXJtdXRhdGlvbi1paS1sY2NpLw==">面试题 08.08. 有重复字符串的排列组合<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：<br>（1）给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有<strong>不重复</strong>的全排列。<br>（2）有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。<br>示例 1：<br>输入：<code>nums = [1,1,2]</code><br>输出：<code>[[1,1,2],[1,2,1],[2,1,1]]</code></p>
<p>示例1:<br>输入：<code>S = &quot;qqe&quot;</code><br>输出：<code>[&quot;eqq&quot;,&quot;qeq&quot;,&quot;qqe&quot;]</code><br><div class="tabs" id="47"><ul class="nav-tabs"><li class="tab active"><a href="#47-1">全排列</a></li><li class="tab"><a href="#47-2">字符串的排列</a></li></ul><div class="tab-content"><div class="tab-pane active" id="47-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为保证不重复：</span></span><br><span class="line"><span class="string">        (1) 排序，使重复值相邻</span></span><br><span class="line"><span class="string">        (2) 定义visited，标记对应位置nums[i]是否使用</span></span><br><span class="line"><span class="string">        (3) 一定要按顺序生成，比如[1,2,2]:</span></span><br><span class="line"><span class="string">            应该从 [填入,未填入,未填入]-&gt;[填入,填入,未填入]-&gt;[填入,填入,填入]</span></span><br><span class="line"><span class="string">            避免从 [填入,未填入,未填入]-&gt;[填入,未填入,填入]-&gt;[填入,填入,填入]</span></span><br><span class="line"><span class="string">            也就是，nums[i]和nums[i-1]相同，且nums[i-1]未被使用过，应该剪掉这个(因为会和nums[i-1]使用的重复)。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">track, visited</span>):</span></span><br><span class="line">            <span class="keyword">if</span> n==<span class="built_in">len</span>(track):</span><br><span class="line">                res.append(track[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 不能使用重复位置的值</span></span><br><span class="line">                <span class="keyword">if</span> visited[i] == <span class="number">1</span>: <span class="keyword">continue</span>  </span><br><span class="line">                <span class="comment"># 排序后按顺序生成，剪掉没按顺序生成的重复路径</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> visited[i<span class="number">-1</span>]==<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                visited[i] = <span class="number">1</span></span><br><span class="line">                backtrack(track, visited)</span><br><span class="line">                track.pop()</span><br><span class="line">                visited[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res, track, n = [], [], <span class="built_in">len</span>(nums)</span><br><span class="line">        visited = [<span class="number">0</span>] * n  <span class="comment"># 标记nums[i]使用/未使用</span></span><br><span class="line">        nums.sort()  <span class="comment"># 需要排序</span></span><br><span class="line">        </span><br><span class="line">        backtrack(track, visited)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="47-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permutation</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">track, visited</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track) == n:</span><br><span class="line">                res.append(<span class="string">&#x27;&#x27;</span>.join(track[:]))</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> visited[i]==<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> visited[i<span class="number">-1</span>]==<span class="number">0</span> <span class="keyword">and</span> s[i]==s[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                track.append(s[i])</span><br><span class="line">                visited[i] = <span class="number">1</span></span><br><span class="line">                backtrack(track, visited)</span><br><span class="line">                track.pop()</span><br><span class="line">                visited[i] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        res, track, n = [], [], <span class="built_in">len</span>(S)</span><br><span class="line">        visited = [<span class="number">0</span>] * n  <span class="comment"># 有重复元素时使用，保证每个元素只用一次</span></span><br><span class="line">        s = <span class="built_in">sorted</span>(<span class="built_in">list</span>(S))  <span class="comment"># 一定要排序</span></span><br><span class="line">        backtrack(track, visited)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="078-子集"><a href="#078-子集" class="headerlink" title="078. 子集"></a>078. 子集</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3Vic2V0cy8=">https://leetcode-cn.com/problems/subsets/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。<br>示例 1：<br>输入：<code>nums = [1,2,3]</code><br>输出：<code>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</code><br><div class="tabs" id="78"><ul class="nav-tabs"><li class="tab active"><a href="#78-1">回溯</a></li><li class="tab"><a href="#78-2">迭代</a></li></ul><div class="tab-content"><div class="tab-pane active" id="78-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, track</span>):</span></span><br><span class="line">            res.append(track[:])  <span class="comment"># 存储当前路径</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res, track = [], []</span><br><span class="line">        backtrack(<span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="78-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        res = [[]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            res = res + [[i] + num <span class="keyword">for</span> num <span class="keyword">in</span> res]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="090-子集-II"><a href="#090-子集-II" class="headerlink" title="090. 子集 II"></a>090. 子集 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3Vic2V0cy1paS8=">https://leetcode-cn.com/problems/subsets-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。<br>示例 1：<br>输入：<code>nums = [1,2,2]</code><br>输出：<code>[[],[1],[1,2],[1,2,2],[2],[2,2]]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, track</span>):</span>  </span><br><span class="line">            res.append(track[:])  <span class="comment"># 存储当前路径</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 排序后按顺序生成，剪掉没按顺序生成的重复路径</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;start <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]: <span class="keyword">continue</span>  </span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res, track = [], []</span><br><span class="line">        nums.sort() <span class="comment"># 必须排序好</span></span><br><span class="line">        backtrack(<span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="077-组合"><a href="#077-组合" class="headerlink" title="077. 组合"></a>077. 组合</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb25zLw==">https://leetcode-cn.com/problems/combinations/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。你可以按 任何顺序 返回答案。<br>示例 1：<br>输入：<code>n = 4, k = 2</code><br>输出：<code>[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track)==k:  <span class="comment"># 注意满足k才存储</span></span><br><span class="line">                res.append(track[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(nums)):</span><br><span class="line">                track.append(nums[i])</span><br><span class="line">                backtrack(i+<span class="number">1</span>, track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res, track = [], []</span><br><span class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        backtrack(<span class="number">0</span>, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="039-组合总和"><a href="#039-组合总和" class="headerlink" title="039. 组合总和"></a>039. 组合总和</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3VtLw==">https://leetcode-cn.com/problems/combination-sum/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 任意顺序 返回这些组合。<code>candidates</code> 中的 同一个 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。<br>示例 1：<br>输入：<code>candidates = [2,3,6,7], target = 7</code><br>输出：<code>[[2,2,3],[7]]</code><br>解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, target, track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:   <span class="comment"># target减为0结束</span></span><br><span class="line">                res.append(track[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                <span class="comment"># 去掉非法选择</span></span><br><span class="line">                <span class="keyword">if</span> candidates[i] &gt; target: <span class="keyword">break</span>  </span><br><span class="line">                track.append(candidates[i])</span><br><span class="line">                <span class="comment"># 可重复选取，candidates从 i 开始</span></span><br><span class="line">                backtrack(i, target-candidates[i], track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res, track, n = [], [], <span class="built_in">len</span>(candidates)</span><br><span class="line">        candidates.sort()  <span class="comment"># 排序</span></span><br><span class="line">        backtrack(<span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="040-组合总和-II"><a href="#040-组合总和-II" class="headerlink" title="040. 组合总和 II"></a>040. 组合总和 II</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3VtLWlpLw==">https://leetcode-cn.com/problems/combination-sum-ii/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。注意：解集不能包含重复的组合。<br>示例 1:<br>输入: <code>candidates = [10,1,2,7,6,1,5], target = 8</code><br>输出: <code>[[1,1,6],[1,2,5],[1,7],[2,6]]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span>(<span class="params">self, candidates: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, target, track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:   <span class="comment"># target减为0结束</span></span><br><span class="line">                res.append(track[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n):</span><br><span class="line">                <span class="comment"># 去掉非法选择</span></span><br><span class="line">                <span class="keyword">if</span> candidates[i] &gt; target: <span class="keyword">break</span>  </span><br><span class="line">                <span class="comment"># 排序后按顺序生成，剪掉没按顺序生成的重复路径</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;start <span class="keyword">and</span> candidates[i]==candidates[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                track.append(candidates[i])</span><br><span class="line">                <span class="comment"># 不能重复使用同一个，candidates从 i+1 开始</span></span><br><span class="line">                backtrack(i+<span class="number">1</span>, target-candidates[i], track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res, track, n = [], [], <span class="built_in">len</span>(candidates)</span><br><span class="line">        candidates.sort()  <span class="comment"># 排序</span></span><br><span class="line">        backtrack(<span class="number">0</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="022-括号生成"><a href="#022-括号生成" class="headerlink" title="022. 括号生成"></a>022. 括号生成</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ2VuZXJhdGUtcGFyZW50aGVzZXMv">https://leetcode-cn.com/problems/generate-parentheses/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。<br>示例 1：<br>输入：<code>n = 3</code><br>输出：<code>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        考虑 2n 个括号(n个左,n个右)，合法的有多少？</span></span><br><span class="line"><span class="string">        合法就是保证：</span></span><br><span class="line"><span class="string">        (1) 左括号数量&lt;=n。</span></span><br><span class="line"><span class="string">        (2) 右括号数量&lt;=左括号数量。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">left, right, track</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(track)==<span class="number">2</span>*n:  <span class="comment"># 恰好用完，存储+结束</span></span><br><span class="line">                res.append(<span class="string">&#x27;&#x27;</span>.join(track))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; n:  <span class="comment"># 尝试添加一个左括号</span></span><br><span class="line">                track.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                backtrack(left+<span class="number">1</span>, right, track)</span><br><span class="line">                track.pop()</span><br><span class="line">            <span class="keyword">if</span> right &lt; left:  <span class="comment"># 尝试添加一个右括号</span></span><br><span class="line">                track.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                backtrack(left, right+<span class="number">1</span>, track)</span><br><span class="line">                track.pop()</span><br><span class="line"></span><br><span class="line">        res, track = [], []</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 左括号数量，右括号数量</span></span><br><span class="line">        backtrack(left, right, track)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtaXNsYW5kcy8=">https://leetcode.cn/problems/number-of-islands/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    找到一个1后，算作1个岛屿，因为左右相邻的1都算作同一个岛屿，把它周围的1全变为0(递归)，这样就能统计岛屿个数。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 深度优先遍历与i，j相邻的所有1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, grid:List[List[<span class="built_in">str</span>]], i:<span class="built_in">int</span>, j:<span class="built_in">int</span></span>) :</span></span><br><span class="line">        ni, nj = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>  <span class="comment"># 避免走向重复陆地，每到达一个陆地便置为0，表示走过了。</span></span><br><span class="line">        <span class="comment"># 后续四个方向遍历</span></span><br><span class="line">        <span class="keyword">if</span> i<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[i<span class="number">-1</span>][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            self.dfs(grid, i<span class="number">-1</span>, j)</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; ni <span class="keyword">and</span> grid[i+<span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            self.dfs(grid, i+<span class="number">1</span>, j)</span><br><span class="line">        <span class="keyword">if</span> j<span class="number">-1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[i][j<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            self.dfs(grid, i, j<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; nj <span class="keyword">and</span> grid[i][j+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            self.dfs(grid, i, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        ni, nj, res = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>]), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ni):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nj):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    self.dfs(grid, i, j)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="093-复原-IP-地址"><a href="#093-复原-IP-地址" class="headerlink" title="093. 复原 IP 地址"></a>093. 复原 IP 地址</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXN0b3JlLWlwLWFkZHJlc3Nlcy8=">https://leetcode.cn/problems/restore-ip-addresses/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 <strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; List[str]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        路径：每次从i~i+3，选择合法的ip段放入，再递归处理</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start=<span class="number">0</span>, dots=<span class="number">3</span>, segs=[]</span>):</span></span><br><span class="line">            <span class="comment"># start：起始位置, dots：需要放置&#x27;.&#x27;的数量</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">min</span>(n, start+<span class="number">3</span>)):</span><br><span class="line">                seg = s[start:i+<span class="number">1</span>]  <span class="comment"># </span></span><br><span class="line">                <span class="comment"># 首位不等于零时：&lt;=255</span></span><br><span class="line">                <span class="comment"># 首位等于零时：只能是0</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">int</span>(seg)&lt;=<span class="number">255</span> <span class="keyword">if</span> seg[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> <span class="built_in">len</span>(seg)==<span class="number">1</span>:</span><br><span class="line">                    segs.append(seg) <span class="comment"># 选择</span></span><br><span class="line">                    <span class="comment"># &#x27;.&#x27;和s同时用完时，结果存入res</span></span><br><span class="line">                    <span class="keyword">if</span> dots==<span class="number">0</span> <span class="keyword">and</span> i==n<span class="number">-1</span>: res.append(<span class="string">&#x27;.&#x27;</span>.join(segs))  </span><br><span class="line">                    <span class="keyword">else</span>: backtrack(i+<span class="number">1</span>, dots<span class="number">-1</span>, segs)  </span><br><span class="line">                    segs.pop()  <span class="comment">#　撤销选择</span></span><br><span class="line"></span><br><span class="line">        s, n = s, <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> n&lt;<span class="number">4</span> <span class="keyword">or</span> n&gt;<span class="number">12</span>: <span class="keyword">return</span> []</span><br><span class="line">        segs, res = [], []  <span class="comment"># segs：IP地址，res：所有IP地址</span></span><br><span class="line">        backtrack(<span class="number">0</span>, <span class="number">3</span>, segs)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h2 id="051-N-皇后"><a href="#051-N-皇后" class="headerlink" title="051. N 皇后"></a>051. N 皇后</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbi1xdWVlbnMv">https://leetcode-cn.com/problems/n-queens/<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlL2M3NjQwODc4MjUxMjQ4NmQ5MWVlYTE4MTEwNzI5M2I2">BM59 N皇后问题<i class="fa fa-external-link-alt"></i></span>。<br><strong>题目描述</strong>：<strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。<br>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例 1：<br>输入：<code>n = 4</code><br>输出：<code>[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</code><br>解释：如上图所示，4 皇后问题存在两个不同的解法。<br><div class="tabs" id="51"><ul class="nav-tabs"><li class="tab active"><a href="#51-1">051.递归</a></li><li class="tab"><a href="#51-2">BM59.递归</a></li><li class="tab"><a href="#51-3">051.回溯1</a></li><li class="tab"><a href="#51-4">051.回溯2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="51-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    n个皇后，不同行不同列，那么肯定棋盘每行都会有一个皇后，每列都会有一个皇后。</span></span><br><span class="line"><span class="string">    如果确定了第一个皇后的行号与列号，则相当于接下来的n−1行中查找n−1个皇后，这就是一个子问题，因此使用递归。</span></span><br><span class="line"><span class="string">    pos：因为每行只能有一列出现皇后，用一个数组记录皇后出现的位置，下标为行号，元素值为列号。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        res = <span class="number">0</span>  </span><br><span class="line">        pos = [<span class="number">0</span>] * n  <span class="comment">#下标为行号，元素为列号，记录皇后位置</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.recursion(n, <span class="number">0</span>, pos, res)  <span class="comment">#递归</span></span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#判断皇后是否符合条件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, pos: List[<span class="built_in">int</span>], row:<span class="built_in">int</span>, col:<span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):  <span class="comment"># 遍历所有已经记录的行</span></span><br><span class="line">            <span class="comment"># 不能同行、同列、同一斜线(行距==列距)</span></span><br><span class="line">            <span class="keyword">if</span> row==i <span class="keyword">or</span> col==pos[i] <span class="keyword">or</span> <span class="built_in">abs</span>(row-i)==<span class="built_in">abs</span>(col-pos[i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">#递归查找皇后种类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursion</span>(<span class="params">self, n:<span class="built_in">int</span>, row:<span class="built_in">int</span>, pos:List[<span class="built_in">int</span>], res:<span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> row == n:  <span class="comment"># 全部行都选择了位置，结束</span></span><br><span class="line">            board = [ [<span class="string">&#x27;.&#x27;</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 初始化成二维列表</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pos)):</span><br><span class="line">                board[i][pos[i]] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            board = [<span class="string">&#x27;&#x27;</span>.join(row) <span class="keyword">for</span> row <span class="keyword">in</span> board]  <span class="comment"># 二维列表转成字符串</span></span><br><span class="line">            self.result.append(board)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):   <span class="comment"># 遍历所有列</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(pos, row, i): </span><br><span class="line">                pos[row] = i  </span><br><span class="line">                self.recursion(n, row+<span class="number">1</span>, pos, res)  <span class="comment"># 递归继续查找</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="51-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#判断皇后是否符合条件</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, pos: List[<span class="built_in">int</span>], row:<span class="built_in">int</span>, col:<span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):  <span class="comment"># 遍历所有已经记录的行</span></span><br><span class="line">            <span class="comment"># 不能同行、同列、同一斜线(行距==列距)</span></span><br><span class="line">            <span class="keyword">if</span> row==i <span class="keyword">or</span> col==pos[i] <span class="keyword">or</span> <span class="built_in">abs</span>(row-i)==<span class="built_in">abs</span>(col-pos[i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">#递归查找皇后种类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recursion</span>(<span class="params">self, n:<span class="built_in">int</span>, row:<span class="built_in">int</span>, pos:List[<span class="built_in">int</span>], res:<span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> row == n:  <span class="comment"># 全部行都选择了位置，结束</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):   <span class="comment"># 遍历所有列</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(pos, row, i): </span><br><span class="line">                pos[row] = i  </span><br><span class="line">                res = self.recursion(n, row+<span class="number">1</span>, pos, res)  <span class="comment"># 递归继续查找</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Nqueen</span>(<span class="params">self , n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span>  </span><br><span class="line">        pos = [<span class="number">0</span>] * n  <span class="comment">#下标为行号，元素为列号，记录皇后位置</span></span><br><span class="line">        result = self.recursion(n, <span class="number">0</span>, pos, res)  <span class="comment">#递归</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="51-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 皇后可以攻击同一行、同一列、左上、左下、右上、右下任意单位。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        路径：棋盘中小于row的行已成功放置皇后</span></span><br><span class="line"><span class="string">        选择列表：第row行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="string">        结束条件：row超过棋盘的最后一行，棋盘放满了</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">board, row</span>):</span></span><br><span class="line">            <span class="keyword">if</span> row == <span class="built_in">len</span>(board):</span><br><span class="line">                board = [<span class="string">&#x27;&#x27;</span>.join(i) <span class="keyword">for</span> i <span class="keyword">in</span> board]</span><br><span class="line">                res.append(copy.deepcopy(board))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            n = <span class="built_in">len</span>(board[row]) <span class="comment"># n列</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 排除非法选择</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isValid(board, row, col): <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                backtrack(board, row+<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 取消选择</span></span><br><span class="line">                board[row][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">board, row, col</span>):</span></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            放置皇后是从上到下，就不需要判断左下、右下的合法性了</span></span><br><span class="line"><span class="string">            只需判断正上、左上、右上合法性</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            n = <span class="built_in">len</span>(board) <span class="comment"># n行/n列</span></span><br><span class="line">            <span class="comment"># 检查列是否冲突</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][col] == <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查右上方是否冲突</span></span><br><span class="line">            i = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br><span class="line">            j = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col+<span class="number">1</span>, n, <span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(i,j):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 检查左上方是否冲突</span></span><br><span class="line">            i = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br><span class="line">            j = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>)]</span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(i,j):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 字符串不可变，使用 列表/字符串切片拼接 方法</span></span><br><span class="line">        <span class="comment"># 双层列表拷贝要用copy.deepcopy(board)</span></span><br><span class="line">        board = [ [<span class="string">&#x27;.&#x27;</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        backtrack(board, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="51-4"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">记录主对角线、副对角线、列(皇后放置位置)：</span></span><br><span class="line"><span class="string">    主对角线(左上右下)：行下标与列下标之差相等 row-col == 常数</span></span><br><span class="line"><span class="string">    副对角线(右上左下)：行下标与列下标之和相等 row+col == 常数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generateBoard</span>():</span></span><br><span class="line">            board = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                row = [<span class="string">&quot;.&quot;</span>] * n</span><br><span class="line">                row[queens[i]] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                board.append(<span class="string">&quot;&quot;</span>.join(row))</span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">row: <span class="built_in">int</span></span>):</span></span><br><span class="line">            <span class="keyword">if</span> row == n:  <span class="comment"># 棋盘行全判断完结束</span></span><br><span class="line">                board = generateBoard()</span><br><span class="line">                solutions.append(board)</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="comment"># 排除非法选择</span></span><br><span class="line">                <span class="keyword">if</span> col <span class="keyword">in</span> columns <span class="keyword">or</span> row-col <span class="keyword">in</span> diagonal1 <span class="keyword">or</span> row+col <span class="keyword">in</span> diagonal2:  <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 做选择</span></span><br><span class="line">                queens[row] = col</span><br><span class="line">                columns.add(col)</span><br><span class="line">                diagonal1.add(row - col)</span><br><span class="line">                diagonal2.add(row + col)</span><br><span class="line">                <span class="comment"># 进入下一层</span></span><br><span class="line">                backtrack(row + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 撤销选择</span></span><br><span class="line">                columns.remove(col)</span><br><span class="line">                diagonal1.remove(row - col)</span><br><span class="line">                diagonal2.remove(row + col)</span><br><span class="line">                    </span><br><span class="line">        solutions = <span class="built_in">list</span>()</span><br><span class="line">        queens = [<span class="number">-1</span>] * n  <span class="comment"># 皇后放置在每行(下标)的列数(值)</span></span><br><span class="line">        columns = <span class="built_in">set</span>()    <span class="comment"># 皇后所在列位置</span></span><br><span class="line">        diagonal1 = <span class="built_in">set</span>()  <span class="comment"># 主对角线(左上右下)：row - col</span></span><br><span class="line">        diagonal2 = <span class="built_in">set</span>()  <span class="comment"># 副对角线(右上左下)：row + col</span></span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> solutions</span><br></pre></td></tr></table></figure></div></div></div></p>
<h2 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a>329. 矩阵中的最长递增路径</h2><p><strong>难度</strong>：困难<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWluY3JlYXNpbmctcGF0aC1pbi1hLW1hdHJpeC8=">https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingPath</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 深度优先搜索，返回[i,j]作为起点的最长递增路径长度</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">dp, i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j] != <span class="number">0</span>: <span class="keyword">return</span> dp[i][j]  <span class="comment"># dp[i][j]算过了直接用</span></span><br><span class="line">            dp[i][j] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> dirs:  <span class="comment"># 4个方向</span></span><br><span class="line">                nexti, nextj = i+x, j+y </span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=nexti&lt;ni <span class="keyword">and</span> <span class="number">0</span>&lt;=nextj&lt;nj <span class="keyword">and</span> matrix[nexti][nextj] &gt; matrix[i][j]:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dfs(dp, nexti, nextj)+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span>  <span class="comment"># 整体的最长递增路径长度</span></span><br><span class="line">        ni, nj = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*nj <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(ni)] <span class="comment"># [i,j]作为起点的最长递增路径</span></span><br><span class="line">        dirs = [[<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">0</span>, <span class="number">1</span>]]  <span class="comment"># 记录四个方向</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ni):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(nj):</span><br><span class="line">                res = <span class="built_in">max</span>(res, dfs(dp, i, j))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p><strong>DFS（深度优先搜索）</strong>可以被认为是回溯算法。<br><strong>BFS（广度优先搜索）</strong>核心是<strong>从一个点向其四周扩散</strong>，编写代码时<strong>使用队列每次将一个节点周围所有节点加入队列中</strong>。<br><strong>BFS相对于DFS</strong>：BFS找到的<strong>路径</strong>一定是<strong>最短</strong>的，但是代价是空间复杂度比DFS高。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从起点start到终点target的最短距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">start:Node, target:Node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> start <span class="keyword">or</span> <span class="keyword">not</span> target: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    q = collections.deque([(start, <span class="number">1</span>)])  <span class="comment"># 将起点加入队列，开始长度为1</span></span><br><span class="line">    visited = Set([start])  <span class="comment"># 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        node, depth = q.popleft()  <span class="comment"># 队尾弹出节点</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">is</span> target: <span class="keyword">return</span> depth   <span class="comment"># 判断是否到达终点</span></span><br><span class="line">        <span class="comment"># 将node的相邻节点加入队列：</span></span><br><span class="line">        <span class="comment"># 1.树结构</span></span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">and</span> node.left <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((node.left, depth+<span class="number">1</span>))  <span class="comment"># 队头加入</span></span><br><span class="line">                visited.add(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">and</span> node.right <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((node.right, depth+<span class="number">1</span>))  <span class="comment"># 队头加入</span></span><br><span class="line">                visited.add(node.right)</span><br><span class="line">        <span class="comment"># 2.复杂问题</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> 相邻节点:</span><br><span class="line">            <span class="keyword">if</span> node 合法:</span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">is</span> target: <span class="keyword">return</span> depth   <span class="comment"># 判断是否到达终点</span></span><br><span class="line">                q.append((node, depth+<span class="number">1</span>))</span><br><span class="line">                visited.add(node)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h2><p><strong>难度</strong>：简单<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：给定一个二叉树，找出其最小深度。最小深度是从<strong>根节点</strong>到<strong>最近叶子节点</strong>的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。<br>示例 1：<br>输入：<code>root = [3,9,20,null,null,15,7]</code><br>输出：<code>2</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 队列(右进左出)，根节点从 1 开始</span></span><br><span class="line">        q = collections.deque([(root, <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node, depth = q.popleft()</span><br><span class="line">            <span class="comment"># 到达叶子节点(左右节点为空)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right: <span class="keyword">return</span> depth</span><br><span class="line">            <span class="keyword">if</span> node.left: q.append((node.left, depth+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right: q.append((node.right, depth+<span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a>752. 打开转盘锁</h2><p><strong>难度</strong>：中等<br><strong>题目链接</strong>：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvb3Blbi10aGUtbG9jay8=">https://leetcode-cn.com/problems/open-the-lock/<i class="fa fa-external-link-alt"></i></span><br><strong>题目描述</strong>：你有一个带有<strong>四个圆形拨轮</strong>的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的<strong>最小旋转次数</strong>，如果无论如何不能解锁，返回 <code>-1</code> 。</p>
<p>示例 1:</p>
<p>输入：<code>deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</code><br>输出：<code>6</code><br>解释：<br>可能的移动序列为 “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”。<br>注意 “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” 这样的序列是不能解锁的，<br>因为当拨动到 “0102” 时这个锁就会被锁定。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openLock</span>(<span class="params">self, deadends: List[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="string">&quot;0000&quot;</span>: <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 起始为目标，返回0</span></span><br><span class="line"></span><br><span class="line">        dead = <span class="built_in">set</span>(deadends)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;0000&quot;</span> <span class="keyword">in</span> dead: <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment"># 起始在死亡状态，返回-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">num_prev</span>(<span class="params">x: <span class="built_in">str</span></span>) -&gt; str:</span>  <span class="comment"># 前拨</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;9&quot;</span> <span class="keyword">if</span> x == <span class="string">&quot;0&quot;</span> <span class="keyword">else</span> <span class="built_in">str</span>(<span class="built_in">int</span>(x) - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">num_succ</span>(<span class="params">x: <span class="built_in">str</span></span>) -&gt; str:</span>  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span> <span class="keyword">if</span> x == <span class="string">&quot;9&quot;</span> <span class="keyword">else</span> <span class="built_in">str</span>(<span class="built_in">int</span>(x) + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 枚举 当前节点 一次旋转得到的数字(每个节点有8个相邻节点)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">status: <span class="built_in">str</span></span>) -&gt; Generator[str, <span class="keyword">None</span>, <span class="keyword">None</span>]:</span></span><br><span class="line">            s = <span class="built_in">list</span>(status)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                num = s[i]</span><br><span class="line">                <span class="comment"># 前拨</span></span><br><span class="line">                s[i] = num_prev(num)</span><br><span class="line">                <span class="keyword">yield</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line">                <span class="comment"># 后拨</span></span><br><span class="line">                s[i] = num_succ(num)</span><br><span class="line">                <span class="keyword">yield</span> <span class="string">&quot;&quot;</span>.join(s)</span><br><span class="line">                s[i] = num</span><br><span class="line"></span><br><span class="line">        q = deque([(<span class="string">&quot;0000&quot;</span>, <span class="number">0</span>)])  <span class="comment"># 记录(当前状态, 路径长度)</span></span><br><span class="line">        seen = &#123;<span class="string">&quot;0000&quot;</span>&#125;  <span class="comment"># 记录走过的状态</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            status, step = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> next_status <span class="keyword">in</span> get(status):</span><br><span class="line">                <span class="keyword">if</span> next_status <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> next_status <span class="keyword">not</span> <span class="keyword">in</span> dead:</span><br><span class="line">                    <span class="keyword">if</span> next_status == target: <span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">                    q.append((next_status, step+<span class="number">1</span>))</span><br><span class="line">                    seen.add(next_status)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\21\Other\面试题集\" rel="bookmark">面试题集</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>SoundMemories
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://soundmemories.github.io/2019/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/" title="算法题">https://soundmemories.github.io/2019/01/31/Other/算法题合集/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Other/" rel="tag"><i class="fa fa-tag"></i> Other</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/01/25/Python/13.Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" rel="prev" title="Python-面向对象-基础">
                  <i class="fa fa-chevron-left"></i> Python-面向对象-基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/01/31/Python/14.Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/" rel="next" title="Python-面向对象-进阶">
                  Python-面向对象-进阶 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SoundMemories</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>








<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  








    <div class="pjax">
  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://soundmemories.github.io/2019/01/31/Other/%E7%AE%97%E6%B3%95%E9%A2%98%E5%90%88%E9%9B%86/',]
      });
      });
  </script>

    </div>
</body>
</html>
