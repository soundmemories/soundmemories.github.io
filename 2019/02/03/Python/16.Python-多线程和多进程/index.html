<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"soundmemories.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.0.2","exturl":true,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="基本概念">
<meta property="og:type" content="article">
<meta property="og:title" content="Python-多线程和多进程">
<meta property="og:url" content="https://soundmemories.github.io/2019/02/03/Python/16.Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/index.html">
<meta property="og:site_name" content="SoundMemories">
<meta property="og:description" content="基本概念">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-02-02T16:00:00.000Z">
<meta property="article:modified_time" content="2021-05-19T08:45:57.625Z">
<meta property="article:author" content="SoundMemories">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://soundmemories.github.io/2019/02/03/Python/16.Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python-多线程和多进程 | SoundMemories</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SoundMemories</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>
	   
		  
      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.1.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-number">1.2.</span> <span class="nav-text">同步和异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">1.3.</span> <span class="nav-text">阻塞和非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="nav-number">1.4.</span> <span class="nav-text">高并发的解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.5.</span> <span class="nav-text">进程和线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python3%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">Python3线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#thread"><span class="nav-number">2.1.</span> <span class="nav-text">_thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#threading"><span class="nav-number">2.2.</span> <span class="nav-text">threading</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#daemon%E7%BA%BF%E7%A8%8B%E5%92%8Cnon-daemon%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">daemon线程和non-daemon线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8A%A0%E5%A1%9E"><span class="nav-number">2.5.</span> <span class="nav-text">线程加塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">2.6.</span> <span class="nav-text">线程本地数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-Timer"><span class="nav-number">2.7.</span> <span class="nav-text">定时器 Timer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.</span> <span class="nav-text">线程安全和线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">线程安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">3.2.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%EF%BC%88Event%EF%BC%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">事件（Event）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%EF%BC%88Lock%EF%BC%89"><span class="nav-number">3.2.2.</span> <span class="nav-text">锁（Lock）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88RLock%EF%BC%89"><span class="nav-number">3.2.3.</span> <span class="nav-text">可重入锁（RLock）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88semaphore%EF%BC%89"><span class="nav-number">3.2.4.</span> <span class="nav-text">信号量（semaphore）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition%E7%B1%BB"><span class="nav-number">3.2.5.</span> <span class="nav-text">Condition类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">线程优先级队列（Queue）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">GIL全局解释器锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">多进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#multiprocessing-Process%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">multiprocessing.Process类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5"><span class="nav-number">6.2.</span> <span class="nav-text">进程间同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.3.</span> <span class="nav-text">进程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">6.4.</span> <span class="nav-text">多进程和多线程的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%9A%84%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.5.</span> <span class="nav-text">Linux的特殊进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#asyncio"><span class="nav-number">7.</span> <span class="nav-text">asyncio</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#asyncio%E7%9A%84%E5%8D%8F%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">asyncio的协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">7.3.</span> <span class="nav-text">事件循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E8%AF%AD%E6%B3%95"><span class="nav-number">7.4.</span> <span class="nav-text">新语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aiohttp"><span class="nav-number">7.5.</span> <span class="nav-text">aiohttp</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concurrent"><span class="nav-number">8.</span> <span class="nav-text">concurrent</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">8.1.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future"><span class="nav-number">8.2.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait"><span class="nav-number">8.3.</span> <span class="nav-text">wait()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor%E5%92%8CProcessPoolExecutor"><span class="nav-number">8.4.</span> <span class="nav-text">ThreadPoolExecutor和ProcessPoolExecutor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#joblib"><span class="nav-number">9.</span> <span class="nav-text">joblib</span></a></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SoundMemories"
      src="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
  <p class="site-author-name" itemprop="name">SoundMemories</p>
  <div class="site-description" itemprop="description">今日事，今日毕</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">118</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvdW5kbWVtb3JpZXM=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soundmemories"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNvdW5kbWVtb3JpZXNAMTYzLmNvbQ==" title="E-Mail → mailto:soundmemories@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2019/02/03/Python/16.Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://i.loli.net/2020/11/04/6JhNuwtBe4adylS.png">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python-多线程和多进程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-03 00:00:00" itemprop="dateCreated datePublished" datetime="2019-02-03T00:00:00+08:00">2019-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>40k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>36 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><a id="more"></a>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并行（parallel）：同时做某些事，可以互不干扰的<strong>同一个时刻</strong>做几件事。<br>并发（concurrency）：同时做某些事，但是强调<strong>一个时段内</strong>有事情要处理。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>一般意义上的同步：在不同环境下，同一个数据一致。</p>
<p>同一线程下，方法上的同步和异步：<br>同步：调用某个方法时，调用方需等待这个调用返回结果，才能继续往后执行。<br>异步：调用某个方法时，调用方不会立即得到结果，而是在调用发出后，调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回调函数来处理这个调用。</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>阻塞和非阻塞一般和线程、进程相关。<br>阻塞：在调用线程结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会被唤醒执行后续的操作。<br>非阻塞：在结果没有返回之前，该调用不会阻塞住当前线程。</p>
<p>同步和异步，阻塞和非阻塞，这二者区别：<br>阻塞和非阻塞是面向线程进程的。<br>同步和异步是面向方法的。</p>
<h3 id="高并发的解决"><a href="#高并发的解决" class="headerlink" title="高并发的解决"></a>高并发的解决</h3><p><strong>1、缓冲区</strong><br>队列：先进先出，其实就是一个缓冲区，解决资源使用顺序问题。<br>queue模块的类Queue、LifoQueue、PriorityQueue。<br><strong>2、锁机制</strong><br>谁抢到资源就上锁，其他人只能等待。<br>争抢也是一种高并发解决方案，但是随机这样可能不好，因为有可能有人很长时间抢不到。<br><strong>3、预处理</strong><br>一种提前加载用户需要的数据的思路，预处理思想，缓存常用。<br>比如提前统计需要什么资源，提前准备好，即使有锁机制，也会很快释放锁。<br><strong>4、并行</strong><br>水平扩展思想，可以多开进程、线程实现并行处理，解决并发问题。<br>能不能使用并行，与计算机CPU数量、核心数量有关系。<br><strong>5、提速</strong><br>垂直扩展思想，提高单个进程、线程处理速度。<br>提高单个CPU性能，或单个服务器性能。<br><strong>6、消息中间件</strong><br>系统和系统之间的缓冲。<br>常见的消息中间件有RabbitMQ、ActiveMQ（Apache）、RocketMQ（阿里Apache）、kafka（Apache）等。</p>
<p>当然还有其他手段解决并发问题，但是已经列举除了最常用的解决方案，一般来说不同的并发场景用不同的策略，而策略可能是多种方式的优化组合。</p>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。一个程序的执行实例就是一个进程。<br>线程（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<p>进程和程序的关系：程序是源代码编译后的文件，而这些文件存放在磁盘上。当程序被操作系统加载到内存中，就是进程，进程中存放着指令和数据（资源），它也是线程的容器。<br>Linux进程有父进程、子进程，Windows的进程是平等关系。</p>
<p>进程控制自己的线程，所以进程可以互通资源，但线程不能，线程只从所属的进程拿资源。<br>创建一个线程比创建一个进程快10~100倍，这是因为线程不需要进行资源分配，不过线程的效果还是看执行时处理速度，创建快并不能说明线程执行快。</p>
<p>线程的生命周期：参考<a href="https://soundmemories.github.io/2020/02/24/Java/24.Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a>。</p>
<h2 id="Python3线程"><a href="#Python3线程" class="headerlink" title="Python3线程"></a>Python3线程</h2><p>Python3 线程中常用的两个模块为：<br>（1）_thread。<br>（2）threading（推荐使用）。<br>thread 模块已被废弃。用户可以使用 threading 模块代替。所以在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。</p>
<p>Python中使用线程有两种方式：<br>（1）函数 包装线程对象。<br>（2）类 包装线程对象。</p>
<h3 id="thread"><a href="#thread" class="headerlink" title="_thread"></a>_thread</h3><p>_thread提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。<br><code>_thread.start_new_thread ( function, args[, kwargs])</code>，function线程函数，args传递给线程函数的参数,他必须是个tuple类型，kwargs可选参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为线程定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params"> threadName, delay</span>):</span></span><br><span class="line">   count = <span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">      time.sleep(delay)</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % ( threadName, time.ctime(time.time()) ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个线程</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   _thread.start_new_thread( print_time, (<span class="string">&quot;Thread-1&quot;</span>, <span class="number">2</span>, ) )</span><br><span class="line">   _thread.start_new_thread( print_time, (<span class="string">&quot;Thread-2&quot;</span>, <span class="number">4</span>, ) )</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;Error: 无法启动线程&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：<br>（1）<code>threading.current_thread()</code>：返回当前对应调用者的控制线程的 Thread 对象。如果调用者的控制线程不是利用 threading 创建，会返回一个功能受限的虚拟线程对象。<br>（3）<code>threading.active_count()</code>：返回当前存活的 Thread 对象的数量。 返回值与 enumerate() 所返回的列表长度一致。<br>（2）<code>threading.enumerate()</code>：以列表形式返回当前所有存活的 Thread 对象。该列表包含守护线程，current_thread() 创建的虚拟线程对象和主线程。它不包含已终结的线程和尚未开始的线程。<br>（4）<code>threading.get_ident()</code>：返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。<br>（5）<code>threading.main_thread()</code>：返回主 Thread 对象。一般情况下，主线程是Python解释器开始时创建的线程。<br>（6）<code>threading.settrace(func)</code>：为所有 threading 模块开始的线程设置追踪函数。在每个线程的 run() 方法被调用前，func 会被传递给 sys.settrace() 。<br>（7）<code>threading.setprofile(func)</code>：为所有 threading 模块开始的线程设置性能测试函数。在每个线程的 run() 方法被调用前，func 会被传递给 sys.setprofile() 。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showtreadinfo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;current thread = &#123;&#125;\nmain thread = &#123;&#125;\nactive count = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        threading.current_thread(), threading.main_thread(), threading.active_count()</span><br><span class="line">        ))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    showtreadinfo()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">&#x27;i am working&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = threading.Thread(target=worker, name=<span class="string">&#x27;worker&#x27;</span>) <span class="comment"># 线程对象</span></span><br><span class="line">    showtreadinfo()</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    t.start() <span class="comment"># 启动</span></span><br><span class="line">    print(<span class="string">&#x27;===end===&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>threading模块同样提供了Thread类来处理线程，调用这个构造函数时，必需带有关键字参数：<br><code>class threading.Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None)</code>：<br>（1）group：应该为 None；为了日后扩展 ThreadGroup 类实现而保留。<br>（2）target：是用于 run() 方法调用的可调用对象。默认是 None，表示不需要调用任何方法。<br>（3）name：是线程名称。默认情况下，由 “Thread-N” 格式构成一个唯一的名称，其中 N 是小的十进制数。<br>（4）args：是用于调用目标函数的参数元组。默认是 ()。<br>（5）kwargs：是用于调用目标函数的关键字参数字典。默认是 {}。<br>（6）daemon：如果不是 None，daemon 参数将显式地设置该线程是否为守护模式。 如果是 None (默认值)，线程将继承当前线程的守护模式属性。</p>
<p>Thread类有如下属性：<br>（1）<code>name</code>：只用于识别的字符串。它没有语义。多个线程可以赋予相同的名称。初始名称由构造函数设置。<br>（2）<code>ident</code>：线程ID。这个线程的 ‘线程标识符’，如果线程尚未开始则为 None 。这是个非零整数。一个线程退出而另外一个线程被创建，线程标识符会被复用。即使线程退出后，仍可得到标识符。<br>（3）<code>daemon</code>：一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 start() 前设置好，不然会抛出 RuntimeError 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 daemon = False。当没有存活的非守护线程时，整个Python程序才会退出。</p>
<p>Thread类提供了以下方法：<br>（1）<code>run()</code>： 用以表示线程活动的方法。只运行线程函数。不start()线程。<br>（2）<code>start()</code>：启动线程活动。启动线程后run()。<br>（3）<code>join([time])</code>：等待，直到线程终结。阻塞调用这个方法的线程，直到被调用 join() 的线程终结。超时选项是可选的。一个线程可以被 join() 很多次。<br>（4）<code>is_alive()</code>：返回线程是否活动的。<br>（5）<code>getName()</code>：返回线程名。<br>（6）<code>setName()</code>：设置线程名。<br>（7）<code>get_ident()</code>：获取线程ID。<br>（8）<code>isDaemon()</code>：是否是daemon线程。<br>（9）<code>setDaemon()</code>：设置为daemon线程，必须在start方法之前设置。</p>
<div class="note info"><p>start()和run()的区别：<br>使用start()启动一个新线程，会在该线程中自动调用对象的run()。<br>单独run()的，并没有启动新的线程，就是在主线程中调用了一个普通的函数而已。</p>
</div>
<p>通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">exitFlag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, counter</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开始线程：&quot;</span> + self.name)</span><br><span class="line">        print_time(self.name, self.counter, <span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;退出线程：&quot;</span> + self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay, counter</span>):</span></span><br><span class="line">    <span class="keyword">while</span> counter:</span><br><span class="line">        <span class="keyword">if</span> exitFlag:</span><br><span class="line">            threadName.exit()</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建新线程</span></span><br><span class="line">    thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启新线程</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line">    thread1.join()</span><br><span class="line">    thread2.join()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure><br>Python没有提供线程退出的方法，线程在下面情况时退出：<br>（1）线程函数内语句执行完毕。<br>（2）线程函数中抛出未处理的异常。</p>
<p>Python的线程没有优先级、没有线程组的概念，也不能被销毁、停止、挂起，那也就没有恢复、中断了。</p>
<h3 id="daemon线程和non-daemon线程"><a href="#daemon线程和non-daemon线程" class="headerlink" title="daemon线程和non-daemon线程"></a>daemon线程和non-daemon线程</h3><p>Python中，构造线程的时候，可以设置daemon属性，这个属性必须在start方法前设置好。这里的daemon不是Linux中的守护进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码Thread的__init__方法中</span></span><br><span class="line"><span class="keyword">if</span> daemon <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    self._daemonic = daemon <span class="comment"># 用户设定bool值</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self._daemonic = current_thread().daemon</span><br><span class="line">self._ident = <span class="literal">None</span></span><br></pre></td></tr></table></figure><br>线程daemon属性，可设置，如果没设置，就取当前线程的daemon值。<br>主线程是non-daemon线程，即daemon = False。<br>daemon：<br>（1）False：就是non-daemon线程。此时主线程会等待子线程，直到所有子线程结束而结束。<br>（1）True：就是daemon线程。此时该线程会随主线程的退出而退出。</p>
<p>Python程序在没有活着的non-daemon线程运行时，程序退出，也就是除主线程之外剩下的只能都是daemon线程，主线程才能退出，否则主线程就只能等待。</p>
<p>non-daemon线程总是要等待它的non-daemon线程结束而结束，会杀死daemon线程。<br>daemon线程总是跟随non-daemon线程结束而结束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">name, timeout</span>):</span></span><br><span class="line">    time.sleep(timeout)</span><br><span class="line">    print(<span class="string">&#x27;&#123;&#125; Exits&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=worker, args=(<span class="string">&#x27;t1&#x27;</span>, <span class="number">1</span>), daemon=<span class="literal">True</span>)  <span class="comment"># 调换1和10看看效果</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = threading.Thread(target=worker, args=(<span class="string">&#x27;t2&#x27;</span>, <span class="number">10</span>), daemon=<span class="literal">False</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    print(<span class="string">&#x27;Main Thread Exits&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="线程加塞"><a href="#线程加塞" class="headerlink" title="线程加塞"></a>线程加塞</h3><p>当在某个线程的线程体中调用了另一个线程的join()方法，当前线程将被阻塞，直到join进来的线程执行完它才能继续：<br><code>join(timeout=None)</code>：等待该线程终止。timeout参数指定调用者等待多久，没有设置超时，就一直等到被调用线程结束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">name, timeout</span>):</span></span><br><span class="line">    time.sleep(timeout)</span><br><span class="line">    print(<span class="string">&#x27;&#123;&#125; working&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=worker, args=(<span class="string">&#x27;t1&#x27;</span>, <span class="number">3</span>), daemon=<span class="literal">True</span>)<span class="comment">#主线程和子线程t无关</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t1.join()  <span class="comment"># 设置join，取消join对比一下</span></span><br><span class="line">    print(<span class="string">&#x27;Main Thread Exits&#x27;</span>)</span><br></pre></td></tr></table></figure><br>使用了join方法后，daemon线程执行完了，主线程才退出了。</p>
<h3 id="线程本地数据"><a href="#线程本地数据" class="headerlink" title="线程本地数据"></a>线程本地数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    x = <span class="number">0</span> <span class="comment"># 局部变量，每一个线程的x都是独立的</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        print(threading.current_thread(), x)</span><br><span class="line">i</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        threading.Thread(target=worker).start()</span><br></pre></td></tr></table></figure>
<p>那么，一个全局变量，分别放入不同的线程中处理，这个全局变量在线程中如何互不影响呢？</p>
<p>python提供 threading.local 类，可以实例化得到一个全局对象，但是不同的线程使用这个对象存储的数据其他线程看不见。<br>可以创建一个 local （或者一个子类型）的实例并在实例中储存属性储存属性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    data.x = <span class="number">0</span> <span class="comment"># 可以像局部变量一样使用，属性可随意命名</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        data.x += <span class="number">1</span></span><br><span class="line">    print(threading.current_thread(), data.x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = threading.local()<span class="comment"># 创建一个全局local对象</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        threading.Thread(target=worker).start()</span><br></pre></td></tr></table></figure><br>threading.local类构建了一个大字典，存放所有线程相关的字典，定义如下：<br><code>&#123; id(Thread) -&gt; (ref(Thread), thread-local dict) &#125;</code><br>每一线程实例的id为key，元组为value。value：<code>(线程对象引用，每个线程自己的字典)</code>。</p>
<p>运行时，threading.local实例处在不同的线程中，就从大字典中找到当前线程相关键值对中的字典，覆盖threading.local实例的 __dict__ 。<br>这样就可以在不同的线程中，安全地使用线程独有的数据，做到了线程间数据隔离，如同本地变量一样安全。</p>
<h3 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h3><p>threading.Timer继承自Thread，这个类用来定义延迟多久后执行一个函数。<br><code>class threading.Timer(interval, function, args=None, kwargs=None)</code>：start()执行之后，Timer对象会处于等待状态，等待了interval秒之后，开始执行function函数的。<br>Timer提供了<code>cancel()</code>方法，用来取消一个未执行的函数，如果下面例子中worker函数已经开始执行，cancel就没有任何效果了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">&quot;%(asctime)s %(threadName)s %(thread)d %(message)s&quot;</span></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=FORMAT)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    logging.info(<span class="string">&#x27;in worker&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 延迟4秒后执行worker函数</span></span><br><span class="line">    t = threading.Timer(<span class="number">4</span>, worker)</span><br><span class="line">    t.setName(<span class="string">&#x27;timer&#x27;</span>)</span><br><span class="line">    <span class="comment"># t.cancel() # start前可取消</span></span><br><span class="line"></span><br><span class="line">    t.start()</span><br><span class="line">    <span class="comment"># time.sleep(4)</span></span><br><span class="line">    <span class="comment"># t.cancel() # start后，t已经执行了，取消不了</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>cancel方法本质使用Event类实现。这并不是说，线程提供了取消的方法。</p>
<h2 id="线程安全和线程同步"><a href="#线程安全和线程同步" class="headerlink" title="线程安全和线程同步"></a>线程安全和线程同步</h2><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>多线程编程是有趣且复杂的事情，它常常容易突然出现“错误情况”，这是由于系统的线程调度具有一定的随机性。即使程序在运行过程中偶尔会出现问题，那也是由于我们的代码有问题导致的。当多个线程访问同一个数据时，非常容易出现线程安全问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    total = <span class="number">5</span> <span class="comment">#5试不出效果，换10 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Ticket, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span>(Ticket.total &gt; <span class="number">0</span>):</span><br><span class="line">            print(self.getName()+ <span class="string">&quot;卖出一张票&quot;</span>)</span><br><span class="line">            Ticket.total -= <span class="number">1</span></span><br><span class="line">            print(<span class="string">&quot;剩余：&quot;</span> + <span class="built_in">str</span>(Ticket.total))</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Ticket(<span class="string">&quot;窗口一&quot;</span>,)</span><br><span class="line">    t2 = Ticket(<span class="string">&quot;窗口二&quot;</span>)</span><br><span class="line">    t3 = Ticket(<span class="string">&quot;窗口三&quot;</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br></pre></td></tr></table></figure><br>如上程序，当执行时，会出现下面的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">窗口一卖出一张票</span><br><span class="line">剩余：4</span><br><span class="line">窗口一卖出一张票</span><br><span class="line">剩余：3</span><br><span class="line">窗口一卖出一张票</span><br><span class="line">窗口三卖出一张票</span><br><span class="line">剩余：1</span><br><span class="line">窗口三卖出一张票</span><br><span class="line">剩余：0</span><br><span class="line">窗口二卖出一张票</span><br><span class="line">剩余：2</span><br><span class="line">剩余：-1</span><br></pre></td></tr></table></figure><br>程序中设定一共5张票，但为什么会出现“剩余：-1”这种情况呢？而且总共卖了6张票？<br>这可能出现了这种情况：当窗口一卖出一张票后，被其他线程抢占cpu执行了，此时窗口一若是卡在<code>Ticket.total -= 1</code>语句等待再次运行，而当其他线程运行完毕时total等于0了，此时再回去执行窗口一的<code>Ticket.total -= 1</code>语句，total就是-1了。<br>卖了6张票的原因，可能是第6次进入时，total值并不是0，因为其他线程没有来得及执行<code>Ticket.total -= 1</code>就被抢占了，这就导致运行时线程数据不一致的安全问题。</p>
<p><strong>print线程安全</strong><br>python中print()其实就不是线程安全的，在使用多线程的时候会被打断。<br>解决办法：<br>（1）标准库里面的logging模块，日志处理模块，线程安全的，生成环境代码都使用logging。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>():</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        logging.warning(<span class="string">&#x27;&#123;&#125; is running.&#x27;</span>.<span class="built_in">format</span>(threading.current_thread().name))</span><br><span class="line">        <span class="comment">#print(&#x27;&#123;&#125; is running.\n&#x27;.format(threading.current_thread().name), end=&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">8</span>): <span class="comment"># 可以增加线程</span></span><br><span class="line">        name = <span class="string">&#x27;worker&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x)</span><br><span class="line">        t = threading.Thread(target=worker, name=name)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><br>（2）手动上锁。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> (<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, counter</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程： &quot;</span> + self.name)</span><br><span class="line">        <span class="comment"># 获取锁，用于线程同步</span></span><br><span class="line">        threadLock.acquire()</span><br><span class="line">        print_time(self.name, self.counter, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line">        threadLock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">threadName, delay, counter</span>):</span></span><br><span class="line">    <span class="keyword">while</span> counter:</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;%s: %s&quot;</span> % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    threadLock = threading.Lock()</span><br><span class="line">    threads = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建新线程</span></span><br><span class="line">    thread1 = myThread(<span class="number">1</span>, <span class="string">&quot;Thread-1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    thread2 = myThread(<span class="number">2</span>, <span class="string">&quot;Thread-2&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启新线程</span></span><br><span class="line">    thread1.start()</span><br><span class="line">    thread2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加线程到线程列表</span></span><br><span class="line">    threads.append(thread1)</span><br><span class="line">    threads.append(thread2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;退出主线程&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>如何解决线程安全问题呢？<br>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。</p>
<p>Python中引入线程同步，让一个线程访问某些数据时，其他线程不能访问这些数据，直到该线程完成对数据的操作。<br>Python提供多种方式实现线程同步： 事件（Event）、锁（Lock）、信号量（Semaphore）等方式，其中锁是互斥量（Mutex）。</p>
<h4 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h4><p>threading.Event是线程间通信机制中最简单的实现类，使用一个内部的标记flag，通过flag的True或False的变化来实现代线程同步，可以看成一种锁机制。<br>threading.Event事件管理可以使用<code>set()</code>方法设置为True，使用<code>clear()</code>方法设置为False。<code>wait()</code>方法在False时阻塞，直到标记为True。标志最初是False。<br>threading.Event中可使用的方法：<br>（1）<code>set()</code>：标记设置为True。<br>（2）<code>clear()</code>：标记设置为False。<br>（3）<code>is_set()</code>：标记是否为True。<br>（4）<code>wait(timeout=None)</code>：设置等待标记为True的时长，None为无限等待。等到返回True，未等到超时了返回False。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    total = <span class="number">10</span></span><br><span class="line">    event = threading.Event()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Ticket, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">        Ticket.event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> Ticket.event.is_set():<span class="comment"># 可以卖，上锁，卖票</span></span><br><span class="line">                Ticket.event.clear() <span class="comment"># 上锁</span></span><br><span class="line">                <span class="keyword">if</span> Ticket.total &gt; <span class="number">0</span>:</span><br><span class="line">                    print(self.getName() + <span class="string">&quot;卖出一张票&quot;</span>)</span><br><span class="line">                    Ticket.total -= <span class="number">1</span></span><br><span class="line">                    print(self.getName() + <span class="string">&quot;：剩余：&quot;</span> + <span class="built_in">str</span>(Ticket.total))</span><br><span class="line">                    Ticket.event.<span class="built_in">set</span>()<span class="comment"># 释放锁</span></span><br><span class="line">                    time.sleep(<span class="number">1</span>) <span class="comment">#让其他线程有充足机会抢占</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span><span class="comment"># 退出while循环后，要记得释放锁</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 正在卖，等卖完</span></span><br><span class="line">                Ticket.event.wait()</span><br><span class="line">        Ticket.event.<span class="built_in">set</span>()<span class="comment">#都结束后，释放锁，不然会锁死</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Ticket(<span class="string">&quot;窗口一&quot;</span>,)</span><br><span class="line">    t2 = Ticket(<span class="string">&quot;窗口二&quot;</span>)</span><br><span class="line">    t3 = Ticket(<span class="string">&quot;窗口三&quot;</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br></pre></td></tr></table></figure></p>
<p>threading.Event本质是通过threading.Condition类和Lock对象来实现的，可以说是对锁（Lock）的一种包装类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源码Event的__init__方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">    self._cond = Condition(Lock())</span><br><span class="line">    self._flag = <span class="literal">False</span></span><br></pre></td></tr></table></figure></p>
<h4 id="锁（Lock）"><a href="#锁（Lock）" class="headerlink" title="锁（Lock）"></a>锁（Lock）</h4><p>锁机制，就是对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。一个线程获得锁，其它试图获取锁的线程将被阻塞。<br>凡是存在共享资源争抢的地方都可以使用锁，从而保证只有一个使用者可以完全使用这个资源。</p>
<p>threading.Lock 本质是方法，能生成对应的锁对象。<br>threading.Lock()生成的对象有的方法：<br>（1）<code>acquire(blocking=True,timeout=-1)</code>：默认阻塞，阻塞可以设置超时时间。非阻塞时，timeout禁止设置。成功获取锁，返回True，否则返回False。<br>（2）<code>release()</code>：释放锁。可以从任何线程调用释放。已上锁的锁，会被重置为unlocked，未上锁的锁上调用，抛RuntimeError异常。</p>
<p>对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 <code>acquire()</code> 和 <code>release()</code>之间。<br><strong>1、阻塞锁</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    total = <span class="number">20</span></span><br><span class="line">    lock = threading.Lock() <span class="comment">#必须用同一个锁对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Ticket, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment"># while内上锁，while时可以被抢占</span></span><br><span class="line">            Ticket.lock.acquire()<span class="comment"># 上锁</span></span><br><span class="line">            <span class="keyword">if</span> Ticket.total &gt; <span class="number">0</span>:</span><br><span class="line">                print(self.getName() + <span class="string">&quot;卖出一张票&quot;</span>)</span><br><span class="line">                Ticket.total -= <span class="number">1</span></span><br><span class="line">                print(self.getName() + <span class="string">&quot;：剩余：&quot;</span> + <span class="built_in">str</span>(Ticket.total))</span><br><span class="line">                Ticket.lock.release() <span class="comment"># 释放锁</span></span><br><span class="line">                time.sleep(<span class="number">1</span>)<span class="comment"># 让其他线程有充足机会抢占</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        Ticket.lock.release()<span class="comment"># 都结束后，释放锁，不然会锁死</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Ticket(<span class="string">&quot;窗口一&quot;</span>,)</span><br><span class="line">    t2 = Ticket(<span class="string">&quot;窗口二&quot;</span>)</span><br><span class="line">    t3 = Ticket(<span class="string">&quot;窗口三&quot;</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br></pre></td></tr></table></figure><br><strong>锁释放的优化</strong><br>一般来说，加锁就需要解锁，但是加锁后解锁前，还要有一些代码执行，就有可能抛异常，一旦出现异常，锁是无法释放，但是当前线程可能因为这个异常被终止了，这就产生了死锁。<br>加锁、解锁常用语句：<br>（1）使用try…finally语句保证锁的释放。<br>（2）with上下文管理，锁对象支持上下文管理。with对象的enter()上锁，exit())解锁。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    total = <span class="number">20</span></span><br><span class="line">    lock = threading.Lock() <span class="comment">#必须用同一个锁对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Ticket, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment"># while内上锁，while时可以被抢占</span></span><br><span class="line">            <span class="keyword">with</span> Ticket.lock:<span class="comment"># 上锁</span></span><br><span class="line">                <span class="keyword">if</span> Ticket.total &gt; <span class="number">0</span>:</span><br><span class="line">                    print(self.getName() + <span class="string">&quot;卖出一张票&quot;</span>)</span><br><span class="line">                    Ticket.total -= <span class="number">1</span></span><br><span class="line">                    print(self.getName() + <span class="string">&quot;：剩余：&quot;</span> + <span class="built_in">str</span>(Ticket.total))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)  <span class="comment"># 让其他线程有充足机会抢占</span></span><br><span class="line">        <span class="comment">#Ticket.lock.release()# 使用with就不需要手动释放锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Ticket(<span class="string">&quot;窗口一&quot;</span>,)</span><br><span class="line">    t2 = Ticket(<span class="string">&quot;窗口二&quot;</span>)</span><br><span class="line">    t3 = Ticket(<span class="string">&quot;窗口三&quot;</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br></pre></td></tr></table></figure><br><strong>2、非阻塞锁</strong><br>当某个线程遇到了阻塞锁，那么只等阻塞，等待锁的释放，但其后面的任务与阻塞的任务无关，这时就可以使用非阻塞锁。<br>非阻塞锁把 阻塞的代码 和 其他代码分开，可以在没获得锁的情况下，继续执行其他代码。一般使用while循环它，当获得锁时，就可以执行阻塞的代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    total = <span class="number">20</span> </span><br><span class="line">    lock = threading.Lock() <span class="comment">#必须用同一个锁对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Ticket, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment"># while内上锁，while时可以被抢占</span></span><br><span class="line">            <span class="comment"># 非阻塞锁，不影响其他代码运行，while循环，获得锁时可以执行阻塞的代码</span></span><br><span class="line">            <span class="keyword">if</span> Ticket.lock.acquire(<span class="literal">False</span>):</span><br><span class="line">                <span class="keyword">if</span> Ticket.total &gt; <span class="number">0</span>:</span><br><span class="line">                    print(self.getName() + <span class="string">&quot;卖出一张票&quot;</span>)</span><br><span class="line">                    Ticket.total -= <span class="number">1</span></span><br><span class="line">                    print(self.getName() + <span class="string">&quot;：剩余：&quot;</span> + <span class="built_in">str</span>(Ticket.total))</span><br><span class="line">                    print(<span class="string">&quot;送一个玩具&quot;</span>)</span><br><span class="line">                    Ticket.lock.release() <span class="comment"># 释放锁</span></span><br><span class="line">                    time.sleep(<span class="number">1</span>)<span class="comment"># 让其他线程有充足机会抢占</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 不影响卖玩具</span></span><br><span class="line">                print(<span class="string">&quot;卖一个玩具&quot;</span>)</span><br><span class="line">        Ticket.lock.release()<span class="comment"># 都结束后，释放锁，不然会锁死</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Ticket(<span class="string">&quot;窗口一&quot;</span>,)</span><br><span class="line">    t2 = Ticket(<span class="string">&quot;窗口二&quot;</span>)</span><br><span class="line">    t3 = Ticket(<span class="string">&quot;窗口三&quot;</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br></pre></td></tr></table></figure></p>
<h4 id="可重入锁（RLock）"><a href="#可重入锁（RLock）" class="headerlink" title="可重入锁（RLock）"></a>可重入锁（RLock）</h4><p>可重入锁，是<strong>线程相关</strong>的锁：<br>（1）一个线程获得了可重入锁，同一个线程就可以在不阻塞的情况下再多次获取可重入锁。<br>（2）可重入锁必须由获取它的线程释放，不能跨线程释放锁。<br>（3）当锁未释放完，其它线程获取锁就会阻塞，直到当前持有锁的线程释放完锁。<br>（4）线程必须在每次获得它时释放它一次。不能过多释放，会报异常。</p>
<p>threading.RLRock 本质是方法，能生成对应的锁对象。<br>threading.RLock()生成的对象有的方法：<br>（1）<code>acquire(blocking=True,timeout=-1)</code>：默认阻塞，阻塞可以设置超时时间。非阻塞时，timeout禁止设置。成功获取锁，返回True，否则返回False。<br>（2）<code>release()</code>：释放锁。可以从任何线程调用释放。已上锁的锁，会被重置为unlocked，未上锁的锁上调用，抛RuntimeError异常。<br>当主线程中使用RLock，在没释放完锁时，调用另一个线程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span>(<span class="params">l</span>):</span></span><br><span class="line">    <span class="comment"># 可以获取多个锁，但最后必须在当前线程释放掉</span></span><br><span class="line">    print(<span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(threading.current_thread(), l.acquire()))</span><br><span class="line">    print(<span class="string">&#x27;&#123;&#125;: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(threading.current_thread(), l.acquire()))</span><br><span class="line">    l.release()</span><br><span class="line">    print(<span class="string">&#x27;sub released once&#x27;</span>)</span><br><span class="line">    l.release()</span><br><span class="line">    print(<span class="string">&#x27;sub released twice&#x27;</span>)</span><br><span class="line">    <span class="comment">#l.relese() # 不能多释放</span></span><br><span class="line"></span><br><span class="line">lock = threading.RLock()</span><br><span class="line">print(<span class="string">&#x27;main thread, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(lock.acquire())) <span class="comment"># count = 1</span></span><br><span class="line"><span class="comment"># 当前线程没释放完锁，调用其他线程</span></span><br><span class="line">threading.Thread(target=sub, args=(lock,)).start() <span class="comment"># 为另一个线程传入同一个lock对象</span></span><br><span class="line"><span class="comment"># 10秒后，当前线程释放锁</span></span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br><span class="line">lock.release() <span class="comment"># count = 0</span></span><br><span class="line">print(<span class="string">&#x27;main thread released&#x27;</span>)</span><br></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main thread, True</span><br><span class="line">main thread released</span><br><span class="line">&lt;Thread(Thread-1, started 21600)&gt;: True</span><br><span class="line">&lt;Thread(Thread-1, started 21600)&gt;: True</span><br><span class="line">sub released once</span><br><span class="line">sub released twice</span><br></pre></td></tr></table></figure><br>当线程锁未释放完，其它线程获取锁就会阻塞，直到当前持有锁的线程释放完锁。</p>
<h4 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h4><p>和Lock很像，信号量对象内部维护一个倒计数器，默认初始值为1，每一次<code>acquire()</code>都会减1，当<code>acquire()</code>发现计数为0就阻塞请求的线程，直到其它线程对信号量<code>release()</code>后，计数大于0，恢复阻塞的线程。</p>
<p>threading.Semaphore(value=1)生成的对象有的方法：<br>（1）<code>acquire(blocking=True,timeout=-1)</code>：获取信号量，计数器减1。默认阻塞，阻塞可以设置超时时间。非阻塞时，timeout禁止设置。成功获取信号量，返回True，否则返回False。<br>（2）<code>release()</code>：释放信号量，计数器加1。可以从任何线程调用释放。已上锁的锁、未上锁的锁，计数器加1，不会报异常。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Semaphore</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">&#x27;%(asctime)s %(threadName)-12s %(thread)-8s %(message)s&#x27;</span></span><br><span class="line">logging.basicConfig(<span class="built_in">format</span>=FORMAT, level=logging.INFO)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">s:Semaphore</span>):</span></span><br><span class="line">    logging.info(<span class="string">&quot;in worker thread&quot;</span>)</span><br><span class="line">    logging.info(s.acquire())</span><br><span class="line">    logging.info(<span class="string">&#x27;worker thread over&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    s = Semaphore(<span class="number">3</span>)</span><br><span class="line">    logging.info(s.acquire())</span><br><span class="line">    print(s._value)<span class="comment"># 私有变量value，记录了当前信号量个数</span></span><br><span class="line">    logging.info(s.acquire())</span><br><span class="line">    print(s._value)</span><br><span class="line">    logging.info(s.acquire())</span><br><span class="line">    print(s._value)</span><br><span class="line"></span><br><span class="line">    Thread(target=worker, args=(s,)).start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    logging.info(s.acquire(<span class="literal">False</span>))<span class="comment">#获取不到锁，不阻塞</span></span><br><span class="line">    logging.info(s.acquire(timeout=<span class="number">3</span>))<span class="comment">#获取不到锁，等3秒超时结束</span></span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">&#x27;release one&#x27;</span>)</span><br><span class="line">    s.release()<span class="comment">#释放完一个信号量，worker才能工作</span></span><br></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2019-02-04 00:27:43,427 MainThread   13112    True</span><br><span class="line">2</span><br><span class="line">2019-02-04 00:27:43,427 MainThread   13112    True</span><br><span class="line">1</span><br><span class="line">2019-02-04 00:27:43,427 MainThread   13112    True</span><br><span class="line">0</span><br><span class="line">2019-02-04 00:27:43,427 Thread-1     6332     in worker thread</span><br><span class="line">2019-02-04 00:27:45,428 MainThread   13112    False</span><br><span class="line">2019-02-04 00:27:48,429 MainThread   13112    False</span><br><span class="line">2019-02-04 00:27:48,429 MainThread   13112    release one</span><br><span class="line">2019-02-04 00:27:48,429 Thread-1     6332     True</span><br><span class="line">2019-02-04 00:27:48,429 Thread-1     6332     worker thread over</span><br></pre></td></tr></table></figure><br><strong>Semaphore越界问题</strong><br>假设如果还没有acquire信号量，就release，会怎么样？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Semaphore</span><br><span class="line"></span><br><span class="line">s = Semaphore(<span class="number">3</span>)</span><br><span class="line">s.release()</span><br><span class="line">print(s._value)<span class="comment">#4</span></span><br><span class="line">s.release()</span><br><span class="line">print(s._value)<span class="comment">#5</span></span><br><span class="line">s.release()</span><br><span class="line">print(s._value)<span class="comment">#6</span></span><br></pre></td></tr></table></figure><br>从上例输出结果可以看出，内置计数器超出了初始值，需要解决这个问题。<br>使用BoundedSemaphore（有界信号量）替代Semaphore（信号量），其release()多了会报错，不会超过初始值。</p>
<h4 id="Condition类"><a href="#Condition类" class="headerlink" title="Condition类"></a>Condition类</h4><p>threading.Condition类，可以传一个Lock或RLock对象，默认是RLock。<br>threading.Condition允许一个或多个线程等待（wait），直到被其他线程唤醒（notify或notify_all）。<br>（1）<code>acquire(blocking=True,timeout=-1)</code>：默认阻塞，阻塞可以设置超时时间。非阻塞时，timeout禁止设置。成功获取锁，返回True，否则返回False。<br>（2）<code>release()</code>：释放锁。可以从任何线程调用释放。已上锁的锁，会被重置为unlocked未上锁的锁上调用，抛RuntimeError异常。<br>（3）<code>wait()</code>：等待释放。<br>（4）<code>notify(n=1)</code>：唤醒<strong>一个或指定个数</strong>同一个锁对象、正在等待的线程。双线程可用。<br>（5）<code>notifyAll()</code>：唤醒<strong>所有</strong>同一个锁对象、正在等待的线程。多线程建议用此，不然出现锁死情况。</p>
<p>其中（1）（2）解决信息同步问题，（3）（4）（5）解决线程的协调工作问题，采用了通知机制，非常有效率。。参考<a href="https://soundmemories.github.io/2020/02/24/Java/24.Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java多线程</a>的“线程通信”部分。</p>
<p>使用Condition，必须先<code>acquire()</code>，用完了要<code>release()</code>，因为内部使用了锁，默认使用RLock锁，最好的方式是使用with上下文。<br>线程之间协调工作，可以使用w<code>ait()</code>和<code>notify()</code>、<code>notify_all()</code>，阻塞和通知机制。</p>
<p>最好的例子就是生产着消费着的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Workbench</span>:</span></span><br><span class="line">    Max = <span class="number">1</span><span class="comment">#缓存上限</span></span><br><span class="line">    lock = threading.Condition(threading.Lock())</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.count = <span class="number">1</span> <span class="comment">#当前缓存数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        Workbench.lock.acquire()</span><br><span class="line">        <span class="keyword">while</span>(self.count &gt;= Workbench.Max):</span><br><span class="line">            Workbench.lock.wait()</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        print(name + <span class="string">&quot;放了一盘菜，剩余：&quot;</span> + <span class="built_in">str</span>(self.count))</span><br><span class="line">        Workbench.lock.notify()</span><br><span class="line">        Workbench.lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        Workbench.lock.acquire()</span><br><span class="line">        <span class="keyword">while</span>(self.count &lt;= <span class="number">0</span>):</span><br><span class="line">            Workbench.lock.wait()</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line">        print(name + <span class="string">&quot;取走一盘菜，剩余：&quot;</span> + <span class="built_in">str</span>(self.count))</span><br><span class="line">        Workbench.lock.notify_all()<span class="comment">#防止死锁，唤醒所有处于阻塞的消费者和生产者</span></span><br><span class="line">        <span class="comment">#Workbench.lock.notify() #使用这个，会出现死锁</span></span><br><span class="line">        Workbench.lock.release()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cook</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, tai:Workbench</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Cook, self).__init__()</span><br><span class="line">        self.tai = tai</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.tai.put(self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Waiter</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, tai:Workbench</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Waiter, self).__init__()</span><br><span class="line">        self.tai = tai</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.tai.take(self.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tai = Workbench()</span><br><span class="line">    c1 = Cook(<span class="string">&quot;生产者1&quot;</span>, tai)</span><br><span class="line">    c2 = Cook(<span class="string">&quot;生产者2&quot;</span>, tai)</span><br><span class="line">    w1 = Waiter(<span class="string">&quot;消费者1&quot;</span>, tai)</span><br><span class="line">    w2 = Waiter(<span class="string">&quot;消费者2&quot;</span>, tai)</span><br><span class="line"></span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line">    w1.start()</span><br><span class="line">    w2.start()</span><br></pre></td></tr></table></figure><br>还可以进一步优化，使用上下文管理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="comment">#Workbench.lock.acquire()</span></span><br><span class="line">        <span class="keyword">with</span> Workbench.lock:</span><br><span class="line">            <span class="keyword">while</span>(self.count &gt;= Workbench.Max):</span><br><span class="line">                Workbench.lock.wait()</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            print(name + <span class="string">&quot;放了一盘菜，剩余：&quot;</span> + <span class="built_in">str</span>(self.count))</span><br><span class="line">            Workbench.lock.notify()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span>(<span class="params">self, name</span>):</span></span><br><span class="line">    <span class="keyword">with</span> Workbench.lock:</span><br><span class="line">        <span class="keyword">while</span>(self.count &lt;= <span class="number">0</span>):</span><br><span class="line">            Workbench.lock.wait()</span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line">        print(name + <span class="string">&quot;取走一盘菜，剩余：&quot;</span> + <span class="built_in">str</span>(self.count))</span><br><span class="line">        Workbench.lock.notify_all()<span class="comment">#防止死锁，唤醒所有处于阻塞的消费者和生产者</span></span><br><span class="line">        <span class="comment">#Workbench.lock.notify() #使用这个，会出现死锁</span></span><br></pre></td></tr></table></figure></p>
<h2 id="线程优先级队列（Queue）"><a href="#线程优先级队列（Queue）" class="headerlink" title="线程优先级队列（Queue）"></a>线程优先级队列（Queue）</h2><p>为什么讲魔术方法时，说实现容器的大小，不准确？<br>如果不加锁，是不可能获得准确的大小的，因为你刚读取到了一个大小，还没有取走，就有可能被其他线程改了。</p>
<p>Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。<br>这些队列都内部使用了Lock和Condition实现了线程同步和线程安全，能够在多线程中直接使用，可以使用队列来实现线程间的同步。</p>
<p>Queue类的size虽然加了锁，但是，依然不能保证立即get、put就能成功，因为读取大小和get、put方法是分开的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">if</span> q.qsize() == <span class="number">7</span>:</span><br><span class="line">    q.put() <span class="comment"># 上下两句可能被打断</span></span><br><span class="line"><span class="keyword">if</span> q.qsize() == <span class="number">1</span>:</span><br><span class="line">    q.get() <span class="comment"># 未必会成功</span></span><br></pre></td></tr></table></figure></p>
<h2 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h2><p>CPython 在解释器<strong>进程级</strong>别有一把锁，叫做GIL 全局解释器锁。</p>
<p>GIL 保证CPython进程中，只有一个线程执行字节码。甚至是在多核CPU的情况下，也只允许同时只能有一个CPU上运行该进程的一个线程。</p>
<p>CPython中：<br>（1）IO密集型，由于线程阻塞，就会调度其他线程。<br>（2）CPU密集型，当前线程可能会连续的获得GIL，导致其它线程几乎无法使用CPU。Python中线程没有用上多核优势。<br>（3）在CPython中由于有GIL存在，<strong>IO密集型，使用多线程较为合算</strong>。<strong>CPU密集型，使用多进程，要绕开GIL</strong>。</p>
<p>新版CPython正在努力优化GIL的问题，但不是移除。<br>如果在意多线程的效率问题，请绕行，选择其它语言erlang、Go等<br><div class="note info"><p>Python中绝大多数内置数据结构的读、写操作都是原子操作。原子操作不可打断，它们线程安全因为GIL存在。<br>由于GIL的存在，Python的内置数据类型在多线程编程的时候就变成了安全的了，但是实际上它们本身<strong>不是线程安全类</strong>。</p>
</div></p>
<p>保留GIL的原因：<br>（1）Guido坚持的简单哲学，对于初学者门槛低，不需要高深的系统知识也能安全、简单的使用Python。<br>（2）移除GIL，会降低CPython单线程的执行效率。</p>
<p>测试下面2个程序，请问下面的程序是 计算密集型 还是 IO密集型 ？<br><div class="tabs" id="calc"><ul class="nav-tabs"><li class="tab active"><a href="#calc-1">1</a></li><li class="tab"><a href="#calc-2">2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="calc-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&quot;%(thread)s %(message)s&quot;</span>)</span><br><span class="line">start = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>():</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000000</span>): <span class="comment"># 10亿</span></span><br><span class="line">        <span class="built_in">sum</span> += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">calc()</span><br><span class="line">calc()</span><br><span class="line">calc()</span><br><span class="line">calc()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    delta = (datetime.datetime.now() - start).total_seconds()</span><br><span class="line">    logging.info(delta)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="calc-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&quot;%(thread)s %(message)s&quot;</span>)</span><br><span class="line">start = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>():</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000000</span>): <span class="comment"># 10亿</span></span><br><span class="line">        <span class="built_in">sum</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=calc)</span><br><span class="line">    t2 = threading.Thread(target=calc)</span><br><span class="line">    t3 = threading.Thread(target=calc)</span><br><span class="line">    t4 = threading.Thread(target=calc)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">    t4.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    t3.join()</span><br><span class="line">    t4.join()</span><br><span class="line"></span><br><span class="line">    delta = (datetime.datetime.now() - start).total_seconds()</span><br><span class="line">    logging.info(delta)</span><br></pre></td></tr></table></figure></div></div></div></p>
<p>注意，不要在代码中出现print等访问IO的语句。访问IO，线程阻塞，会释放GIL锁，其他线程被调度。</p>
<p>程序1是单线程程序，所有calc()依次执行，根本就不是并发。在主线程内，函数串行执行。<br>程序2是多线程程序，calc()执行在不同的线程中，但是由于GIL的存在，线程的执行变成了假并发。但是这些线程可以被调度到不同的CPU核心上执行，只不过GIL让同一时间该进程只有一个线程被执行。</p>
<p>从两段程序测试的结果来看，CPython中多线程根本没有任何优势，和一个线程执行时间相当。因为GIL的存在，<br>尤其是像上面的计算密集型程序，和单线程串行效果相当。这样，实际上就没有用上CPU多核心的优势。</p>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>由于Python的GIL全局解释器锁存在，多线程未必是CPU密集型程序的好的选择。</p>
<p>多进程可以完全独立的进程环境中运行程序，可以较充分地利用多处理器。<br>但进程本身的隔离带来的数据不共享也是一个问题。而且线程比进程轻量级。</p>
<h3 id="multiprocessing-Process类"><a href="#multiprocessing-Process类" class="headerlink" title="multiprocessing.Process类"></a>multiprocessing.Process类</h3><p>Process类遵循了Thread类的API，减少了学习难度。<br>先看一个例子，前面介绍的单线程、多线程比较的例子的多进程版本。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000000</span>): <span class="comment"># 10亿</span></span><br><span class="line">        <span class="built_in">sum</span> += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> i, <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = datetime.datetime.now() <span class="comment"># 注意一定要有这一句</span></span><br><span class="line">    </span><br><span class="line">    ps = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        p = multiprocessing.Process(target=calc, args=(i,), name=<span class="string">&#x27;calc-&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        ps.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">        p.join()</span><br><span class="line">        print(p.name, p.exitcode)</span><br><span class="line">        </span><br><span class="line">    delta = (datetime.datetime.now() - start).total_seconds()</span><br><span class="line">    print(delta)</span><br><span class="line">    print(<span class="string">&#x27;===end====&#x27;</span>)</span><br></pre></td></tr></table></figure><br>对于上面这个程序，在使用单线程、多线程都跑了4分钟多，而多进程用了1分半，这是真并行。<br>可以看出，几乎没有什么学习难度，注意：<code>__name__ == &quot;__main__&quot;</code> 多进程代码一定要放在这下面执行。</p>
<p>multiprocessing.Process类的属性和方法：<br>（1）<code>pid</code>/<code>ident</code>：进程id。<br>（2）<code>name</code>：进程名字。<br>（3）<code>exitcode</code>：进程的退出状态码。<br>（4）<code>terminate()</code>：终止指定的进程。<br>（5）<code>start()</code>：启动进程。<br>（6）<code>join(timeout=None)</code>：阻塞进程。<br>（7）<code>run()</code>：运行进程内方法。</p>
<h3 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h3><p>Python在进程间同步提供了和线程同步一样的类，使用的方法一样，使用的效果也类似。<br>不过，进程间代价要高于线程间，而且底层实现是不同的，只不过Python屏蔽了这些不同之处，让用户简单使用多进程。</p>
<p>multiprocessing还提供共享内存、服务器进程来共享数据，还提供了用于进程间通讯的Queue队列、Pipe管道。</p>
<p><strong>Python的进程和线程通信方式不同：</strong><br>（1）多进程就是启动多个解释器进程，进程间通信必须序列化、反序列化。<br>（2）数据的线程安全性问题。如果每个进程中没有实现多线程，GIL可以说没什么用了。</p>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>multiprocessing.Pool 是进程池类：<br>（1）<code>apply(self, func, args=(), kwds=&#123;&#125;)</code>：阻塞，同一时刻，进程池中只能有一个进程执行。同步，当前进程需等待返回结果。<br>（2）<code>apply_async(self, func, args=(), kwds=&#123;&#125;,callback=None, error_callback=None)</code>：非阻塞，同一时刻，进程池中所有进程可并行执行。异步，能立即返回调用对象（不是结果），在得到结果后，会执行回调函数callback。运行发生错误，执行error_callback。<br>（3）<code>close()</code>：关闭池，池不能再接受新的任务。会等到pool里进程执行完关闭。<br>（4）<code>terminate()</code>：结束工作进程，不再处理未处理的任务。立即结束当前进程，关闭pool。<br>（5）<code>join()</code>：主进程阻塞等待子进程的退出， join方法要在close或terminate之后使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志打印进程id、进程名、线程id、线程名</span></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&quot;%(process)d %(processName)s %(thread)d %(message)s&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000000</span>): <span class="comment"># 10亿</span></span><br><span class="line">        <span class="built_in">sum</span> += <span class="number">1</span></span><br><span class="line">    logging.info(<span class="built_in">sum</span>)</span><br><span class="line">    <span class="keyword">return</span> i, <span class="built_in">sum</span> <span class="comment"># 进程要return，才可以拿到这个结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    start = datetime.datetime.now() <span class="comment"># 注意一定要有这一句</span></span><br><span class="line">    pool = multiprocessing.Pool(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="comment"># 返回值，同步调用，注意观察CPU使用</span></span><br><span class="line">        ret = pool.apply(calc, args=(i,))<span class="comment">#同步，相当于串行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#ret = pool.apply_async(calc, args=(i,))#异步，立即返回临时对象</span></span><br><span class="line">        <span class="comment">#异步，立即返回临时对象，直到完成后，回调</span></span><br><span class="line">        <span class="comment">#ret = pool.apply_async(calc, args=(i,),callback=lambda ret: logging.info(&#x27;&#123;&#125; in callback&#x27;.format(ret)))</span></span><br><span class="line">        print(ret)</span><br><span class="line"></span><br><span class="line">    pool.close()<span class="comment">#关闭池，等池中任务都执行完</span></span><br><span class="line">    pool.join()<span class="comment">#close之后才能join，主进程阻塞等待pool子进程结束</span></span><br><span class="line">    delta = (datetime.datetime.now() - start).total_seconds()</span><br><span class="line">    print(delta)</span><br><span class="line">    print(<span class="string">&#x27;===end====&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="多进程和多线程的选择"><a href="#多进程和多线程的选择" class="headerlink" title="多进程和多线程的选择"></a>多进程和多线程的选择</h3><p>（1）CPU密集型：CPython中使用到了GIL，多线程的时候锁相互竞争，且多核优势不能发挥，Python多进程效率更高。<br>（2）IO密集型：适合是用多线程，可以减少多进程间IO的序列化开销。且在IO等待的时候，切换到其他线程继续执行，效率不错。</p>
<p>应用：请求/应答模型（Web应用中常见的处理模型）<br>（1）master启动多个worker工作进程，一般和CPU数目相同。发挥多核优势。<br>（2）worker工作进程中，往往需要操作网络IO和磁盘IO，启动多线程，提高并发处理能力。worker处理用户的请求，往往需要等待数据，处理完请求还要通过网络IO返回响应。<br>这就是nginx工作模式。</p>
<h3 id="Linux的特殊进程"><a href="#Linux的特殊进程" class="headerlink" title="Linux的特殊进程"></a>Linux的特殊进程</h3><p>在Linux/Unix中，通过父进程创建子进程。</p>
<p><strong>僵尸进程</strong><br>一个进程使用了fork创建了子进程，如果子进程终止进入僵死状态，而父进程并没有调用wait或者waitpid获取子进程的状态信息，那么子进程仍留下一个数据结构保存在系统中，这种进程称为僵尸进程。<br>僵尸进程会占用一定的内存空间，还占用了进程号，所以一定要避免大量的僵尸进程产生。有很多方法可以避免僵尸进程。<br><strong>孤儿进程</strong><br>父进程退出，而它的子进程仍在运行，那么这些子进程就会成为孤儿进程。孤儿进程会被init进程（进程号为1）收养，并由init进程对它们完成状态收集工作。<br>init进程会循环调用wait这些孤儿进程，所以，孤儿进程没有什么危害。<br><strong>守护进程</strong><br>它是运行在后台的一种特殊进程。它独立于控制终端并周期性执行某种任务或等待处理某些事件。<br>守护进程的父进程是init进程，因为其父进程已经故意被终止掉了。<br>守护进程相对于普通的孤儿进程需要做一些特殊处理。</p>
<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p>3.4版本加入标准库。<br>asyncio底层基于selectors实现，看似库，其实就是个框架，包含异步IO、事件循环、协程、任务等内容。<br>asyncio中能调用前面讲过的大部分类，比如Condition、Event、Lock、Queue等等。<br>asyncio还有一些特有的方法和机制，比如事件循环。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程，又称微线程，纤程。英文名Coroutine。<br>子程序，或者称为函数，在所有语言中都是层级调用。所以子程序调用是通过栈实现的。<br>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。<br>协程执行过程中，在同一个线程内部子程序可中断，然后转而执行这个线程的其他子程序，在适当的时候再返回来接着执行。</p>
<p>协程不是进程、也不是线程，它是用户空间调度的手动、并发处理的方式。<br>进程、线程由操作系统完成调度，而协程是同一个线程内完成调度。它不需要更多的线程，自然也没有多线程切换带来的开销。<br>协程是非抢占式调度，只有一个协程主动让出控制权，另一个协程才会被调度。<br>协程也不需要使用锁机制，因为是在同一个线程中执行。<br>多CPU下，可以使用多进程和协程配合，既能发挥进程并行有势，又能发挥协程在单线程中并发的优势。<br>Python中协程是基于生成器的。</p>
<p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;z&#x27;</span>)</span><br></pre></td></tr></table></figure><br>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure><br>但是在A中是没有调用B的，看起来A、B的执行有点像多线程，但协程的特点在于是<strong>一个线程执行</strong>，那和多线程比，协程有何优势？<br>（1）最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。<br>（2）第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是<strong>多进程+协程</strong>，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。</p>
<p>举例：<br>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。<br>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>():</span></span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        print(<span class="string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span>(<span class="params">c</span>):</span></span><br><span class="line">    c.<span class="built_in">next</span>()</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        print(<span class="string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c = consumer()</span><br><span class="line">    produce(c)</span><br></pre></td></tr></table></figure><br>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：<br>（1）首先调用c.next()启动生成器；<br>（2）然后，一旦生产了东西，通过c.send(n)切换到consumer执行；<br>（3）consumer通过yield拿到消息，处理，又通过yield把结果传回；<br>（4）produce拿到consumer处理的结果，继续生产下一条消息；<br>（5）produce决定不生产了，通过c.close()关闭consumer，整个过程结束。<br>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
<h3 id="asyncio的协程"><a href="#asyncio的协程" class="headerlink" title="asyncio的协程"></a>asyncio的协程</h3><p>asyncio中与协程相关方法：<br>（1）<code>asyncio.iscoroutine(obj)</code>：判断是不是协程对象。<br>（2）<code>asyncio.iscoroutinefunction(func)</code>：判断是不是协程函数。</p>
<p>asyncio.Future类：和concurrent.futures.Future类似。通过Future对象可以了解任务执行的状态数据。事件循环来监控Future对象是否完成。<br>asyncio.Task类：Task类是Future的子类，它的作用就是把协程包装成一个Future对象。</p>
<p>asyncio使用装饰器，将生成器函数转换成协程函数，就可以在事件循环中执行了。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环是asyncio提供的核心运行机制。<br>事件循环解决的是多协程事件的自动循环执行的问题。</p>
<p>asyncio事件循环相关方法：<br>（1）<code>asyncio.get_event_loop()</code>：返回一个EventLoop（事件循环对象），是asyncio.BaseEventLoop的实例。<br>（2）<code>asyncio.create_task(coro)</code>：使用EventLoop（事件循环对象/协程对象）创建任务对象（Future类或子类Task的对象）。<br>（2）<code>asyncio.ensure_future(coro)</code>：使用EventLoop（事件循环对象/协程对象）创建任务对象（Future类或子类Task的对象）。<br>EventLoop对象使用的方法：<br>（1）<code>run_forever()</code>：一直运行，直到stop()。<br>（2）<code>run_until_complete(future/task)</code>：运行直至Future对象运行完，返回future的运行结果，即<code>future.result()</code>。参数可以是Future类或子类Task的对象。<br>（3）<code>stop()</code>：停止运行事件循环。<br>（4）<code>close()</code>：关闭事件循环。<br>（5）<code>is_running()</code>：返回事件循环的是否运行。<br>EventLoop对象这些方法，继承自AbstractEventLoop类。</p>
<p>我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)<span class="comment"># asyncio.sleep(1)返回的是None</span></span><br><span class="line">    print(<span class="string">&quot;Hello again!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 获取EventLoop:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># 执行coroutine</span></span><br><span class="line">    result = loop.run_until_complete(hello())</span><br><span class="line">    <span class="comment"># 获取return值</span></span><br><span class="line">    print(result)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    loop.run_until_complete(hello())的本质是执行了2步：</span></span><br><span class="line"><span class="string">    （1）task = asyncio.ensure_future(hello()) #先用ensure_future把协程包装进一个Future对象中，并使用create_task返回一个task</span></span><br><span class="line"><span class="string">    （2）loop.run_forever(task) # 也可以把task放入run_until_complete(task)中执行</span></span><br><span class="line"><span class="string">    （3）task.result() # 返回task的return结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure><br><code>@asyncio.coroutine</code>把一个generator标记为coroutine类型，然后，我们就把这个coroutine扔到EventLoop中执行。</p>
<p><code>hello()</code>会首先打印出”Hello world!”，然后，<code>yield from</code>语法可以让我们方便地调用另一个generator。由于<code>asyncio.sleep()</code>也是一个coroutine，所以线程不会等待<code>asyncio.sleep()</code>，而是直接中断并执行下一个消息循环。当<code>asyncio.sleep()</code>返回时，线程就可以从<code>yield from</code>拿到返回值（此处是None），然后接着执行下一行语句。</p>
<p>把<code>asyncio.sleep(1)</code>看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine了，因此可以实现并发执行。</p>
<p>所以也可以这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># asyncio.sleep(1)返回的是None</span></span><br><span class="line">    print(<span class="string">&quot;Hello again!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 获取EventLoop:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = asyncio.ensure_future(hello())</span><br><span class="line">    <span class="comment"># 执行coroutine</span></span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    <span class="comment">#获取return值</span></span><br><span class="line">    print(task.result()) <span class="comment">#asyncio.sleep(1)返回的是None</span></span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure><br>task对象都可以调用<code>add_done_callback(fn)</code>增加回调函数，回调函数是单参的，参数就是task对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># asyncio.sleep(1)返回的是None</span></span><br><span class="line">    print(<span class="string">&quot;Hello again!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回调函数，参数必须是task，task运行结束会自动调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cb</span>(<span class="params">task</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;in task callback = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(task))</span><br><span class="line">    print(<span class="built_in">type</span>(task)) <span class="comment"># &lt;class &#x27;_asyncio.Task&#x27;&gt;</span></span><br><span class="line">    print(task.result()) <span class="comment"># 打印返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 获取EventLoop:</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    task = asyncio.ensure_future(hello())</span><br><span class="line">    <span class="comment"># 增加回调函数</span></span><br><span class="line">    task.add_done_callback(cb)<span class="comment">#只写回调函数名字</span></span><br><span class="line">    <span class="comment"># 执行coroutine</span></span><br><span class="line">    loop.run_until_complete(task)</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure><br>我们用Task封装两个coroutine试试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;Hello world! (%s)&#x27;</span> % threading.currentThread())</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&#x27;Hello again! (%s)&#x27;</span> % threading.currentThread())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [hello(), hello()]</span><br><span class="line">    <span class="comment"># asyncio.wait 会迭代列表中的对象并封装成&#123;f1,f2&#125;，返回一个协程对象f</span></span><br><span class="line">    <span class="comment"># 循环执行f，它内部等价yield from &#123;f1,f2&#125;</span></span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure><br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello world! (&lt;_MainThread(MainThread, started 6100)&gt;)</span><br><span class="line">Hello world! (&lt;_MainThread(MainThread, started 6100)&gt;)</span><br><span class="line">(暂停约1秒)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 6100)&gt;)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 6100)&gt;)</span><br></pre></td></tr></table></figure><br>由打印的当前线程名称可以看出，两个coroutine是由同一个线程并发执行的。</p>
<p>如果把<code>asyncio.sleep()</code>换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。</p>
<h3 id="新语法"><a href="#新语法" class="headerlink" title="新语法"></a>新语法</h3><p>用asyncio提供的<code>@asyncio.coroutine</code>可以把一个generator标记为coroutine类型，然后在coroutine内部用yield from调用另一个coroutine实现异步操作。</p>
<p>为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法async和await，可以让coroutine的代码更简洁易读。</p>
<p>async和await是针对coroutine的新语法，要使用新的语法，只需要做两步简单的替换：<br>（1）把<code>@asyncio.coroutine</code>替换为<code>async</code>。<br>（2）把<code>yield from</code>替换为<code>await</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    r = <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot;Hello again!&quot;</span>)</span><br></pre></td></tr></table></figure><br>可替换为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">    r = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot;Hello again!&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h3><p>异步HTTP客户端、服务端框架。</p>
<p>asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。</p>
<p>asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。<br>安装：<code>pip install aiohttp</code></p>
<div class="tabs" id="http"><ul class="nav-tabs"><li class="tab active"><a href="#http-1">HTTP Server</a></li><li class="tab"><a href="#http-2">HTTP Client</a></li></ul><div class="tab-content"><div class="tab-pane active" id="http-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">indexhandle</span>(<span class="params">request:web.Request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=request.path, status=<span class="number">201</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">request:web.Request</span>):</span></span><br><span class="line">    print(request.match_info)</span><br><span class="line">    print(request.query_string) <span class="comment"># http://127.0.0.1:8080/1?name=12301</span></span><br><span class="line">    <span class="keyword">return</span> web.Response(text=request.match_info.get(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;0000&#x27;</span>), status=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">app = web.Application()</span><br><span class="line">app.router.add_get(<span class="string">&quot;/&quot;</span>, indexhandle) <span class="comment"># http://127.0.0.1:8080/</span></span><br><span class="line">app.router.add_get(<span class="string">&quot;/&#123;id&#125;&quot;</span>, handle) <span class="comment"># http://127.0.0.1:8080/12301</span></span><br><span class="line"><span class="comment"># app.add_routes([</span></span><br><span class="line"><span class="comment"># web.get(&#x27;/&#x27;, indexhandle),</span></span><br><span class="line"><span class="comment"># web.get(&#x27;/&#123;id&#125;&#x27;, handle),</span></span><br><span class="line"><span class="comment"># ])</span></span><br><span class="line">web.run_app(app, host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">9977</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="http-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span>(<span class="params">url:<span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> res:</span><br><span class="line">            print(res.status)</span><br><span class="line">            print(<span class="keyword">await</span> res.text())</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1:8080/2?age=20&amp;name=jerry&#x27;</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(get_html(url))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></div></div></div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">return</span> web.Response(body=<span class="string">b&#x27;&lt;h1&gt;Index&lt;/h1&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">    text = <span class="string">&#x27;&lt;h1&gt;hello, %s!&lt;/h1&gt;&#x27;</span> % request.match_info[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> web.Response(body=text.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">loop</span>):</span></span><br><span class="line">    app = web.Application(loop=loop)</span><br><span class="line">    app.router.add_route(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, index)</span><br><span class="line">    app.router.add_route(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/hello/&#123;name&#125;&#x27;</span>, hello)</span><br><span class="line">    srv = <span class="keyword">await</span> loop.create_server(app.make_handler(), <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>)</span><br><span class="line">    print(<span class="string">&#x27;Server started at http://127.0.0.1:8000...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> srv</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(init(loop))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure>
<p>注意aiohttp的初始化函数<code>init()</code>也是一个coroutine，<code>loop.create_server()</code>则利用asyncio创建TCP服务。</p>
<h2 id="concurrent"><a href="#concurrent" class="headerlink" title="concurrent"></a>concurrent</h2><p>Python3.2开始，标准库为我们提供了concurrent.futures模块，它提供了ThreadPoolExecutor和ProcessPoolExecutor两个类，实现了对threading和multiprocessing的进一步抽象，对编写线程池/进程池提供了直接的支持,他属于上层的封装，对于用户来说，不用在考虑那么多东西了。</p>
<p>concurrent.futures主要继承了Executor、Future、wait()等，所以其子类ThreadPoolExecutor和ProcessPoolExecutor两个类也继承了它们的功能。</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>Exectuor是基础模块，这是一个抽象类，其子类分为ThreadPoolExecutor和ProcessPoolExecutor，分别被用来创建线程池和进程池。<br>Exectuor提供的方法如下：<br>（1）<code>Executor.submit(fn, *args, **kwargs)</code>：往线程池中加入一个task，返回一个Future对象。其中<code>future.result()</code>的result方法的作用是拿到调用返回的结果。<br>（2）<code>Executor.map(fn, *args, **kwargs)</code>：和python自带的map函数功能类似，但它是异步执行，并且每一个异步操作，能用timeout参数来设置超时时间，超时会报TimeoutError异常。<br>（3）<code>Executor.shutdown(wait=True)</code>：释放异步执行操作后的系统资源。True阻塞，等池内Futures都执行完返回。False立即返回，池内Futures继续执行完。Executor实现了__enter__和__exit__使得其对象可以使用with操作符。</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>future提供了跟踪任务执行状态的方法，Future实例可以被<code>Executor.submit()</code>方法创建。除了测试之外不应该直接创建。<br>（1）<code>cancel()</code>：尝试去取消调用。如果调用当前正在执行，不能被取消。这个方法将返回False，否则调用将会被取消，方法将返回True。只有pending状态才能取消。<br>（2）<code>cancelled()</code>：如果调用被成功取消返回True。<br>（3）<code>running()</code>：如果当前正在被执行不能被取消返回True。有pending、running、finished三种状态。<br>（4）<code>done()</code>：如果调用被成功取消或者完成running返回True。<br>（5）<code>result(Timeout = None)</code>：拿到调用返回的结果。如果没有执行完毕就会去等待。<br>（6）<code>exception(timeout=None)</code>：捕获程序执行过程中的异常。<br>（7）<code>add_done_callback(fn)</code>：将fn绑定到future对象上。当future对象被取消或完成运行时，fn函数将会被调用。</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><p><code>wait()</code>接会返回一个tuple(元组)，tuple中包含两个set(集合)，一个是completed(已完成的)另外一个是uncompleted(未完成的)。使用<code>wait()</code>的一个优势就是获得更大的自由度，它接收三个参数<code>FIRST_COMPLETED</code>, <code>FIRST_EXCEPTION</code> 和<code>ALL_COMPLETE</code>，默认设置为<code>ALL_COMPLETED</code>。</p>
<p>如果采用默认的<code>ALL_COMPLETED</code>，程序会阻塞直到池里面的所有任务都完成，再执行主线程。<br>如果采用<code>FIRST_COMPLETED</code>，程序并不会等到池里面所有的任务都完成。</p>
<h3 id="ThreadPoolExecutor和ProcessPoolExecutor"><a href="#ThreadPoolExecutor和ProcessPoolExecutor" class="headerlink" title="ThreadPoolExecutor和ProcessPoolExecutor"></a>ThreadPoolExecutor和ProcessPoolExecutor</h3><p>concurrent.futures的ThreadPoolExecutor和ProcessPoolExecutor子类，完全继承了上面的所有功能，它们的区别一个是线程池，一个是进程池。</p>
<p>ThreadPoolExecutor类：<br><code>ThreadPoolExecutor(max_workers=1)</code>：池中至多创建max_workers个线程来同时异步执行，返回Executor实例。<br>ProcessPoolExecutor类：<br><code>ProcessPoolExecutor(max_workers=1)</code>：池中至多创建max_workers个进程来同时异步执行，返回Executor实例。</p>
<div class="tabs" id="threadpool"><ul class="nav-tabs"><li class="tab active"><a href="#threadpool-1">ThreadPoolExecutor</a></li><li class="tab"><a href="#threadpool-2">ProcessPoolExecutor</a></li></ul><div class="tab-content"><div class="tab-pane active" id="threadpool-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出格式定义</span></span><br><span class="line">FORMAT = <span class="string">&#x27;%(asctime)-15s\t [%(processName)s:%(threadName)s, %(process)d:%(thread)8d] %(message)s&#x27;</span></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=FORMAT)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">n</span>):</span></span><br><span class="line">    logging.info(<span class="string">&#x27;begin to work-&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.info(<span class="string">&#x27;finished &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建线程池，池容量为3</span></span><br><span class="line">    executer = futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        future = executer.submit(worker, i)</span><br><span class="line">        fs.append(future)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">6</span>):</span><br><span class="line">        future = executer.submit(worker, i)</span><br><span class="line">        fs.append(future)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        logging.info(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> fs: <span class="comment"># 判断是否还有未完成的任务</span></span><br><span class="line">            logging.info(f.done())</span><br><span class="line">            flag = flag <span class="keyword">and</span> f.done()</span><br><span class="line">            <span class="comment"># if not flag: # 注释了这个if，输出的日志看的清楚些</span></span><br><span class="line">            <span class="comment"># break</span></span><br><span class="line">            </span><br><span class="line">        print(<span class="string">&#x27;-&#x27;</span> * <span class="number">30</span>)</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            executer.shutdown()</span><br><span class="line">            logging.info(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 线程池一旦创建了线程，就不需要频繁清除</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="threadpool-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出格式定义</span></span><br><span class="line">FORMAT = <span class="string">&#x27;%(asctime)-15s\t [%(processName)s:%(threadName)s, %(process)d:%(thread)8d] %(message)s&#x27;</span></span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=FORMAT)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">n</span>):</span></span><br><span class="line">    logging.info(<span class="string">&#x27;begin to work-&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    logging.info(<span class="string">&#x27;finished &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建线程池，池容量为3</span></span><br><span class="line">    executer = futures.ProcessPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        future = executer.submit(worker, i)</span><br><span class="line">        fs.append(future)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">6</span>):</span><br><span class="line">        future = executer.submit(worker, i)</span><br><span class="line">        fs.append(future)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        logging.info(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> fs: <span class="comment"># 判断是否还有未完成的任务</span></span><br><span class="line">            logging.info(f.done())</span><br><span class="line">            flag = flag <span class="keyword">and</span> f.done()</span><br><span class="line">            <span class="comment"># if not flag: # 注释了这个if，输出的日志看的清楚些</span></span><br><span class="line">                <span class="comment"># break</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">&#x27;-&#x27;</span> * <span class="number">30</span>)</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            executer.shutdown() <span class="comment"># 清理池。除非不用了，否则不用频繁清理池</span></span><br><span class="line">            logging.info(threading.<span class="built_in">enumerate</span>())<span class="comment"># 多进程时看主线程已没有必要了</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div></div></div>
<p>支持上下文管理：ProcessPoolExecutor继承自Executor，其实现了__enter__ 、__exit__方法，支持上下文管理。可以使用with语句。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">1</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    future = executor.submit(<span class="built_in">pow</span>, <span class="number">323</span>, <span class="number">1235</span>)</span><br><span class="line">    print(future.result())</span><br></pre></td></tr></table></figure><br>总结：<br>可以对任务设置一个超时检测使用<code>done()</code>判断，如果超过时间没有结束，那么应该给它关闭，让另一个任务进来。<br>池中异常也应该定时查看，如果池中有异常且不查看，那么池效率下降，池可能没办反重复利用，导致池失效。</p>
<p>注意：这个池，出现异常，Future不会挂掉，也不会向主程序抛出异常，使用enumerate()或者active_count()查看池内Future数，这个数不能看出有没有异常挂掉的Future。</p>
<p>该库统一了线程池、进程池调用，简化了编程。是Python简单的思想哲学的体现。<br>唯一的缺点：无法设置线程名称。但这都不值一提。</p>
<h2 id="joblib"><a href="#joblib" class="headerlink" title="joblib"></a>joblib</h2><p>Joblib是一个可以将Python代码转换为并行计算模式的包，可以大大简化我们写并行计算代码的步骤。我们可以通过操作该包内的函数来实现目标代码的并行计算，从而提高代码运行效率。下面举一个简单的例子来说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> joblib <span class="keyword">import</span> Parallel, delayed</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;a:输入参数&quot;&quot;&quot;</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 休眠1s</span></span><br><span class="line">    print(a)       <span class="comment"># 打印出a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环执行10次，大概10秒</span></span><br><span class="line">start = time.time()  <span class="comment"># 记录开始的时间</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):  <span class="comment"># 执行10次single()函数</span></span><br><span class="line">    single(i)</span><br><span class="line">Time = time.time() - start  <span class="comment"># 计算执行的时间</span></span><br><span class="line">print(<span class="built_in">str</span>(Time)+<span class="string">&#x27;s&#x27;</span>) <span class="comment"># 10.0172s</span></span><br></pre></td></tr></table></figure><br>使用joblib库里的Parallel函数及delayed函数来对执行10次single()函数的操作实现并行化处理。</p>
<p>Parallel函数会创建一个进程池，以便在多进程中执行每一个列表项，函数中，我们设置参数n_jobs=3，即开启三个进程。函数delayed是一个创建元组<code>(function, args, kwargs)</code>的简单技巧，下面代码中的意思是创建10个实参分别为0~9的single()函数的workers。代码及结果如下，可见运行时间相比顺序执行大大减小。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start = time.time()  <span class="comment"># 记录开始的时间</span></span><br><span class="line">Parallel(n_jobs=<span class="number">3</span>)(delayed(single)(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))   <span class="comment"># 并行化处理</span></span><br><span class="line">Time = time.time() - start  <span class="comment"># 计算执行的时间</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">str</span>(Time)+<span class="string">&#x27;s&#x27;</span>) <span class="comment"># 3.78s</span></span><br></pre></td></tr></table></figure><br>由于进程切换等操作的时间开销，最终的执行时间并不是理想的3.33s，而是大于一个3.33s的时间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">joblib.parallel(n_jobs=<span class="literal">None</span>, backend=<span class="literal">None</span>, verbose=<span class="number">0</span>, timeout=<span class="literal">None</span>, pre_dispatch=<span class="string">&#x27;2 * n_jobs&#x27;</span>, </span><br><span class="line">                batch_size=<span class="string">&#x27;auto&#x27;</span>,temp_folder=<span class="literal">None</span>, max_nbytes=<span class="string">&#x27;1M&#x27;</span>, mmap_mode=<span class="string">&#x27;r&#x27;</span>, prefer=<span class="literal">None</span>, require=<span class="literal">None</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">n_jobs: &#123;int, default: None&#125;，设置并行执行任务的最大数量，n_jobs=-1表示系统自己调整最合适的数量。</span></span><br><span class="line"><span class="string">backend: &#123;str,  default: &#x27;loky&#x27;&#125;，指定并行化后端的实现方法。</span></span><br><span class="line"><span class="string">verbose: int, 执行期间的信息显示。非零，则打印进度消息。超过50，输出被发送到stdout。消息的频率随着信息级别的增加而增加。如果大于10，则报告所有迭代。</span></span><br><span class="line"><span class="string">timeout: float, 任务运行时间限制。</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>除了并行计算功能外，Joblib还具有以下功能：<br>（1）快速磁盘缓存：Python函数的memoize或make-like功能，适用于任意Python对象，包括大型numpy数组。<br>（2）快速压缩：替代pickle，使用joblib.dump和joblib.load可以提高大数据的读取和存储效率。</p>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\09\Python\00.Python-pdb\" rel="bookmark">Python-pdb调试器</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\13\Python\03.Python-字符串\" rel="bookmark">Python-字符串</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\11\Python\01.Python-基础语法\" rel="bookmark">Python-基础语法</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\14\Python\04.Python-集合\" rel="bookmark">Python-集合</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2019\01\12\Python\02.Python-列表、元组\" rel="bookmark">Python-列表、元组</a></div>
    </li>
  </ul>


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>SoundMemories
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://soundmemories.github.io/2019/02/03/Python/16.Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/" title="Python-多线程和多进程">https://soundmemories.github.io/2019/02/03/Python/16.Python-多线程和多进程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"><i class="fa fa-tag"></i> Python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/02/01/Python/15.Python-%E5%BC%82%E5%B8%B8/" rel="prev" title="Python-异常">
                  <i class="fa fa-chevron-left"></i> Python-异常
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/02/05/Python/18.Python-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="next" title="Python-网络编程">
                  Python-网络编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SoundMemories</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  




  <script src="/js/local-search.js"></script>








<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  const url = element.dataset.target;
  const pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  const pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  const fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script data-pjax>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>





  








    <div class="pjax">
  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://soundmemories.github.io/2019/02/03/Python/16.Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/',]
      });
      });
  </script>

    </div>
</body>
</html>
