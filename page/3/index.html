<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"soundmemories.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.17.1","exturl":true,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="今日事，今日毕">
<meta property="og:type" content="website">
<meta property="og:title" content="SoundMemories">
<meta property="og:url" content="https://soundmemories.github.io/page/3/index.html">
<meta property="og:site_name" content="SoundMemories">
<meta property="og:description" content="今日事，今日毕">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SoundMemories">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://soundmemories.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SoundMemories</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SoundMemories</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">9</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">126</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SoundMemories"
      src="/images/avstar.png">
  <p class="site-author-name" itemprop="name">SoundMemories</p>
  <div class="site-description" itemprop="description">今日事，今日毕</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">126</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NvdW5kbWVtb3JpZXM=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soundmemories"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnNvdW5kbWVtb3JpZXNAMTYzLmNvbQ==" title="E-Mail → mailto:soundmemories@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2021/06/15/NLP/00.%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/15/NLP/00.%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">手动实现+部分源码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-15 00:00:00" itemprop="dateCreated datePublished" datetime="2021-06-15T00:00:00+08:00">2021-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="dropout">dropout</h1>
<div class="tabs" id="one"><ul class="nav-tabs"><li class="tab active"><a href="#one-1">dropout</a></li><li class="tab"><a href="#one-2">R-Drop</a></li></ul><div class="tab-content"><div class="tab-pane active" id="one-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础dropout</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">rate, x, w1, b1, w2, b2</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    rate: dropout概率</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    layer1 = np.maximum(<span class="number">0</span>, np.dot(w1, x)+b1) <span class="comment"># maximum作为relu替代</span></span><br><span class="line">    mask1 = np.random.binomial(<span class="number">1</span>, <span class="number">1</span>-rate, layer1.shape) <span class="comment"># 二项分布，试验次数1，成功概率1-rate，形状同layer1</span></span><br><span class="line">    layer1 = layer1 * mask1</span><br><span class="line"></span><br><span class="line">    layer2 = np.maximum(<span class="number">0</span>, np.dot(w2, layer1)+b2) </span><br><span class="line">    mask2 = np.random.binomial(<span class="number">1</span>, <span class="number">1</span>-rate, layer2.shape) </span><br><span class="line">    layer2 = layer2 * mask2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> layer2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">rate, x, w1, b1, w2, b2</span>):</span><br><span class="line">    layer1 = np.maximum(<span class="number">0</span>, np.dot(w1, x)+b1) </span><br><span class="line">    layer1 = layer1 * (<span class="number">1</span>-rate) <span class="comment"># 保证测试和训练期望一致，需要乘以1-rate</span></span><br><span class="line"></span><br><span class="line">    layer2 = np.maximum(<span class="number">0</span>, np.dot(w2, layer1)+b2) </span><br><span class="line">    layer2 = layer2 * (<span class="number">1</span>-rate)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> layer2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">another_train</span>(<span class="params">rate, x, w1, b1, w2, b2</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    rate: dropout概率</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    layer1 = np.maximum(<span class="number">0</span>, np.dot(w1, x)+b1) <span class="comment"># maximum作为relu替代</span></span><br><span class="line">    mask1 = np.random.binomial(<span class="number">1</span>, <span class="number">1</span>-rate, layer1.shape) <span class="comment"># 二项分布，试验次数1，成功概率1-rate，形状同layer1</span></span><br><span class="line">    layer1 = layer1 * mask1</span><br><span class="line">    layer1 = layer1/(<span class="number">1</span>-rate) <span class="comment"># 把测试阶段的计算挪到训练，减少测试计算量</span></span><br><span class="line"></span><br><span class="line">    layer2 = np.maximum(<span class="number">0</span>, np.dot(w2, layer1)+b2) </span><br><span class="line">    mask2 = np.random.binomial(<span class="number">1</span>, <span class="number">1</span>-rate, layer2.shape) </span><br><span class="line">    layer2 = layer2 * mask2</span><br><span class="line">    layer2 = layer2/(<span class="number">1</span>-rate)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> layer2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">another_test</span>(<span class="params">rate, x, w1, b1, w2, b2</span>):</span><br><span class="line">    layer1 = np.maximum(<span class="number">0</span>, np.dot(w1, x)+b1) </span><br><span class="line">    layer2 = np.maximum(<span class="number">0</span>, np.dot(w2, layer1)+b2) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> layer2</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="one-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/dropreg/R-Drop</span></span><br><span class="line"><span class="comment"># https://spaces.ac.cn/archives/8496</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># define your task model, which outputs the classifier logits</span></span><br><span class="line">model = TaskModel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_kl_loss</span>(<span class="params">p, q pad_mask=<span class="literal">None</span></span>):</span><br><span class="line">    p_loss = F.kl_div(F.log_softmax(p, dim=-<span class="number">1</span>), F.softmax(q, dim=-<span class="number">1</span>), reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    q_loss = F.kl_div(F.log_softmax(q, dim=-<span class="number">1</span>), F.softmax(p, dim=-<span class="number">1</span>), reduction=<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># pad_mask is for seq-level tasks</span></span><br><span class="line">    <span class="keyword">if</span> pad_mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        p_loss.masked_fill_(pad_mask, <span class="number">0.</span>)</span><br><span class="line">        q_loss.masked_fill_(pad_mask, <span class="number">0.</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># You can choose whether to use function &quot;sum&quot; and &quot;mean&quot; depending on your task</span></span><br><span class="line">    p_loss = p_loss.<span class="built_in">sum</span>()</span><br><span class="line">    q_loss = q_loss.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">    loss = (p_loss + q_loss) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># keep dropout and forward twice</span></span><br><span class="line">logits = model(x)</span><br><span class="line"></span><br><span class="line">logits2 = model(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cross entropy loss for classifier</span></span><br><span class="line">ce_loss = <span class="number">0.5</span> * (cross_entropy_loss(logits, label) + cross_entropy_loss(logits2, label))</span><br><span class="line"></span><br><span class="line">kl_loss = compute_kl_loss(logits, logits2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># carefully choose hyper-parameters</span></span><br><span class="line">loss = ce_loss + α * kl_loss</span><br></pre></td></tr></table></figure></div></div></div>
<h1 id="算子融合">算子融合</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RepVGG的算子融合</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">point-wise: 通道融合, 抛弃局部关联性。</span></span><br><span class="line"><span class="string">depth-wise: 局部关联性，抛弃通道融合。</span></span><br><span class="line"><span class="string">普通卷积可看成：depth-wise + 1*1 point-wise</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line">in_channels = <span class="number">2</span></span><br><span class="line">ou_channels = <span class="number">2</span></span><br><span class="line">kernel_size = <span class="number">3</span></span><br><span class="line">w = <span class="number">9</span></span><br><span class="line">h = <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># res_block = 3*3 conv + 1*1 conv + input</span></span><br><span class="line">x = torch.ones(<span class="number">1</span>, in_channels, w, h) <span class="comment"># 输入图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.原生方法</span></span><br><span class="line">t1 = time.time()</span><br><span class="line">conv_2d = nn.Conv2d(in_channels, ou_channels, kernel_size, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">conv_2d_pointwise = nn.Conv2d(in_channels, ou_channels, <span class="number">1</span>)</span><br><span class="line">result1 = conv_2d(x) + conv_2d_pointwise(x) + x</span><br><span class="line">t2 = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.算子融合</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">point-wise卷积-&gt;3*3</span></span><br><span class="line"><span class="string">x-&gt;3*3</span></span><br><span class="line"><span class="string">3个卷积-&gt;1个卷积</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># point-wise卷积-&gt;2*2*3*3</span></span><br><span class="line"><span class="comment"># pad: 左右上下前后内外，这里只pad 1*1 的左右上下</span></span><br><span class="line">pointwise_to_conv_weight = F.pad(conv_2d_pointwise.weight, [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]) <span class="comment"># 2*2*1*1-&gt;2*2*3*3</span></span><br><span class="line">conv_2d_for_pointwise = nn.Conv2d(in_channels, ou_channels, kernel_size, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">conv_2d_for_pointwise.weight = nn.Parameter(pointwise_to_conv_weight)</span><br><span class="line">conv_2d_for_pointwise.bias = conv_2d_pointwise.bias</span><br><span class="line"></span><br><span class="line"><span class="comment"># x-&gt;2*2*3*3 </span></span><br><span class="line">zeros = torch.unsqueeze(torch.zeros(kernel_size, kernel_size), <span class="number">0</span>)</span><br><span class="line">stars = torch.unsqueeze(F.pad(torch.ones(<span class="number">1</span>, <span class="number">1</span>), [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]), <span class="number">0</span>)</span><br><span class="line">stars_zeros = torch.unsqueeze(torch.cat([stars, zeros], <span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line">zeros_stars = torch.unsqueeze(torch.cat([zeros, stars], <span class="number">0</span>), <span class="number">0</span>)</span><br><span class="line">identity_to_conv_weight = torch.cat([stars_zeros, zeros_stars], <span class="number">0</span>)</span><br><span class="line">identity_to_conv_bias = torch.zeros([ou_channels]) </span><br><span class="line">conv_2d_for_identity = nn.Conv2d(in_channels, ou_channels, kernel_size, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">conv_2d_for_identity.weight = nn.Parameter(identity_to_conv_weight)</span><br><span class="line">conv_2d_for_identity.bias = nn.Parameter(identity_to_conv_bias)</span><br><span class="line"></span><br><span class="line">result2 = conv_2d(x) + conv_2d_for_pointwise(x) + conv_2d_for_identity(x)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.isclose(result1, result2)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor(True)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 融合</span></span><br><span class="line">t3 = time.time()</span><br><span class="line">conv_2d_for_fusion = nn.Conv2d(in_channels, ou_channels, kernel_size, padding=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">conv_2d_for_fusion.weight = nn.Parameter(conv_2d.weight.data +</span><br><span class="line">                                         conv_2d_for_pointwise.weight.data +</span><br><span class="line">                                         conv_2d_for_identity.weight.data)</span><br><span class="line">conv_2d_for_fusion.bias = nn.Parameter(conv_2d.bias.data +</span><br><span class="line">                                         conv_2d_for_pointwise.bias.data +</span><br><span class="line">                                         conv_2d_for_identity.bias.data)</span><br><span class="line">result3 = conv_2d_for_fusion(x)</span><br><span class="line">t4 = time.time()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">all</span>(torch.isclose(result2, result3)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;原生写法耗时:&#x27;</span>, t2-t1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;融合算子耗时:&#x27;</span>, t4-t3)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor(True)</span></span><br><span class="line"><span class="string">原生写法耗时: 0.7473533153533936</span></span><br><span class="line"><span class="string">原生写法耗时: 0.0010013580322265625</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>ConvMixer 使用了算子融合：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/locuslab/convmixer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ConvMixer</span>(<span class="params">h, depth, kernel_size=<span class="number">9</span>, patch_size=<span class="number">7</span>, n_classes=<span class="number">1000</span></span>):</span><br><span class="line">    Seq, ActBn = nn.Sequential, <span class="keyword">lambda</span> x: Seq(x, nn.GELU(), nn.BatchNorm2d(h))</span><br><span class="line">    Residual = <span class="built_in">type</span>(<span class="string">&#x27;Residual&#x27;</span>, (Seq,), &#123;<span class="string">&#x27;forward&#x27;</span>: <span class="keyword">lambda</span> self, x: self[<span class="number">0</span>](x) + x&#125;)</span><br><span class="line">    <span class="keyword">return</span> Seq(ActBn(nn.Conv2d(<span class="number">3</span>, h, patch_size, stride=patch_size)),</span><br><span class="line">           *[Seq(Residual(ActBn(nn.Conv2d(h, h, kernel_size, groups=h, padding=<span class="string">&quot;same&quot;</span>))),</span><br><span class="line">                ActBn(nn.Conv2d(h, h, <span class="number">1</span>))) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(depth)],</span><br><span class="line">            nn.AdaptiveAvgPool2d((<span class="number">1</span>,<span class="number">1</span>)), nn.Flatten(), nn.Linear(h, n_classes))</span><br></pre></td></tr></table></figure></p>
<h1 id="transformer">Transformer</h1>
<p>seq2seq基础模块分类：<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- CNN</span><br><span class="line"> - 权重共享</span><br><span class="line">    - 平移不变性</span><br><span class="line">    - 可并行计算</span><br><span class="line"> - 滑动窗口，局部关联性建模，依靠多层堆积来进行长程建模</span><br><span class="line"> - 对相对位置敏感，对绝对位置不敏感</span><br><span class="line"></span><br><span class="line">- RNN(依次有序递归建模)</span><br><span class="line"> - 对顺序敏感</span><br><span class="line"> - 串行计算耗时</span><br><span class="line"> - 长程建模能力弱</span><br><span class="line"> - 计算复杂度与序列长度呈线性关系</span><br><span class="line"> - 单步计算复杂度不变</span><br><span class="line"> - 对相对位置、绝对位置都敏感</span><br><span class="line"></span><br><span class="line">- transformer</span><br><span class="line"> - 无局部假设</span><br><span class="line">    - 可并行计算</span><br><span class="line">    - 对相对位置不敏感</span><br><span class="line"> - 无有序假设</span><br><span class="line">    - 需要位置编码来反映位置变化对特征的影响</span><br><span class="line">    - 对绝对位置不敏感</span><br><span class="line">- 任意两字符都可建模</span><br><span class="line">    - 擅长长短程建模</span><br><span class="line">    - 自注意力机制需要序列长度的平方级别复杂度</span><br><span class="line">- 总结特点：</span><br><span class="line">    - 无先验假设(例如: 局部关联性、有序建模性)</span><br><span class="line">    - 核心计算在于自注意力机制，平方复杂度n^2*d</span><br><span class="line">    - 数据量的要求与先验假设的程度成反比(数据量少，需要注入的先验假设越多，比如对loss和多头的改进假设)</span><br><span class="line">- 使用类型：</span><br><span class="line">    - Encoder only：Bert、分类任务、非流式任务</span><br><span class="line">    - Decoder only：GPT系列、语言建模、自回归生成任务、流式任务</span><br><span class="line">    - Encoder-Decoder：机器翻译、语音识别</span><br></pre></td></tr></table></figure><br />
Transformer结构：<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- Transformer</span><br><span class="line"> - Encoder</span><br><span class="line">    - input word embedding: 由稀疏的one-hot进入一个不带bias的FFN得到一个稠密的连续向量。</span><br><span class="line">    - position encoding: </span><br><span class="line">        - 通过sin/cos来固定表征：每个位置确定性的; 对于不同长度的句子，两个词相对位置的距离一致; 可以推广到更长的测试句子。</span><br><span class="line">        - pe(pos+k)可以写成pe(pos)的线性组合。</span><br><span class="line">        - 通过残差连接来使得位置信息流入深层。</span><br><span class="line">    - multi-head self-attention</span><br><span class="line">        - 使得建模能力更强，表征空间更丰富。</span><br><span class="line">        - 由多个QKV构成，每组单独计算一个attention向量。</span><br><span class="line">        - 把每组的attention向量拼起来，并入一个不带bias的FFN得到最终的向量。</span><br><span class="line">    - feed-forward network</span><br><span class="line">        - 只考虑embedding的每个维度进行建模。</span><br><span class="line">        - 不同位置参数共享。</span><br><span class="line">        - 类似1*1 point-wise convolution。</span><br><span class="line"> - Decoder</span><br><span class="line">  - output word embedding</span><br><span class="line">  - position encoding</span><br><span class="line">  - mask multi-head self-attention</span><br><span class="line">  - multi-head cross-attention</span><br><span class="line">  - feed-forward network</span><br><span class="line">  - softmax</span><br></pre></td></tr></table></figure><br />
Transformer Pytorch源码：<br />
补充阅读：<span class="exturl" data-url="aHR0cHM6Ly9ubHAuc2Vhcy5oYXJ2YXJkLmVkdS8yMDE4LzA0LzAzL2F0dGVudGlvbi5odG1s">The
Annotated Transformer<i class="fa fa-external-link-alt"></i></span><br />
<div class="tabs" id="tr"><ul class="nav-tabs"><li class="tab active"><a href="#tr-1">Transformer</a></li><li class="tab"><a href="#tr-2">Encoder/Decoder</a></li><li class="tab"><a href="#tr-3">EncoderLayer/DecoderLayer</a></li><li class="tab"><a href="#tr-4">MultiheadAttention</a></li><li class="tab"><a href="#tr-5">Solution 3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tr-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Transformer</span>(<span class="title class_ inherited__">Module</span>):</span><br><span class="line">    <span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">     Examples::</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; transformer_model = nn.Transformer(nhead=16, num_encoder_layers=12)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; src = torch.rand((10, 32, 512))</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; tgt = torch.rand((20, 32, 512))</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; out = transformer_model(src, tgt)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                d_model: <span class="built_in">int</span> = <span class="number">512</span>,  <span class="comment"># 模型维度</span></span></span><br><span class="line"><span class="params">                nhead: <span class="built_in">int</span> = <span class="number">8</span>,  <span class="comment"># 多头注意力层数</span></span></span><br><span class="line"><span class="params">                num_encoder_layers: <span class="built_in">int</span> = <span class="number">6</span>, <span class="comment"># encoder block数</span></span></span><br><span class="line"><span class="params">                num_decoder_layers: <span class="built_in">int</span> = <span class="number">6</span>, <span class="comment"># decoder block数</span></span></span><br><span class="line"><span class="params">                dim_feedforward: <span class="built_in">int</span> = <span class="number">2048</span>, <span class="comment"># FFN中间维度</span></span></span><br><span class="line"><span class="params">                dropout: <span class="built_in">float</span> = <span class="number">0.1</span>, <span class="comment"># 丢弃概率</span></span></span><br><span class="line"><span class="params">                activation: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="type">Callable</span>[[Tensor], Tensor]] = F.relu, <span class="comment"># 激活函数</span></span></span><br><span class="line"><span class="params">                custom_encoder: <span class="type">Optional</span>[<span class="type">Any</span>] = <span class="literal">None</span>, </span></span><br><span class="line"><span class="params">                custom_decoder: <span class="type">Optional</span>[<span class="type">Any</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                layer_norm_eps: <span class="built_in">float</span> = <span class="number">1e-5</span>, </span></span><br><span class="line"><span class="params">                batch_first: <span class="built_in">bool</span> = <span class="literal">False</span>,  <span class="comment"># batch在第0维？</span></span></span><br><span class="line"><span class="params">                norm_first: <span class="built_in">bool</span> = <span class="literal">False</span>, </span></span><br><span class="line"><span class="params">                device=<span class="literal">None</span>, </span></span><br><span class="line"><span class="params">                dtype=<span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            factory_kwargs = &#123;<span class="string">&#x27;device&#x27;</span>: device, <span class="string">&#x27;dtype&#x27;</span>: dtype&#125;</span><br><span class="line">            <span class="built_in">super</span>(Transformer, self).__init__()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> custom_encoder <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.encoder = custom_encoder</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># EncoderLayer</span></span><br><span class="line">                encoder_layer = TransformerEncoderLayer(d_model, nhead, dim_feedforward, dropout,</span><br><span class="line">                                                        activation, layer_norm_eps, batch_first, norm_first,</span><br><span class="line">                                                        **factory_kwargs)</span><br><span class="line">                encoder_norm = LayerNorm(d_model, eps=layer_norm_eps, **factory_kwargs)</span><br><span class="line">                <span class="comment"># Encoder block</span></span><br><span class="line">                self.encoder = TransformerEncoder(encoder_layer, num_encoder_layers, encoder_norm)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> custom_decoder <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self.decoder = custom_decoder</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># DecoderLayer</span></span><br><span class="line">                decoder_layer = TransformerDecoderLayer(d_model, nhead, dim_feedforward, dropout,</span><br><span class="line">                                                        activation, layer_norm_eps, batch_first, norm_first,</span><br><span class="line">                                                        **factory_kwargs)</span><br><span class="line">                decoder_norm = LayerNorm(d_model, eps=layer_norm_eps, **factory_kwargs)</span><br><span class="line">                <span class="comment"># Decoder block</span></span><br><span class="line">                self.decoder = TransformerDecoder(decoder_layer, num_decoder_layers, decoder_norm)</span><br><span class="line">            ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                src: Tensor,  <span class="comment"># 源</span></span></span><br><span class="line"><span class="params">                tgt: Tensor,  <span class="comment"># 目标</span></span></span><br><span class="line"><span class="params">                src_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,  <span class="comment"># 源的mask(通过mask能还原原本句子)</span></span></span><br><span class="line"><span class="params">                tgt_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,  <span class="comment"># 目标的mask</span></span></span><br><span class="line"><span class="params">                memory_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, <span class="comment"># encoder输出mask</span></span></span><br><span class="line"><span class="params">                src_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                tgt_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, </span></span><br><span class="line"><span class="params">                memory_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">                </span>) -&gt; Tensor:</span><br><span class="line">        <span class="string">r&quot;&quot;&quot;Take in and process masked source/target sequences.</span></span><br><span class="line"><span class="string">        Shape:</span></span><br><span class="line"><span class="string">            - src: :math:`(S, N, E)`, `(N, S, E)` if batch_first.</span></span><br><span class="line"><span class="string">            - tgt: :math:`(T, N, E)`, `(N, T, E)` if batch_first.</span></span><br><span class="line"><span class="string">            - src_mask: :math:`(S, S)`.</span></span><br><span class="line"><span class="string">            - tgt_mask: :math:`(T, T)`.</span></span><br><span class="line"><span class="string">            - memory_mask: :math:`(T, S)`.</span></span><br><span class="line"><span class="string">            - src_key_padding_mask: :math:`(N, S)`.</span></span><br><span class="line"><span class="string">            - tgt_key_padding_mask: :math:`(N, T)`.</span></span><br><span class="line"><span class="string">            - memory_key_padding_mask: :math:`(N, S)`.</span></span><br><span class="line"><span class="string">        - output: :math:`(T, N, E)`, `(N, T, E)` if batch_first.</span></span><br><span class="line"><span class="string">        Examples:</span></span><br><span class="line"><span class="string">            &gt;&gt;&gt; output = transformer_model(src, tgt, src_mask=src_mask, tgt_mask=tgt_mask)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 调用encoder和decoder得到结果</span></span><br><span class="line">        memory = self.encoder(src, mask=src_mask, src_key_padding_mask=src_key_padding_mask)</span><br><span class="line">        output = self.decoder(tgt, memory, tgt_mask=tgt_mask, memory_mask=memory_mask,</span><br><span class="line">                              tgt_key_padding_mask=tgt_key_padding_mask,</span><br><span class="line">                              memory_key_padding_mask=memory_key_padding_mask)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tr-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerEncoder</span>(<span class="title class_ inherited__">Module</span>):</span><br><span class="line">    <span class="string">r&quot;&quot;&quot;TransformerEncoder is a stack of N encoder layers</span></span><br><span class="line"><span class="string">    Examples::</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; encoder_layer = nn.TransformerEncoderLayer(d_model=512, nhead=8)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; transformer_encoder = nn.TransformerEncoder(encoder_layer, num_layers=6)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; src = torch.rand(10, 32, 512)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; out = transformer_encoder(src)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __constants__ = [<span class="string">&#x27;norm&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                 encoder_layer, <span class="comment"># 定义的encoder block</span></span></span><br><span class="line"><span class="params">                 num_layers, <span class="comment"># block数</span></span></span><br><span class="line"><span class="params">                 norm=<span class="literal">None</span> <span class="comment"># normalization方法</span></span></span><br><span class="line"><span class="params">                 </span>):</span><br><span class="line">        <span class="built_in">super</span>(TransformerEncoder, self).__init__()</span><br><span class="line">        self.layers = _get_clones(encoder_layer, num_layers)</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        self.norm = norm</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                src: Tensor,  <span class="comment"># 源</span></span></span><br><span class="line"><span class="params">                mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, <span class="comment"># 源的mask(通过mask能还原原本句子)</span></span></span><br><span class="line"><span class="params">                src_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">                </span>) -&gt; Tensor:</span><br><span class="line">        <span class="string">r&quot;&quot;&quot;Pass the input through the encoder layers in turn.&quot;&quot;&quot;</span></span><br><span class="line">        output = src</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> mod <span class="keyword">in</span> self.layers:</span><br><span class="line">            output = mod(output, src_mask=mask, src_key_padding_mask=src_key_padding_mask)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.norm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output = self.norm(output)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerDecoder</span>(<span class="title class_ inherited__">Module</span>):</span><br><span class="line">    <span class="string">r&quot;&quot;&quot;TransformerDecoder is a stack of N decoder layers</span></span><br><span class="line"><span class="string">    Examples::</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; decoder_layer = nn.TransformerDecoderLayer(d_model=512, nhead=8)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; transformer_decoder = nn.TransformerDecoder(decoder_layer, num_layers=6)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; memory = torch.rand(10, 32, 512)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; tgt = torch.rand(20, 32, 512)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; out = transformer_decoder(tgt, memory)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __constants__ = [<span class="string">&#x27;norm&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                 decoder_layer, <span class="comment"># # 定义的decoder block</span></span></span><br><span class="line"><span class="params">                 num_layers,  <span class="comment"># block数</span></span></span><br><span class="line"><span class="params">                 norm=<span class="literal">None</span> <span class="comment"># normalization方法</span></span></span><br><span class="line"><span class="params">                 </span>):</span><br><span class="line">        <span class="built_in">super</span>(TransformerDecoder, self).__init__()</span><br><span class="line">        self.layers = _get_clones(decoder_layer, num_layers)</span><br><span class="line">        self.num_layers = num_layers</span><br><span class="line">        self.norm = norm</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                tgt: Tensor, <span class="comment"># 目标</span></span></span><br><span class="line"><span class="params">                memory: Tensor, <span class="comment"># encoder输出(最后一层)</span></span></span><br><span class="line"><span class="params">                tgt_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, <span class="comment"># 目标的mask</span></span></span><br><span class="line"><span class="params">                memory_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, <span class="comment"># encoder输出mask</span></span></span><br><span class="line"><span class="params">                tgt_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                memory_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">                </span>) -&gt; Tensor:</span><br><span class="line">        <span class="string">r&quot;&quot;&quot;Pass the inputs (and mask) through the decoder layer in turn.&quot;&quot;&quot;</span></span><br><span class="line">        output = tgt</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> mod <span class="keyword">in</span> self.layers:</span><br><span class="line">            output = mod(output, memory, tgt_mask=tgt_mask,</span><br><span class="line">                         memory_mask=memory_mask,</span><br><span class="line">                         tgt_key_padding_mask=tgt_key_padding_mask,</span><br><span class="line">                         memory_key_padding_mask=memory_key_padding_mask)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.norm <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output = self.norm(output)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tr-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerEncoderLayer</span>(<span class="title class_ inherited__">Module</span>):</span><br><span class="line">    <span class="string">r&quot;&quot;&quot;TransformerEncoderLayer is made up of self-attn and feedforward network.</span></span><br><span class="line"><span class="string">    Examples::</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; encoder_layer = nn.TransformerEncoderLayer(d_model=512, nhead=8)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; src = torch.rand(10, 32, 512)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; out = encoder_layer(src)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Alternatively, when ``batch_first`` is ``True``:</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; encoder_layer = nn.TransformerEncoderLayer(d_model=512, nhead=8, batch_first=True)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; src = torch.rand(32, 10, 512)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; out = encoder_layer(src)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __constants__ = [<span class="string">&#x27;batch_first&#x27;</span>, <span class="string">&#x27;norm_first&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                 d_model, <span class="comment"># 模型维度</span></span></span><br><span class="line"><span class="params">                 nhead, <span class="comment"># 头数</span></span></span><br><span class="line"><span class="params">                 dim_feedforward=<span class="number">2048</span>, <span class="comment"># FFN中间维度</span></span></span><br><span class="line"><span class="params">                 dropout=<span class="number">0.1</span>, </span></span><br><span class="line"><span class="params">                 activation=F.relu,</span></span><br><span class="line"><span class="params">                 layer_norm_eps=<span class="number">1e-5</span>, </span></span><br><span class="line"><span class="params">                 batch_first=<span class="literal">False</span>, </span></span><br><span class="line"><span class="params">                 norm_first=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 device=<span class="literal">None</span>, </span></span><br><span class="line"><span class="params">                 dtype=<span class="literal">None</span></span></span><br><span class="line"><span class="params">                 </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        factory_kwargs = &#123;<span class="string">&#x27;device&#x27;</span>: device, <span class="string">&#x27;dtype&#x27;</span>: dtype&#125;</span><br><span class="line">        <span class="built_in">super</span>(TransformerEncoderLayer, self).__init__()</span><br><span class="line">        self.self_attn = MultiheadAttention(d_model, nhead, dropout=dropout, batch_first=batch_first,</span><br><span class="line">                                            **factory_kwargs)</span><br><span class="line">        <span class="comment"># Implementation of Feedforward model</span></span><br><span class="line">        self.linear1 = Linear(d_model, dim_feedforward, **factory_kwargs) <span class="comment"># 先投射到2048维</span></span><br><span class="line">        self.dropout = Dropout(dropout) </span><br><span class="line">        self.linear2 = Linear(dim_feedforward, d_model, **factory_kwargs) <span class="comment"># 再投射到521维</span></span><br><span class="line"></span><br><span class="line">        self.norm_first = norm_first</span><br><span class="line">        self.norm1 = LayerNorm(d_model, eps=layer_norm_eps, **factory_kwargs)</span><br><span class="line">        self.norm2 = LayerNorm(d_model, eps=layer_norm_eps, **factory_kwargs)</span><br><span class="line">        self.dropout1 = Dropout(dropout)</span><br><span class="line">        self.dropout2 = Dropout(dropout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Legacy string support for activation function.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(activation, <span class="built_in">str</span>):</span><br><span class="line">            self.activation = _get_activation_fn(activation)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.activation = activation</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setstate__</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;activation&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> state:</span><br><span class="line">            state[<span class="string">&#x27;activation&#x27;</span>] = F.relu</span><br><span class="line">        <span class="built_in">super</span>(TransformerEncoderLayer, self).__setstate__(state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                src: Tensor, <span class="comment"># 源</span></span></span><br><span class="line"><span class="params">                src_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, <span class="comment"># 源mask</span></span></span><br><span class="line"><span class="params">                src_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">                </span>) -&gt; Tensor:</span><br><span class="line">        <span class="string">r&quot;&quot;&quot;Pass the input through the encoder layer.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># see Fig. 1 of https://arxiv.org/pdf/2002.04745v1.pdf</span></span><br><span class="line"></span><br><span class="line">        x = src</span><br><span class="line">        <span class="keyword">if</span> self.norm_first:</span><br><span class="line">            x = x + self._sa_block(self.norm1(x), src_mask, src_key_padding_mask)</span><br><span class="line">            x = x + self._ff_block(self.norm2(x))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># norm(x + self-attention block) -&gt; norm(x + feed forward block), 注意，此时的x是前面的输出</span></span><br><span class="line">            x = self.norm1(x + self._sa_block(x, src_mask, src_key_padding_mask))</span><br><span class="line">            x = self.norm2(x + self._ff_block(x))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># self-attention block</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_sa_block</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                  x: Tensor,</span></span><br><span class="line"><span class="params">                  attn_mask: <span class="type">Optional</span>[Tensor], </span></span><br><span class="line"><span class="params">                  key_padding_mask: <span class="type">Optional</span>[Tensor]</span></span><br><span class="line"><span class="params">                  </span>) -&gt; Tensor:</span><br><span class="line">        x = self.self_attn(x, x, x,</span><br><span class="line">                           attn_mask=attn_mask,</span><br><span class="line">                           key_padding_mask=key_padding_mask,</span><br><span class="line">                           need_weights=<span class="literal">False</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> self.dropout1(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># feed forward block</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_ff_block</span>(<span class="params">self, x: Tensor</span>) -&gt; Tensor:</span><br><span class="line">        x = self.linear2(self.dropout(self.activation(self.linear1(x))))</span><br><span class="line">        <span class="keyword">return</span> self.dropout2(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerDecoderLayer</span>(<span class="title class_ inherited__">Module</span>):</span><br><span class="line">    <span class="string">r&quot;&quot;&quot;TransformerDecoderLayer is made up of self-attn, multi-head-attn and feedforward network.</span></span><br><span class="line"><span class="string">    Examples::</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; decoder_layer = nn.TransformerDecoderLayer(d_model=512, nhead=8)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; memory = torch.rand(10, 32, 512)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; tgt = torch.rand(20, 32, 512)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; out = decoder_layer(tgt, memory)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Alternatively, when ``batch_first`` is ``True``:</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; decoder_layer = nn.TransformerDecoderLayer(d_model=512, nhead=8, batch_first=True)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; memory = torch.rand(32, 10, 512)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; tgt = torch.rand(32, 20, 512)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; out = decoder_layer(tgt, memory)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __constants__ = [<span class="string">&#x27;batch_first&#x27;</span>, <span class="string">&#x27;norm_first&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                 d_model, </span></span><br><span class="line"><span class="params">                 nhead, </span></span><br><span class="line"><span class="params">                 dim_feedforward=<span class="number">2048</span>, </span></span><br><span class="line"><span class="params">                 dropout=<span class="number">0.1</span>, </span></span><br><span class="line"><span class="params">                 activation=F.relu,</span></span><br><span class="line"><span class="params">                 layer_norm_eps=<span class="number">1e-5</span>, </span></span><br><span class="line"><span class="params">                 batch_first=<span class="literal">False</span>, </span></span><br><span class="line"><span class="params">                 norm_first=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 device=<span class="literal">None</span>, </span></span><br><span class="line"><span class="params">                 dtype=<span class="literal">None</span></span></span><br><span class="line"><span class="params">                 </span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        factory_kwargs = &#123;<span class="string">&#x27;device&#x27;</span>: device, <span class="string">&#x27;dtype&#x27;</span>: dtype&#125;</span><br><span class="line">        <span class="built_in">super</span>(TransformerDecoderLayer, self).__init__()</span><br><span class="line">        <span class="comment"># 2个多头注意力，一个self-attention，一个cross-attention</span></span><br><span class="line">        self.self_attn = MultiheadAttention(d_model, nhead, dropout=dropout, batch_first=batch_first,</span><br><span class="line">                                            **factory_kwargs)</span><br><span class="line">        self.multihead_attn = MultiheadAttention(d_model, nhead, dropout=dropout, batch_first=batch_first,</span><br><span class="line">                                                 **factory_kwargs)</span><br><span class="line">        <span class="comment"># Implementation of Feedforward model</span></span><br><span class="line">        self.linear1 = Linear(d_model, dim_feedforward, **factory_kwargs)</span><br><span class="line">        self.dropout = Dropout(dropout)</span><br><span class="line">        self.linear2 = Linear(dim_feedforward, d_model, **factory_kwargs)</span><br><span class="line"></span><br><span class="line">        self.norm_first = norm_first</span><br><span class="line">        self.norm1 = LayerNorm(d_model, eps=layer_norm_eps, **factory_kwargs)</span><br><span class="line">        self.norm2 = LayerNorm(d_model, eps=layer_norm_eps, **factory_kwargs)</span><br><span class="line">        self.norm3 = LayerNorm(d_model, eps=layer_norm_eps, **factory_kwargs)</span><br><span class="line">        self.dropout1 = Dropout(dropout)</span><br><span class="line">        self.dropout2 = Dropout(dropout)</span><br><span class="line">        self.dropout3 = Dropout(dropout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Legacy string support for activation function.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(activation, <span class="built_in">str</span>):</span><br><span class="line">            self.activation = _get_activation_fn(activation)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.activation = activation</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setstate__</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;activation&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> state:</span><br><span class="line">            state[<span class="string">&#x27;activation&#x27;</span>] = F.relu</span><br><span class="line">        <span class="built_in">super</span>(TransformerDecoderLayer, self).__setstate__(state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, </span></span><br><span class="line"><span class="params">                tgt: Tensor, </span></span><br><span class="line"><span class="params">                memory: Tensor, </span></span><br><span class="line"><span class="params">                tgt_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, </span></span><br><span class="line"><span class="params">                memory_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                tgt_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>, </span></span><br><span class="line"><span class="params">                memory_key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">                </span>) -&gt; Tensor:</span><br><span class="line">        <span class="string">r&quot;&quot;&quot;Pass the inputs (and mask) through the decoder layer.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            tgt: the sequence to the decoder layer (required).</span></span><br><span class="line"><span class="string">            memory: the sequence from the last layer of the encoder (required).</span></span><br><span class="line"><span class="string">            tgt_mask: the mask for the tgt sequence (optional).</span></span><br><span class="line"><span class="string">            memory_mask: the mask for the memory sequence (optional).</span></span><br><span class="line"><span class="string">            tgt_key_padding_mask: the mask for the tgt keys per batch (optional).</span></span><br><span class="line"><span class="string">            memory_key_padding_mask: the mask for the memory keys per batch (optional).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># see Fig. 1 of https://arxiv.org/pdf/2002.04745v1.pdf</span></span><br><span class="line"></span><br><span class="line">        x = tgt</span><br><span class="line">        <span class="keyword">if</span> self.norm_first:</span><br><span class="line">            x = x + self._sa_block(self.norm1(x), tgt_mask, tgt_key_padding_mask)</span><br><span class="line">            x = x + self._mha_block(self.norm2(x), memory, memory_mask, memory_key_padding_mask)</span><br><span class="line">            x = x + self._ff_block(self.norm3(x))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 先self-attention</span></span><br><span class="line">            x = self.norm1(x + self._sa_block(x, tgt_mask, tgt_key_padding_mask))</span><br><span class="line">            <span class="comment"># 再cross-attention</span></span><br><span class="line">            x = self.norm2(x + self._mha_block(x, memory, memory_mask, memory_key_padding_mask))</span><br><span class="line">            <span class="comment"># 再FFN</span></span><br><span class="line">            x = self.norm3(x + self._ff_block(x))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># self-attention block</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_sa_block</span>(<span class="params">self, x: Tensor,</span></span><br><span class="line"><span class="params">                  attn_mask: <span class="type">Optional</span>[Tensor], key_padding_mask: <span class="type">Optional</span>[Tensor]</span>) -&gt; Tensor:</span><br><span class="line">        x = self.self_attn(x, x, x,</span><br><span class="line">                           attn_mask=attn_mask,</span><br><span class="line">                           key_padding_mask=key_padding_mask,</span><br><span class="line">                           need_weights=<span class="literal">False</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> self.dropout1(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># multihead attention block</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_mha_block</span>(<span class="params">self, x: Tensor, mem: Tensor,</span></span><br><span class="line"><span class="params">                   attn_mask: <span class="type">Optional</span>[Tensor], key_padding_mask: <span class="type">Optional</span>[Tensor]</span>) -&gt; Tensor:</span><br><span class="line">        x = self.multihead_attn(x, mem, mem,</span><br><span class="line">                                attn_mask=attn_mask,</span><br><span class="line">                                key_padding_mask=key_padding_mask,</span><br><span class="line">                                need_weights=<span class="literal">False</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> self.dropout2(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># feed forward block</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_ff_block</span>(<span class="params">self, x: Tensor</span>) -&gt; Tensor:</span><br><span class="line">        x = self.linear2(self.dropout(self.activation(self.linear1(x))))</span><br><span class="line">        <span class="keyword">return</span> self.dropout3(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_clones</span>(<span class="params">module, N</span>):</span><br><span class="line">    <span class="keyword">return</span> ModuleList([copy.deepcopy(module) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_activation_fn</span>(<span class="params">activation</span>):</span><br><span class="line">    <span class="keyword">if</span> activation == <span class="string">&quot;relu&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> F.relu</span><br><span class="line">    <span class="keyword">elif</span> activation == <span class="string">&quot;gelu&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> F.gelu</span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;activation should be relu/gelu, not &#123;&#125;&quot;</span>.<span class="built_in">format</span>(activation))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tr-4"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MultiheadAttention</span>(<span class="title class_ inherited__">Module</span>):</span><br><span class="line">    <span class="string">r&quot;&quot;&quot;Allows the model to jointly attend to information from different representation subspaces.</span></span><br><span class="line"><span class="string">    Examples::</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; multihead_attn = nn.MultiheadAttention(embed_dim, num_heads)</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; attn_output, attn_output_weights = multihead_attn(query, key, value)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __constants__ = [<span class="string">&#x27;batch_first&#x27;</span>]</span><br><span class="line">    bias_k: <span class="type">Optional</span>[torch.Tensor]</span><br><span class="line">    bias_v: <span class="type">Optional</span>[torch.Tensor]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embed_dim, num_heads, dropout=<span class="number">0.</span>, bias=<span class="literal">True</span>, add_bias_kv=<span class="literal">False</span>, add_zero_attn=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 kdim=<span class="literal">None</span>, vdim=<span class="literal">None</span>, batch_first=<span class="literal">False</span>, device=<span class="literal">None</span>, dtype=<span class="literal">None</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        factory_kwargs = &#123;<span class="string">&#x27;device&#x27;</span>: device, <span class="string">&#x27;dtype&#x27;</span>: dtype&#125;</span><br><span class="line">        <span class="built_in">super</span>(MultiheadAttention, self).__init__()</span><br><span class="line">        self.embed_dim = embed_dim</span><br><span class="line">        self.kdim = kdim <span class="keyword">if</span> kdim <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> embed_dim</span><br><span class="line">        self.vdim = vdim <span class="keyword">if</span> vdim <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> embed_dim</span><br><span class="line">        self._qkv_same_embed_dim = self.kdim == embed_dim <span class="keyword">and</span> self.vdim == embed_dim</span><br><span class="line"></span><br><span class="line">        self.num_heads = num_heads</span><br><span class="line">        self.dropout = dropout</span><br><span class="line">        self.batch_first = batch_first</span><br><span class="line">        self.head_dim = embed_dim // num_heads</span><br><span class="line">        <span class="keyword">assert</span> self.head_dim * num_heads == self.embed_dim, <span class="string">&quot;embed_dim must be divisible by num_heads&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._qkv_same_embed_dim <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            self.q_proj_weight = Parameter(torch.empty((embed_dim, embed_dim), **factory_kwargs))</span><br><span class="line">            self.k_proj_weight = Parameter(torch.empty((embed_dim, self.kdim), **factory_kwargs))</span><br><span class="line">            self.v_proj_weight = Parameter(torch.empty((embed_dim, self.vdim), **factory_kwargs))</span><br><span class="line">            self.register_parameter(<span class="string">&#x27;in_proj_weight&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.in_proj_weight = Parameter(torch.empty((<span class="number">3</span> * embed_dim, embed_dim), **factory_kwargs))</span><br><span class="line">            self.register_parameter(<span class="string">&#x27;q_proj_weight&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">            self.register_parameter(<span class="string">&#x27;k_proj_weight&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">            self.register_parameter(<span class="string">&#x27;v_proj_weight&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> bias:</span><br><span class="line">            self.in_proj_bias = Parameter(torch.empty(<span class="number">3</span> * embed_dim, **factory_kwargs))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.register_parameter(<span class="string">&#x27;in_proj_bias&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        self.out_proj = NonDynamicallyQuantizableLinear(embed_dim, embed_dim, bias=bias, **factory_kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> add_bias_kv:</span><br><span class="line">            self.bias_k = Parameter(torch.empty((<span class="number">1</span>, <span class="number">1</span>, embed_dim), **factory_kwargs))</span><br><span class="line">            self.bias_v = Parameter(torch.empty((<span class="number">1</span>, <span class="number">1</span>, embed_dim), **factory_kwargs))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.bias_k = self.bias_v = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        self.add_zero_attn = add_zero_attn</span><br><span class="line"></span><br><span class="line">        self._reset_parameters()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_reset_parameters</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._qkv_same_embed_dim:</span><br><span class="line">            xavier_uniform_(self.in_proj_weight)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xavier_uniform_(self.q_proj_weight)</span><br><span class="line">            xavier_uniform_(self.k_proj_weight)</span><br><span class="line">            xavier_uniform_(self.v_proj_weight)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.in_proj_bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            constant_(self.in_proj_bias, <span class="number">0.</span>)</span><br><span class="line">            constant_(self.out_proj.bias, <span class="number">0.</span>)</span><br><span class="line">        <span class="keyword">if</span> self.bias_k <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            xavier_normal_(self.bias_k)</span><br><span class="line">        <span class="keyword">if</span> self.bias_v <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            xavier_normal_(self.bias_v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setstate__</span>(<span class="params">self, state</span>):</span><br><span class="line">        <span class="comment"># Support loading old MultiheadAttention checkpoints generated by v1.1.0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;_qkv_same_embed_dim&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> state:</span><br><span class="line">            state[<span class="string">&#x27;_qkv_same_embed_dim&#x27;</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(MultiheadAttention, self).__setstate__(state)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, query: Tensor, key: Tensor, value: Tensor, key_padding_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                need_weights: <span class="built_in">bool</span> = <span class="literal">True</span>, attn_mask: <span class="type">Optional</span>[Tensor] = <span class="literal">None</span></span>) -&gt; <span class="type">Tuple</span>[Tensor, <span class="type">Optional</span>[Tensor]]:</span><br><span class="line">        <span class="keyword">if</span> self.batch_first:</span><br><span class="line">            query, key, value = [x.transpose(<span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> x <span class="keyword">in</span> (query, key, value)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._qkv_same_embed_dim:</span><br><span class="line">            attn_output, attn_output_weights = F.multi_head_attention_forward(</span><br><span class="line">                query, key, value, self.embed_dim, self.num_heads,</span><br><span class="line">                self.in_proj_weight, self.in_proj_bias,</span><br><span class="line">                self.bias_k, self.bias_v, self.add_zero_attn,</span><br><span class="line">                self.dropout, self.out_proj.weight, self.out_proj.bias,</span><br><span class="line">                training=self.training,</span><br><span class="line">                key_padding_mask=key_padding_mask, need_weights=need_weights,</span><br><span class="line">                attn_mask=attn_mask, use_separate_proj_weight=<span class="literal">True</span>,</span><br><span class="line">                q_proj_weight=self.q_proj_weight, k_proj_weight=self.k_proj_weight,</span><br><span class="line">                v_proj_weight=self.v_proj_weight)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            attn_output, attn_output_weights = F.multi_head_attention_forward(</span><br><span class="line">                query, key, value, self.embed_dim, self.num_heads,</span><br><span class="line">                self.in_proj_weight, self.in_proj_bias,</span><br><span class="line">                self.bias_k, self.bias_v, self.add_zero_attn,</span><br><span class="line">                self.dropout, self.out_proj.weight, self.out_proj.bias,</span><br><span class="line">                training=self.training,</span><br><span class="line">                key_padding_mask=key_padding_mask, need_weights=need_weights,</span><br><span class="line">                attn_mask=attn_mask)</span><br><span class="line">        <span class="keyword">if</span> self.batch_first:</span><br><span class="line">            <span class="keyword">return</span> attn_output.transpose(<span class="number">1</span>, <span class="number">0</span>), attn_output_weights</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> attn_output, attn_output_weights</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tr-5"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></div></div></p>
<h1 id="参考资料">参考资料</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuam1sci5vcmcvcGFwZXJzL3ZvbHVtZTE1L3NyaXZhc3RhdmExNGEvc3JpdmFzdGF2YTE0YS5wZGY/dXRtX2NvbnRlbnQ9YnVmZmVyNzliNDMmdXRtX21lZGl1bT1zb2NpYWwmdXRtX3NvdXJjZT10d2l0dGVyLmNvbSZ1dG1fY2FtcGFpZ249YnVmZmVyLA==">Dropout:
A Simple Way to Prevent Neural Networks from Overfitting<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9wcm9jZWVkaW5ncy5uZXVyaXBzLmNjL3BhcGVyLzIwMjEvZmlsZS81YTY2YjkyMDBmMjlhYzNmYTBhZTI0NGNjMmE1MWIzOS1QYXBlci5wZGY=">R-Drop:
Regularized Dropout for Neural Networks<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzIxMDEuMDM2OTcucGRm">RepVGG: Making VGG-style
ConvNets Great Again<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi41M3l1LmNvbS9wZGYvMjIwMS4wOTc5Mi5wZGY=">Patches Are All You
Need?<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MDYuMDM3NjIucGRm">Attention Is All You
Need<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2021/06/13/NLP/00.TensorFlow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/13/NLP/00.TensorFlow/" class="post-title-link" itemprop="url">TensorFlow2.0</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-13 00:00:00" itemprop="dateCreated datePublished" datetime="2021-06-13T00:00:00+08:00">2021-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>TensorFlow程序 = 张量数据结构 +
计算图算法语言，<strong>张量</strong>和<strong>计算图</strong>是TensorFlow的核心概念。<br />
Tensorflow的基本数据结构是张量Tensor，张量即多维数组，这和numpy中的array很类似。从行为特性来看，有两种类型的张量，常量constant和变量Variable。常量的值在计算图中不可以被重新赋值，变量可以在计算图中用assign等算子重新赋值。</p>
<h1 id="常量张量">常量张量</h1>
<p>张量的数据类型和numpy.array基本一一对应。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">i = tf.constant(<span class="number">1</span>) <span class="comment"># tf.int32 </span></span><br><span class="line">l = tf.constant(<span class="number">1</span>, dtype=tf.int64) <span class="comment"># tf.int64 </span></span><br><span class="line">f = tf.constant(<span class="number">1.23</span>) <span class="comment">#tf.float32 </span></span><br><span class="line">d = tf.constant(<span class="number">3.14</span>, dtype=tf.double) <span class="comment"># tf.double </span></span><br><span class="line">s = tf.constant(<span class="string">&quot;hello world&quot;</span>) <span class="comment"># tf.string</span></span><br><span class="line">b = tf.constant(<span class="literal">True</span>) <span class="comment">#tf.bool</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tf.int64 == np.int64) </span><br><span class="line"><span class="built_in">print</span>(tf.<span class="built_in">bool</span> == np.<span class="built_in">bool</span>)</span><br><span class="line"><span class="built_in">print</span>(tf.double == np.float64)</span><br><span class="line"><span class="built_in">print</span>(tf.string == np.unicode) <span class="comment"># tf.string类型和np.unicode类型不等价</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 可以用tf.cast改变张量的数据类型。</span></span><br><span class="line">h = tf.constant([<span class="number">123</span>,<span class="number">456</span>], dtype=tf.int32)</span><br><span class="line">f = tf.cast(h, tf.float32)</span><br><span class="line"><span class="built_in">print</span>(h.dtype, f.dtype)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;dtype: &#x27;int32&#x27;&gt; &lt;dtype: &#x27;float32&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 可以用numpy方法将tensorflow中的张量转化成numpy中的张量。</span></span><br><span class="line"><span class="comment"># 可以用shape方法查看张量的尺寸。</span></span><br><span class="line">y = tf.constant([[<span class="number">1.0</span>,<span class="number">2.0</span>],[<span class="number">3.0</span>,<span class="number">4.0</span>]])</span><br><span class="line"><span class="built_in">print</span>(y.numpy()) <span class="comment">#转换成np.array</span></span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[1. 2.]</span></span><br><span class="line"><span class="string"> [3. 4.]]</span></span><br><span class="line"><span class="string">(2, 2)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 不同类型的数据可以用不同维度(rank)的张量来表示。</span></span><br><span class="line">vector = tf.constant([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>]) <span class="comment">#向量，1维张量</span></span><br><span class="line"><span class="built_in">print</span>(tf.rank(vector))</span><br><span class="line"><span class="built_in">print</span>(vector.numpy().ndim) <span class="comment"># tf.rank的作用和numpy的ndim方法相同</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tf.Tensor(1, shape=(), dtype=int32)</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 字符串解码</span></span><br><span class="line">u = tf.constant(<span class="string">u&quot;你好 世界&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(u.numpy())  </span><br><span class="line"><span class="built_in">print</span>(u.numpy().decode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd \xe4\xb8\x96\xe7\x95\x8c&#x27;</span></span><br><span class="line"><span class="string">你好 世界</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="变量张量">变量张量</h1>
<p>模型中需要被训练的参数一般被设置成变量。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常量值不可以改变，常量的重新赋值相当于创造新的内存空间</span></span><br><span class="line">c = tf.constant([<span class="number">1.0</span>,<span class="number">2.0</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(c))</span><br><span class="line">c = c + tf.constant([<span class="number">1.0</span>,<span class="number">1.0</span>])</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(c))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tf.Tensor([1. 2.], shape=(2,), dtype=float32)</span></span><br><span class="line"><span class="string">5276289568</span></span><br><span class="line"><span class="string">tf.Tensor([2. 3.], shape=(2,), dtype=float32)</span></span><br><span class="line"><span class="string">5276290240</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 变量的值可以改变，可以通过assign, assign_add等方法给变量重新赋值</span></span><br><span class="line">v = tf.Variable([<span class="number">1.0</span>,<span class="number">2.0</span>],name = <span class="string">&quot;v&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v))</span><br><span class="line">v.assign_add([<span class="number">1.0</span>,<span class="number">1.0</span>])</span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(v))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;tf.Variable &#x27;v:0&#x27; shape=(2,) dtype=float32, numpy=array([1., 2.], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">5276259888</span></span><br><span class="line"><span class="string">&lt;tf.Variable &#x27;v:0&#x27; shape=(2,) dtype=float32, numpy=array([2., 3.], dtype=float32)&gt;</span></span><br><span class="line"><span class="string">5276259888</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="计算图">计算图</h1>
<p>TensorFlow有静态计算图，动态计算图，以及Autograph。<br />
在TensorFlow1.0时代，采用的是静态计算图，需要先使用TensorFlow的各种算子创建计算图，然后再开启一个会话Session，显式执行计算图。<br />
在TensorFlow2.0时代，采用的是动态计算图，即每使用一个算子后，该算子会被动态加入到隐含的默认计算图中立即执行得到结果，而无需开启Session。<br />
使用动态计算图即Eager
Excution的好处是方便调试程序，它会让TensorFlow代码的表现和Python原生代码的表现一样，写起来就像写numpy一样，各种日志打印，控制流全部都是可以使用的。缺点是运行效率相对会低一些。因为使用动态图会有许多次Python进程和TensorFlow的C++进程之间的通信。而静态计算图构建完成之后几乎全部在TensorFlow内核上使用C++代码执行，效率更高。此外静态图会对计算步骤进行一定的优化，剪去和结果无关的计算步骤。</p>
<p>如果需要在TensorFlow2.0中使用静态图，可以使用@tf.function装饰器将普通Python函数转换成对应的TensorFlow计算图构建代码。运行该函数就相当于在TensorFlow1.0中用Session执行代码。使用tf.function构建静态图的方式叫做
Autograph.</p>
<p><strong>计算图构成</strong>：<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">计算图由节点(nodes)和线(edges)组成。</span><br><span class="line">节点：表示操作符Operator，或者称为算子，线表示计算间的依赖。</span><br><span class="line">实线表示有数据传递依赖，传递的数据即张量。虚线通常可以表示控制依赖，即执行先后顺序。</span><br></pre></td></tr></table></figure><br />
<img
src="https://lyhue1991.github.io/eat_tensorflow2_in_30_days/data/strjoin_graph.png" /></p>
<p><strong>静态计算图</strong><br />
在TensorFlow1.0中，使用静态计算图分两步，第一步定义计算图，第二步在会话中执行计算图。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义计算图</span></span><br><span class="line">g = tf.Graph()</span><br><span class="line"><span class="keyword">with</span> g.as_default():</span><br><span class="line">    <span class="comment">#placeholder为占位符，执行会话时候指定填充对象</span></span><br><span class="line">    x = tf.placeholder(name=<span class="string">&#x27;x&#x27;</span>, shape=[], dtype=tf.string)  </span><br><span class="line">    y = tf.placeholder(name=<span class="string">&#x27;y&#x27;</span>, shape=[], dtype=tf.string)</span><br><span class="line">    z = tf.string_join([x,y],name = <span class="string">&#x27;join&#x27;</span>,separator=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行计算图</span></span><br><span class="line"><span class="keyword">with</span> tf.Session(graph = g) <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="built_in">print</span>(sess.run(fetches = z,feed_dict = &#123;x:<span class="string">&quot;hello&quot;</span>,y:<span class="string">&quot;world&quot;</span>&#125;))</span><br></pre></td></tr></table></figure><br />
TensorFlow2.0为了确保对老版本tensorflow项目的兼容性，在tf.compat.v1子模块中保留了对TensorFlow1.0那种静态计算图构建风格的支持。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">g = tf.compat.v1.Graph()</span><br><span class="line"><span class="keyword">with</span> g.as_default():</span><br><span class="line">    x = tf.compat.v1.placeholder(name=<span class="string">&#x27;x&#x27;</span>, shape=[], dtype=tf.string)</span><br><span class="line">    y = tf.compat.v1.placeholder(name=<span class="string">&#x27;y&#x27;</span>, shape=[], dtype=tf.string)</span><br><span class="line">    z = tf.strings.join([x,y],name = <span class="string">&quot;join&quot;</span>,separator = <span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.compat.v1.Session(graph = g) <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment"># fetches的结果非常像一个函数的返回值，而feed_dict中的占位符相当于函数的参数序列。</span></span><br><span class="line">    result = sess.run(fetches = z,feed_dict = &#123;x:<span class="string">&quot;hello&quot;</span>,y:<span class="string">&quot;world&quot;</span>&#125;)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">b&#x27;hello world&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br />
<strong>动态计算图</strong><br />
TensorFlow2.0中，使用的是<strong>动态计算图</strong>和<strong>Autograph</strong>。<br />
动态计算图已经不区分计算图的定义和执行了，而是定义后立即执行。因此称之为
Eager
Excution。Eager这个英文单词的原意是"迫不及待的"，也就是立即执行的意思。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 动态计算图在每个算子处都进行构建，构建后立即执行</span></span><br><span class="line">x = tf.constant(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">y = tf.constant(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">z = tf.strings.join([x,y],separator=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">tf.<span class="built_in">print</span>(z)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 可以将动态计算图代码的输入和输出关系封装成函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strjoin</span>(<span class="params">x,y</span>):</span><br><span class="line">    z =  tf.strings.join([x,y],separator = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    tf.<span class="built_in">print</span>(z)</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">result = strjoin(tf.constant(<span class="string">&quot;hello&quot;</span>),tf.constant(<span class="string">&quot;world&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">tf.Tensor(b&#x27;hello world&#x27;, shape=(), dtype=string)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br />
<strong>Autograph</strong><br />
在TensorFlow2.0中，动态计算图运行效率相对较低，可以用@tf.function装饰器将普通Python函数转换成和TensorFlow1.0对应的静态计算图构建代码。如果采用Autograph的方式使用计算图，第一步定义计算图变成了定义函数，第二步执行计算图变成了调用函数。不需要使用会话了，一些都像原始的Python语法一样自然。<br />
实践中，一般会先用动态计算图调试代码，然后在需要提高性能的的地方利用@tf.function切换成Autograph获得更高的效率。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用autograph构建静态图</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strjoin</span>(<span class="params">x,y</span>):</span><br><span class="line">    z =  tf.strings.join([x,y],separator = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    tf.<span class="built_in">print</span>(z)</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">result = strjoin(tf.constant(<span class="string">&quot;hello&quot;</span>),tf.constant(<span class="string">&quot;world&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">hello world</span></span><br><span class="line"><span class="string">tf.Tensor(b&#x27;hello world&#x27;, shape=(), dtype=string)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建日志</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">stamp = datetime.datetime.now().strftime(<span class="string">&quot;%Y%m%d-%H%M%S&quot;</span>)</span><br><span class="line">logdir = os.path.join(<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;autograph&#x27;</span>, stamp)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 在 Python3 下建议使用 pathlib 修正各操作系统的路径</span></span><br><span class="line"><span class="comment"># from pathlib import Path</span></span><br><span class="line"><span class="comment"># stamp = datetime.datetime.now().strftime(&quot;%Y%m%d-%H%M%S&quot;)</span></span><br><span class="line"><span class="comment"># logdir = str(Path(&#x27;../../data/autograph/&#x27; + stamp))</span></span><br><span class="line"></span><br><span class="line">writer = tf.summary.create_file_writer(logdir)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启autograph跟踪</span></span><br><span class="line">tf.summary.trace_on(graph=<span class="literal">True</span>, profiler=<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#执行autograph</span></span><br><span class="line">result = strjoin(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将计算图信息写入日志</span></span><br><span class="line"><span class="keyword">with</span> writer.as_default():</span><br><span class="line">    tf.summary.trace_export(</span><br><span class="line">        name=<span class="string">&quot;autograph&quot;</span>,</span><br><span class="line">        step=<span class="number">0</span>,</span><br><span class="line">        profiler_outdir=logdir)</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动 tensorboard在jupyter中的魔法命令</span></span><br><span class="line">%load_ext tensorboard</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动tensorboard</span></span><br><span class="line">%tensorboard --logdir ../../data/autograph/</span><br></pre></td></tr></table></figure></p>
<h1 id="自动微分">自动微分</h1>
<p>Tensorflow一般使用梯度磁带tf.GradientTape来记录正向运算过程，然后反播磁带自动得到梯度值。这种利用tf.GradientTape求微分的方法叫做Tensorflow的自动微分机制。<br />
<div class="tabs" id="one"><ul class="nav-tabs"><li class="tab active"><a href="#one-1">利用梯度磁带求导数</a></li><li class="tab"><a href="#one-2">利用梯度磁带和优化器求最小值</a></li></ul><div class="tab-content"><div class="tab-pane active" id="one-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = a*x**2 + b*x + c的导数</span></span><br><span class="line">x = tf.Variable(<span class="number">0.0</span>,name=<span class="string">&quot;x&quot;</span>,dtype=tf.float32)</span><br><span class="line">a = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">b = tf.constant(-<span class="number">2.0</span>)</span><br><span class="line">c = tf.constant(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    y = a*tf.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line"></span><br><span class="line">dy_dx = tape.gradient(y,x)</span><br><span class="line"><span class="built_in">print</span>(dy_dx)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tf.Tensor(-2.0, shape=(), dtype=float32)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 对常量张量也可以求导，需要增加watch</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    tape.watch([a,b,c])</span><br><span class="line">    y = a*tf.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line"></span><br><span class="line">dy_dx,dy_da,dy_db,dy_dc = tape.gradient(y,[x,a,b,c])</span><br><span class="line"><span class="built_in">print</span>(dy_da)</span><br><span class="line"><span class="built_in">print</span>(dy_dc)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tf.Tensor(0.0, shape=(), dtype=float32)</span></span><br><span class="line"><span class="string">tf.Tensor(1.0, shape=(), dtype=float32)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 可以求二阶导数</span></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape2:</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape1:   </span><br><span class="line">        y = a*tf.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line">    dy_dx = tape1.gradient(y,x)   </span><br><span class="line">dy2_dx2 = tape2.gradient(dy_dx,x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dy2_dx2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tf.Tensor(2.0, shape=(), dtype=float32)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 可以在autograph中使用</span></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):   </span><br><span class="line">    a = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">    b = tf.constant(-<span class="number">2.0</span>)</span><br><span class="line">    c = tf.constant(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自变量x转换成tf.float32</span></span><br><span class="line">    x = tf.cast(x,tf.float32)</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        tape.watch(x)</span><br><span class="line">        y = a*tf.<span class="built_in">pow</span>(x,<span class="number">2</span>)+b*x+c</span><br><span class="line">    dy_dx = tape.gradient(y,x) </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>((dy_dx,y))</span><br><span class="line"></span><br><span class="line">tf.<span class="built_in">print</span>(f(tf.constant(<span class="number">0.0</span>)))</span><br><span class="line">tf.<span class="built_in">print</span>(f(tf.constant(<span class="number">1.0</span>)))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(-2, 1)</span></span><br><span class="line"><span class="string">(0, 0)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="one-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求f(x) = a*x**2 + b*x + c的最小值</span></span><br><span class="line"><span class="comment"># 使用optimizer.apply_gradients</span></span><br><span class="line">x = tf.Variable(<span class="number">0.0</span>,name = <span class="string">&quot;x&quot;</span>,dtype = tf.float32)</span><br><span class="line">a = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">b = tf.constant(-<span class="number">2.0</span>)</span><br><span class="line">c = tf.constant(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">optimizer = tf.keras.optimizers.SGD(learning_rate=<span class="number">0.01</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        y = a*tf.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line">    dy_dx = tape.gradient(y,x)</span><br><span class="line">    optimizer.apply_gradients(grads_and_vars=[(dy_dx,x)])</span><br><span class="line"></span><br><span class="line">tf.<span class="built_in">print</span>(<span class="string">&quot;y =&quot;</span>,y,<span class="string">&quot;; x =&quot;</span>,x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">y = 0 ; x = 0.999998569</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 求f(x) = a*x**2 + b*x + c的最小值</span></span><br><span class="line"><span class="comment"># 使用optimizer.minimize</span></span><br><span class="line"><span class="comment"># optimizer.minimize相当于先用tape求gradient,再apply_gradient</span></span><br><span class="line">x = tf.Variable(<span class="number">0.0</span>,name = <span class="string">&quot;x&quot;</span>,dtype = tf.float32)</span><br><span class="line"><span class="comment">#注意f()无参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():   </span><br><span class="line">    a = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">    b = tf.constant(-<span class="number">2.0</span>)</span><br><span class="line">    c = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">    y = a*tf.<span class="built_in">pow</span>(x,<span class="number">2</span>)+b*x+c</span><br><span class="line">    <span class="keyword">return</span>(y)</span><br><span class="line"></span><br><span class="line">optimizer = tf.keras.optimizers.SGD(learning_rate=<span class="number">0.01</span>)   </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    optimizer.minimize(f,[x])   </span><br><span class="line"></span><br><span class="line">tf.<span class="built_in">print</span>(<span class="string">&quot;y =&quot;</span>,f(),<span class="string">&quot;; x =&quot;</span>,x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">y = 0 ; x = 0.999998569</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 在autograph中完成最小值求解</span></span><br><span class="line"><span class="comment"># 使用optimizer.apply_gradients</span></span><br><span class="line">x = tf.Variable(<span class="number">0.0</span>,name = <span class="string">&quot;x&quot;</span>,dtype = tf.float32)</span><br><span class="line">optimizer = tf.keras.optimizers.SGD(learning_rate=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minimizef</span>():</span><br><span class="line">    a = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">    b = tf.constant(-<span class="number">2.0</span>)</span><br><span class="line">    c = tf.constant(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> tf.<span class="built_in">range</span>(<span class="number">1000</span>): <span class="comment">#注意autograph时使用tf.range(1000)而不是range(1000)</span></span><br><span class="line">        <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">            y = a*tf.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line">        dy_dx = tape.gradient(y,x)</span><br><span class="line">        optimizer.apply_gradients(grads_and_vars=[(dy_dx,x)])</span><br><span class="line"></span><br><span class="line">    y = a*tf.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">tf.<span class="built_in">print</span>(minimizef())</span><br><span class="line">tf.<span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">0.999998569</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 在autograph中完成最小值求解</span></span><br><span class="line"><span class="comment"># 使用optimizer.minimize</span></span><br><span class="line">x = tf.Variable(<span class="number">0.0</span>,name = <span class="string">&quot;x&quot;</span>,dtype = tf.float32)</span><br><span class="line">optimizer = tf.keras.optimizers.SGD(learning_rate=<span class="number">0.01</span>)   </span><br><span class="line"></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():   </span><br><span class="line">    a = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">    b = tf.constant(-<span class="number">2.0</span>)</span><br><span class="line">    c = tf.constant(<span class="number">1.0</span>)</span><br><span class="line">    y = a*tf.<span class="built_in">pow</span>(x,<span class="number">2</span>)+b*x+c</span><br><span class="line">    <span class="keyword">return</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch</span>):  </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> tf.<span class="built_in">range</span>(epoch):  </span><br><span class="line">        optimizer.minimize(f,[x])</span><br><span class="line">    <span class="keyword">return</span>(f())</span><br><span class="line"></span><br><span class="line">tf.<span class="built_in">print</span>(train(<span class="number">1000</span>))</span><br><span class="line">tf.<span class="built_in">print</span>(x)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">0.999998569</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<h1 id="参考资料">参考资料</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvdmVyc2lvbnMvcjIuMC9hcGlfZG9jcy9weXRob24vdGY=">TensorFlow官网<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aC12Mi5kMmwuYWkvY2hhcHRlcl9wcmVsaW1pbmFyaWVzL25kYXJyYXkuaHRtbA==">动手学深度学习<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9seWh1ZTE5OTEuZ2l0aHViLmlvL2VhdF90ZW5zb3JmbG93Ml9pbl8zMF9kYXlzL2NoaW5lc2UvMi4lRTYlQTAlQjglRTUlQkYlODMlRTYlQTYlODIlRTUlQkYlQjUvMi0xJTJDJUU1JUJDJUEwJUU5JTg3JThGJUU2JTk1JUIwJUU2JThEJUFFJUU3JUJCJTkzJUU2JTlFJTg0Lw==">30天吃掉那只Tensorflow2<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTI1NHkxQzdWTS8/c3BtX2lkX2Zyb209MzMzLjc4OA==">TensorFlow视频精讲<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2021/06/10/NLP/00.Pytorch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/10/NLP/00.Pytorch/" class="post-title-link" itemprop="url">Pytorch</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-10 00:00:00" itemprop="dateCreated datePublished" datetime="2021-06-10T00:00:00+08:00">2021-06-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:01</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="张量类型">张量类型</h1>
<p>张量的数据类型和numpy.array基本一一对应，但是不支持str类型。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">torch.float64/torch.double</span><br><span class="line">torch.float32/torch.<span class="built_in">float</span>  <span class="comment"># 一般神经网络建模使用的都是torch.float32类型。</span></span><br><span class="line">torch.float16</span><br><span class="line">torch.int64/torch.long</span><br><span class="line">torch.int32/torch.<span class="built_in">int</span></span><br><span class="line">torch.int16</span><br><span class="line">torch.int8</span><br><span class="line">torch.uint8</span><br><span class="line">torch.<span class="built_in">bool</span></span><br></pre></td></tr></table></figure></p>
<p>张量常用属性：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = torch.rand([<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">a.dtype <span class="comment"># 元素类型</span></span><br><span class="line">a.shape/size() <span class="comment"># 形状</span></span><br><span class="line">a.device <span class="comment"># 设备</span></span><br><span class="line"><span class="comment"># 不同类型的数据可以用不同维度(dimension)的张量来表示，一般有几层中括号，就是多少维的张量。</span></span><br><span class="line">a.dim()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动推断数据类型</span></span><br><span class="line">i = torch.tensor(<span class="number">1</span>); <span class="built_in">print</span>(i, i.dtype) <span class="comment"># type(i)是&lt;class &#x27;torch.Tensor&#x27;&gt;</span></span><br><span class="line">x = torch.tensor(<span class="number">2.0</span>); <span class="built_in">print</span>(x, x.dtype)</span><br><span class="line">b = torch.tensor(<span class="literal">True</span>); <span class="built_in">print</span>(b, b.dtype)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor(1) torch.int64</span></span><br><span class="line"><span class="string">tensor(2.) torch.float32</span></span><br><span class="line"><span class="string">tensor(True) torch.bool</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定数据类型</span></span><br><span class="line">i = torch.tensor(<span class="number">1</span>, dtype=torch.int32); <span class="built_in">print</span>(i, i.dtype)</span><br><span class="line">x = torch.tensor(<span class="number">2.0</span>, dtype=torch.double); <span class="built_in">print</span>(x, x.dtype)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor(1, dtype=torch.int32) torch.int32</span></span><br><span class="line"><span class="string">tensor(2., dtype=torch.float64) torch.float64</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用特定类型构造函数</span></span><br><span class="line">i = torch.IntTensor(<span class="number">1</span>); <span class="built_in">print</span>(i,i.dtype) <span class="comment"># 这里1是容量，不是数据</span></span><br><span class="line">x = torch.Tensor(np.array(<span class="number">2.0</span>)); <span class="built_in">print</span>(x,x.dtype) <span class="comment"># 等价于torch.FloatTensor</span></span><br><span class="line">b = torch.BoolTensor(np.array([<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>])); <span class="built_in">print</span>(b,b.dtype)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([5], dtype=torch.int32) torch.int32</span></span><br><span class="line"><span class="string">tensor(2.) torch.float32</span></span><br><span class="line"><span class="string">tensor([ True, False,  True, False]) torch.bool</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同类型进行转换</span></span><br><span class="line">i = torch.tensor(<span class="number">1</span>); <span class="built_in">print</span>(i,i.dtype)</span><br><span class="line">x = i.<span class="built_in">float</span>(); <span class="built_in">print</span>(x,x.dtype) <span class="comment"># 调用 float方法转换成浮点类型</span></span><br><span class="line">y = i.<span class="built_in">type</span>(torch.<span class="built_in">float</span>); <span class="built_in">print</span>(y,y.dtype) <span class="comment"># 使用type函数转换成浮点类型</span></span><br><span class="line">z = i.type_as(x);<span class="built_in">print</span>(z,z.dtype) <span class="comment"># 使用type_as方法转换成某个Tensor相同类型</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor(1) torch.int64</span></span><br><span class="line"><span class="string">tensor(1.) torch.float32</span></span><br><span class="line"><span class="string">tensor(1.) torch.float32</span></span><br><span class="line"><span class="string">tensor(1.) torch.float32</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="张量尺寸">张量尺寸</h1>
<p>可以使用shape属性或者size()方法查看张量在每一维的长度。<br />
可以使用view/reshape方法改变张量的尺寸，view需张量连续，reshape会重新复制一份数据，所以不需要数据连续。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shape/size()查看维度长度</span></span><br><span class="line">vector = torch.tensor([<span class="number">1.0</span>,<span class="number">2.0</span>,<span class="number">3.0</span>,<span class="number">4.0</span>])</span><br><span class="line"><span class="built_in">print</span>(vector.size())</span><br><span class="line"><span class="built_in">print</span>(vector.shape)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">torch.Size([4])</span></span><br><span class="line"><span class="string">torch.Size([4])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用view可以改变张量尺寸</span></span><br><span class="line">vector = torch.arange(<span class="number">0</span>,<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(vector)</span><br><span class="line"><span class="built_in">print</span>(vector.shape)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span></span><br><span class="line"><span class="string">torch.Size([12])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">matrix34 = vector.view(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(matrix34)</span><br><span class="line"><span class="built_in">print</span>(matrix34.shape)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">        [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">        [ 8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">torch.Size([3, 4])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有些操作会让张量存储结构扭曲(如：转置操作)，直接使用view会失败，可以用reshape方法</span></span><br><span class="line">matrix26 = torch.arange(<span class="number">0</span>,<span class="number">12</span>).view(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(matrix26)</span><br><span class="line"><span class="built_in">print</span>(matrix26.shape)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([[ 0,  1,  2,  3,  4,  5],</span></span><br><span class="line"><span class="string">        [ 6,  7,  8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">torch.Size([2, 6])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> </span><br><span class="line">matrix62 = matrix26.t() <span class="comment"># 转置操作让张量存储结构扭曲</span></span><br><span class="line"><span class="built_in">print</span>(matrix62.is_contiguous())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 直接使用view方法会失败，可以使用reshape方法</span></span><br><span class="line"><span class="comment">#matrix34 = matrix62.view(3,4) #error!</span></span><br><span class="line">matrix34 = matrix62.reshape(<span class="number">3</span>,<span class="number">4</span>) <span class="comment">#等价于matrix34 = matrix62.contiguous().view(3,4)</span></span><br><span class="line"><span class="built_in">print</span>(matrix34)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([[ 0,  6,  1,  7],</span></span><br><span class="line"><span class="string">        [ 2,  8,  3,  9],</span></span><br><span class="line"><span class="string">        [ 4, 10,  5, 11]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="张量和numpy数组">张量和numpy数组</h1>
<p>可以用numpy方法从Tensor得到numpy数组，也可以用torch.from_numpy从numpy数组得到Tensor。<strong>这两种方法关联的Tensor和numpy数组是共享数据内存的，如果改变其中一个，另外一个的值也会发生改变</strong>。如果有需要，可以用张量的clone方法拷贝张量，中断这种关联。<br />
此外，还可以使用item方法从标量张量得到对应的Python数值。使用tolist方法从张量得到对应的Python数值列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从numpy数组得到Tensor</span></span><br><span class="line">np_array = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">x_np = torch.from_numpy(np_array) </span><br><span class="line"><span class="built_in">print</span>(x_np)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([[1, 2],</span></span><br><span class="line"><span class="string">        [3, 4]], dtype=torch.int32)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 改变np_array，x_np也随之改变。</span></span><br><span class="line">np.add(np_array,<span class="number">1</span>,out= np_array)</span><br><span class="line"><span class="built_in">print</span>(x_np)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([[2, 3],</span></span><br><span class="line"><span class="string">        [4, 5]], dtype=torch.int32)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 同理x_np改变，np_array也会随之改变。</span></span><br><span class="line">x_np.add_(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(np_array)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[3 4]</span></span><br><span class="line"><span class="string"> [5 6]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 可以用 clone() 方法拷贝张量，独立中断这种关联，拷贝后的张量和原始张量内存。</span></span><br><span class="line">x_np_c = x_np.clone().numpy() <span class="comment"># 中断了和x_np关联</span></span><br><span class="line">x_np.add_(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(x_np_c)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[3 4]</span></span><br><span class="line"><span class="string"> [5 6]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># item方法和tolist方法可以将张量转换成Python数值和数值列表。</span></span><br><span class="line">i = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line"><span class="built_in">print</span>(i.item())</span><br><span class="line">x = torch.tensor([<span class="number">1.0</span>,<span class="number">2.0</span>])</span><br><span class="line"><span class="built_in">print</span>(x.tolist())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1.0</span></span><br><span class="line"><span class="string">[1.0, 2.0]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>张量创建参考了很多numpy方法，比如ones_like，rand_like，rand，ones，zeros等等，可参考<a
href="https://soundmemories.github.io/2020/04/22/Machine%20Learning/02.ML-NumPy/">numpy创建方法</a>。</p>
<h1 id="张量操作">张量操作</h1>
<p>张量具有100多种操作，包含了算数、线性代数、矩阵运算（转置/索引/切片）、采样等，详情见<span class="exturl" data-url="aHR0cHM6Ly9weXRvcmNoLm9yZy9kb2NzL3N0YWJsZS90b3JjaC5odG1s">官网介绍<i class="fa fa-external-link-alt"></i></span>。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据量大需要用GPU提高速度，把数据移动到GPU计算</span></span><br><span class="line">tensor = torch.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">  tensor = tensor.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;Device tensor is stored on: <span class="subst">&#123;tensor.device&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Device tensor is stored on: cuda:0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br />
常用方法：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">torch.is_tensor(obj) <span class="comment"># 是否为tensor？</span></span><br><span class="line">torch.is_complex(<span class="built_in">input</span>) <span class="comment"># 是否为复数类型？只支持torch.complex64和torch.complex128。</span></span><br><span class="line">torch.is_floating_point(<span class="built_in">input</span>) <span class="comment"># 是否为float类型？</span></span><br><span class="line">torch.is_nonzero(<span class="built_in">input</span>) <span class="comment"># 是否为&gt;0的值？只能是一个元素。</span></span><br><span class="line">torch.numel(<span class="built_in">input</span>) <span class="comment"># 返回张量的元素数量。</span></span><br><span class="line">torch.set_default_tensor_type(t) <span class="comment"># 设置全局默认张量类型，为t类型。</span></span><br><span class="line"></span><br><span class="line">torch.tensor、as_tensor、from_numpy <span class="comment"># 创建张量，建议用tensor创建。</span></span><br><span class="line">torch.zeros(*size,...,requires_grad=<span class="literal">False</span>) <span class="comment"># 创建全0张量，可选择梯度是否计算。</span></span><br><span class="line">torch.zeros_like(<span class="built_in">input</span>,...)  <span class="comment"># 创建类似input形状的全0张量。</span></span><br><span class="line">torch.ones(*size,...) <span class="comment"># 创建全1张量，可选择梯度是否计算。</span></span><br><span class="line">torch.ones_like(<span class="built_in">input</span>,...)  <span class="comment"># 创建类似input形状的全1张量。</span></span><br><span class="line">torch.arange(start=<span class="number">0</span>, end, step=<span class="number">1</span>,...) <span class="comment"># 创建张量列表，[start, end)，默认int32。建议用此方法。</span></span><br><span class="line">torch.<span class="built_in">range</span>(start=<span class="number">0</span>, end, step=<span class="number">1</span>,...) <span class="comment"># 创建张量列表，[start, end]，默认float32。</span></span><br><span class="line">torch.linspace(start, end, steps...) <span class="comment"># 创建线性张量，steps个元素，自动线性增长。</span></span><br><span class="line">torch.logspace(start, end, steps, base=<span class="number">10.0</span>,,,) <span class="comment"># 创建对数张量，steps个元素，自动对数(10为底)增长。</span></span><br><span class="line">torch.eye(n, m=<span class="literal">None</span>,...) <span class="comment"># 创建2维张量，主对角线全为1，其余为0，只传入一个值为方阵。</span></span><br><span class="line">torch.full(size, fill_value,...) <span class="comment"># 创建size形状张量，用fill_value(列表/元组等)数据填充。</span></span><br><span class="line"></span><br><span class="line">torch.cat(tensors, dim=<span class="number">0</span>,...) <span class="comment"># 按dim维度拼接张量，tensors为多个张量序列(每个张量dim一定要相同)。</span></span><br><span class="line">torch.concat() <span class="comment"># torch.cat的别名。</span></span><br><span class="line">torch.chunk(<span class="built_in">input</span>, chunks, dim=<span class="number">0</span>) <span class="comment"># 将张量按dim维度拆分成chunks块(均分)。</span></span><br><span class="line">torch.gather(<span class="built_in">input</span>, dim, index...) <span class="comment"># 按dim和index从input取值。</span></span><br><span class="line">torch.hstack(tensors,...) <span class="comment"># 沿着列堆叠。</span></span><br><span class="line">torch.reshape(<span class="built_in">input</span>, shape) <span class="comment"># 改变张量形状，返回新张量。view就地改变，需张量contiguous。</span></span><br><span class="line">torch.scatter(<span class="built_in">input</span>, dim, index, src) <span class="comment"># 将src中数据根据index中的索引按照dim的方向填进input中，根据src下标找index值，</span></span><br><span class="line">                                        <span class="comment"># 和scatter_()作用相同，但不会改变原来张量(带_为就地修改)。</span></span><br><span class="line">torch.split(tensor, split_size, dim=<span class="number">0</span>) <span class="comment"># 按split_size切分张量，split_size整数为每块元素个数，列表时为指定每块元素个数。</span></span><br><span class="line">torch.squeeze(<span class="built_in">input</span>, dim=<span class="literal">None</span>,...) <span class="comment"># 对dim维度压缩，未指定时压缩所有为1的维度。</span></span><br><span class="line">torch.stack(tensors, dim=<span class="number">0.</span>..) <span class="comment"># 按dim维度堆叠张量，会增加维度，cat不会增加维度。</span></span><br><span class="line">torch.take(<span class="built_in">input</span>, index) <span class="comment"># 把张量铺平看成一维数组，按照index索引取值。</span></span><br><span class="line">torch.tile(<span class="built_in">input</span>, dims) <span class="comment"># 复制dims-1次数据，dims形状小于input形状时，dims前面补1。</span></span><br><span class="line">                        <span class="comment">#  (8, 6, 4, 2) and dims is (2, 2), then dims is treated as (1, 1, 2, 2)</span></span><br><span class="line">torch.transpose(<span class="built_in">input</span>, dim0, dim1) <span class="comment"># dim0和dim1交换维度。</span></span><br><span class="line">torch.unbind(<span class="built_in">input</span>, dim=<span class="number">0</span>) <span class="comment"># 沿着dim维度切片得到多个张量，返回所有张量元组。</span></span><br><span class="line">torch.unsqueeze(<span class="built_in">input</span>, dim) <span class="comment"># 在dim维度增加一维，和squeeze相反。</span></span><br><span class="line">torch.where(condition, x, y) <span class="comment"># 根据condition条件判断，成立为x，否则为y。</span></span><br><span class="line"></span><br><span class="line">torch.manual_seed(seed) <span class="comment"># 设定随机数种子，包括cpu和GPU，不包括numpy。</span></span><br><span class="line">torch.bernoulli(<span class="built_in">input</span>,...) <span class="comment"># 伯努利次采样，input为每个位置的概率，返回每个位置伯努利采样结果(0/1)。</span></span><br><span class="line">torch.normal(mean, std, size,...) <span class="comment"># 返回正态分布(高斯分布)，mean和std可以为整数/序列。</span></span><br><span class="line">torch.rand(*size, ...) <span class="comment"># 生成随机数，[0,1)区间均匀分布采样。</span></span><br><span class="line">torch.randint(low=<span class="number">0</span>, high, size,...) <span class="comment"># 生成随机整数，[low,high)区间均匀分布采样。</span></span><br><span class="line">torch.randn(*size,...) <span class="comment"># 生成随机数，正态分布采样(均值0，标准差1)。</span></span><br><span class="line">torch.randperm(n, ...) <span class="comment"># 随机组合，[0,n)区间随机打乱组合。</span></span><br><span class="line"></span><br><span class="line">torch.<span class="built_in">abs</span>(<span class="built_in">input</span>,...) <span class="comment"># 绝对值。</span></span><br><span class="line">torch.add(<span class="built_in">input</span>, other, *, alpha=<span class="number">1</span>,...)  <span class="comment"># 相加，input + alpha*other。</span></span><br><span class="line">torch.ceil(<span class="built_in">input</span>,...) <span class="comment"># 取上界。</span></span><br><span class="line">torch.div(<span class="built_in">input</span>, other,...) <span class="comment"># 相除，input/other。</span></span><br><span class="line">torch.exp(<span class="built_in">input</span>,...) <span class="comment"># 指数，e^input。</span></span><br><span class="line">torch.floor(<span class="built_in">input</span>,...) <span class="comment"># 取下界。</span></span><br><span class="line">torch.log(<span class="built_in">input</span>,...) <span class="comment"># 对数,log_e(input)。</span></span><br><span class="line">torch.mul(<span class="built_in">input</span>, other,...) <span class="comment"># 相乘，input*other。</span></span><br><span class="line">torch.neg(<span class="built_in">input</span>,...) <span class="comment"># 取负，-1*input。</span></span><br><span class="line">torch.<span class="built_in">pow</span>(<span class="built_in">input</span>, exponent,...) <span class="comment"># 幂指数，input^exponent。</span></span><br><span class="line">torch.sqrt(<span class="built_in">input</span>,...) <span class="comment"># 开方。</span></span><br><span class="line">torch.<span class="built_in">round</span>(<span class="built_in">input</span>,...) <span class="comment"># 保留整数部分，四舍五入。</span></span><br><span class="line">torch.trunc(<span class="built_in">input</span>,...) <span class="comment"># 保留整数部分，向0归整。fix别名。</span></span><br><span class="line">torch.sub(<span class="built_in">input</span>, other, *, alpha=<span class="number">1</span>,...) <span class="comment"># 相减，input - alpha*other。</span></span><br><span class="line">torch.clamp(<span class="built_in">input</span>, <span class="built_in">min</span>=<span class="literal">None</span>, <span class="built_in">max</span>=<span class="literal">None</span>,...) <span class="comment"># 限制范围[min,max]。</span></span><br><span class="line"></span><br><span class="line">torch.argmax(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>) <span class="comment"># input最大值索引，不写dim将按input展平比较。</span></span><br><span class="line">torch.argmin(<span class="built_in">input</span>, dim=<span class="literal">None</span>, keepdim=<span class="literal">False</span>) <span class="comment"># input最小值索引，不写dim将按input展平比较。</span></span><br><span class="line">torch.<span class="built_in">all</span>(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>,...) <span class="comment"># input元素全为True？不写dim将按input展平比较。</span></span><br><span class="line">torch.<span class="built_in">any</span>(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>,...) <span class="comment"># input元素不全为True？不写dim将按input展平比较。</span></span><br><span class="line">torch.<span class="built_in">max</span>(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>,...) <span class="comment"># input最大值, 不写dim将按input展平比较。</span></span><br><span class="line">torch.<span class="built_in">min</span>(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>,...) <span class="comment"># input最小值, 不写dim将按input展平比较。</span></span><br><span class="line">torch.mean(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>,...) <span class="comment"># input均值, 不写dim将按input展平比较。</span></span><br><span class="line">torch.median(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>,...) <span class="comment"># input中位数, 不写dim将按input展平比较。</span></span><br><span class="line">torch.<span class="built_in">sum</span>(<span class="built_in">input</span>, dim, keepdim=<span class="literal">False</span>,...) <span class="comment"># input求和, 不写dim将按input展平比较。</span></span><br><span class="line"></span><br><span class="line">torch.argsort(<span class="built_in">input</span>, dim=-<span class="number">1</span>, descending=<span class="literal">False</span>) <span class="comment"># 给定维度升序排序后的索引。</span></span><br><span class="line">torch.equal(<span class="built_in">input</span>, other) <span class="comment"># input和other形状和元素相同为True。</span></span><br><span class="line">torch.ge(<span class="built_in">input</span>, other,...) <span class="comment"># 大于等于。</span></span><br><span class="line">torch.gt(<span class="built_in">input</span>, other,...) <span class="comment"># 大于。</span></span><br><span class="line">torch.isin(elements, test_elements,...) <span class="comment"># elements元素在test_elements中出现为True，形状同elements。</span></span><br><span class="line">torch.isnan(<span class="built_in">input</span>) <span class="comment"># nan？</span></span><br><span class="line">torch.le(<span class="built_in">input</span>, other,...) <span class="comment"># 小于等于。</span></span><br><span class="line">torch.lt(<span class="built_in">input</span>, other,...) <span class="comment"># 小于。</span></span><br><span class="line">torch.maximum(<span class="built_in">input</span>, other,...) <span class="comment"># 留下input和other相同位置最大值。</span></span><br><span class="line">torch.minimum(<span class="built_in">input</span>, other,...) <span class="comment"># 留下input和other相同位置最小值。</span></span><br><span class="line">torch.ne(<span class="built_in">input</span>, other,...) <span class="comment"># 不等于。</span></span><br><span class="line">torch.sort(<span class="built_in">input</span>, dim=-<span class="number">1</span>, descending=<span class="literal">False</span>,...) <span class="comment"># 按dim排序，默认升序。</span></span><br><span class="line">torch.topk(<span class="built_in">input</span>, k, dim=<span class="literal">None</span>, largest=<span class="literal">True</span>, <span class="built_in">sorted</span>=<span class="literal">True</span>,...) <span class="comment"># topk个元素，默认最大k个。</span></span><br><span class="line"></span><br><span class="line">torch.mm(mat1, mat2, out=<span class="literal">None</span>) <span class="comment"># 两个二维矩阵的矩阵乘法，并且不支持broadcast操作。</span></span><br><span class="line"><span class="comment"># mat1 x mat2 -&gt; n×m × m×d = n×d</span></span><br><span class="line">torch.bmm(bmat1, bmat2, out=<span class="literal">None</span>) <span class="comment"># 三维带batch的矩阵乘法。</span></span><br><span class="line"><span class="comment"># bmat1 x bmat2 -&gt; b×n×m × b×m×d = b×n×d</span></span><br><span class="line">torch.matmul(<span class="built_in">input</span>, other, out=<span class="literal">None</span>) <span class="comment"># 支持broadcast操作，使用起来比较复杂。</span></span><br><span class="line"><span class="comment"># 针对多维数据 matmul() 乘法，可以认为该乘法使用使用两个参数的后两个维度来计算，其他的维度都可以认为是batch维度。</span></span><br><span class="line">torch.mul(mat1, other, out=<span class="literal">None</span>) <span class="comment"># 矩阵逐元素乘法。</span></span><br><span class="line"><span class="comment"># 其中 other 乘数可以是标量，也可以是任意维度的矩阵， 只要满足最终相乘是可以broadcast的即可。</span></span><br></pre></td></tr></table></figure><br />
不规则取值示例：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 班级成绩册的例子，有4个班级，每个班级10个学生，每个学生7门科目成绩。可以用一个4×10×7的张量来表示。</span></span><br><span class="line">minval=<span class="number">0</span></span><br><span class="line">maxval=<span class="number">100</span></span><br><span class="line">scores = torch.floor(minval + (maxval-minval)*torch.rand([<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>])).<span class="built_in">int</span>()</span><br><span class="line"><span class="comment"># 抽取每个班级第0个学生，第5个学生，第9个学生的全部成绩</span></span><br><span class="line">torch.index_select(scores,dim = <span class="number">1</span>,index = torch.tensor([<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]))</span><br><span class="line"><span class="comment"># 抽取每个班级第0个学生，第5个学生，第9个学生的第1门课程，第3门课程，第6门课程成绩</span></span><br><span class="line">torch.index_select(torch.index_select(scores, dim=<span class="number">1</span>, index=torch.tensor([<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]))</span><br><span class="line">                   ,dim=<span class="number">2</span>,index=torch.tensor([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]))</span><br><span class="line"><span class="comment"># 抽取第0个班级第0个学生的第0门课程，第2个班级的第4个学生的第1门课程，第3个班级的第9个学生第6门课程成绩</span></span><br><span class="line"><span class="comment"># take将输入看成一维数组，输出和index同形状</span></span><br><span class="line">torch.take(scores,torch.tensor([<span class="number">0</span>*<span class="number">10</span>*<span class="number">7</span>+<span class="number">0</span>,<span class="number">2</span>*<span class="number">10</span>*<span class="number">7</span>+<span class="number">4</span>*<span class="number">7</span>+<span class="number">1</span>,<span class="number">3</span>*<span class="number">10</span>*<span class="number">7</span>+<span class="number">9</span>*<span class="number">7</span>+<span class="number">6</span>]))</span><br><span class="line"><span class="comment"># 抽取分数大于等于80分的分数（布尔索引）</span></span><br><span class="line"><span class="comment"># 结果是1维张量</span></span><br><span class="line">torch.masked_select(scores, scores&gt;=<span class="number">80</span>)</span><br></pre></td></tr></table></figure><br />
如果要通过修改张量的部分元素值得到新的张量，可以使用torch.where，torch.index_fill
和 torch.masked_fill。<br />
torch.where可以理解为if的张量版本。<br />
torch.index_fill的选取元素逻辑和torch.index_select相同。<br />
torch.masked_fill的选取元素逻辑和torch.masked_select相同。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分数大于60分，赋值成1，否则赋值成0</span></span><br><span class="line">ifpass = torch.where(scores&gt;<span class="number">60</span>,torch.tensor(<span class="number">1</span>),torch.tensor(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 将每个班级第0个学生，第5个学生，第9个学生的全部成绩赋值成满分</span></span><br><span class="line"><span class="comment"># 等价于 scores.index_fill(dim = 1,index = torch.tensor([0,5,9]),value = 100)</span></span><br><span class="line">torch.index_fill(scores,dim = <span class="number">1</span>,index = torch.tensor([<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>]),value = <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将分数小于60分的分数赋值成60分</span></span><br><span class="line"><span class="comment"># 等价于scores.masked_fill(scores&lt;60,60)</span></span><br><span class="line">torch.masked_fill(scores,scores&lt;<span class="number">60</span>,<span class="number">60</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="自动微分">自动微分</h1>
<p>关于自动微分的论文：<span class="exturl" data-url="aHR0cHM6Ly93d3cuam1sci5vcmcvcGFwZXJzL3ZvbHVtZTE4LzE3LTQ2OC8xNy00NjgucGRm">Automatic
Differentiation in Machine Learning: a Survey<i class="fa fa-external-link-alt"></i></span>。<br />
为什么深度学习框架都用反向传播计算梯度？<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">假设 a=f(x), b=g(a), y=h(b)</span><br><span class="line"></span><br><span class="line">p_y/p_x = p_h/p_b * p_g/p_a * p_f/p_x (链式法则+雅可比)</span><br><span class="line">雅可比矩阵大小：|y|*|b|, |b|*|a|, |a|*|x|</span><br><span class="line"></span><br><span class="line">统计计算量：</span><br><span class="line">forward mode <span class="keyword">for</span> AD：</span><br><span class="line">|y|*|b| (|b|*|a|, |a|*|x|) = bax+ybx</span><br><span class="line"></span><br><span class="line">reverse mode <span class="keyword">for</span> AD:</span><br><span class="line">(|y|*|b|, |b|*|a|) |a|*|x| = yba+yax</span><br><span class="line"></span><br><span class="line">假设a=b，变成x跟y的比较：</span><br><span class="line">当x&gt;y, 输入特征大于输出特征, reverse mode计算量比较小(深度网络一般输入维度x&gt;y的，所以用方向传播省计算量)</span><br><span class="line">当x&lt;y, 输入特征小于输出特征, forward mode计算量比较小</span><br></pre></td></tr></table></figure><br />
Pytorch一般通过反向传播<code>backward()</code>方法实现这种求梯度计算。该方法求得的梯度将存在对应自变量张量的grad属性下。<br />
除此之外，也能够调用<code>torch.autograd.grad()</code>函数来实现求梯度计算。这就是Pytorch的自动微分机制。<br />
注意，Pytorch梯度会自动累加，不想累加使用<code>.grad_zero_()</code>清除当前梯度。<br />
利用backward方法求导数：<br />
<div class="tabs" id="one"><ul class="nav-tabs"><li class="tab active"><a href="#one-1">标量反向传播</a></li><li class="tab"><a href="#one-2">非标量反向传播</a></li><li class="tab"><a href="#one-3">非标量用标量反向传播</a></li></ul><div class="tab-content"><div class="tab-pane active" id="one-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = a*x^2 + b*x + c的导数</span></span><br><span class="line">x = torch.tensor(<span class="number">0.0</span>, requires_grad=<span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">a = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">b = torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">c = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">y = a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c </span><br><span class="line"></span><br><span class="line">y.backward()</span><br><span class="line">dy_dx = x.grad</span><br><span class="line"><span class="built_in">print</span>(dy_dx)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor(-2.)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="one-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = a*x^2 + b*x + c</span></span><br><span class="line">x = torch.tensor([[<span class="number">0.0</span>,<span class="number">0.0</span>],[<span class="number">1.0</span>,<span class="number">2.0</span>]], requires_grad=<span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">a = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">b = torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">c = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">y = a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c </span><br><span class="line"></span><br><span class="line">gradient = torch.tensor([[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:\n&quot;</span>,x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y:\n&quot;</span>,y)</span><br><span class="line"><span class="comment"># 当loss非标量时，backward需要传入和结果形状一致的张量。loss对参数求完梯度后乘以这个张量作为结果。</span></span><br><span class="line"><span class="comment"># 官网自动微分：https://pytorch.org/tutorials/beginner/basics/autogradqs_tutorial.html</span></span><br><span class="line">y.backward(gradient=gradient)</span><br><span class="line">x_grad = x.grad</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_grad:\n&quot;</span>,x_grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">x:</span></span><br><span class="line"><span class="string"> tensor([[0., 0.],</span></span><br><span class="line"><span class="string">        [1., 2.]], requires_grad=True)</span></span><br><span class="line"><span class="string">y:</span></span><br><span class="line"><span class="string"> tensor([[1., 1.],</span></span><br><span class="line"><span class="string">        [0., 1.]], grad_fn=&lt;AddBackward0&gt;)</span></span><br><span class="line"><span class="string">x_grad:</span></span><br><span class="line"><span class="string"> tensor([[-2., -2.],</span></span><br><span class="line"><span class="string">        [ 0.,  2.]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 手动计算</span></span><br><span class="line"><span class="keyword">from</span> torch.autograd.functional <span class="keyword">import</span> jacobian</span><br><span class="line"><span class="comment"># jacobian需要输入一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line"><span class="comment"># 把矩阵运算转成向量运算</span></span><br><span class="line">x_1 = torch.ones_like(func(x[<span class="number">0</span>])) @ jacobian(func,x[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(x_1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([-2., -2.])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">x_2 = torch.ones_like(func(x[<span class="number">1</span>])) @ jacobian(func,x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(x_2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([0., 2.])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="one-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = a*x^2 + b*x + c</span></span><br><span class="line">x = torch.tensor([[<span class="number">0.0</span>,<span class="number">0.0</span>],[<span class="number">1.0</span>,<span class="number">2.0</span>]], requires_grad=<span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">a = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">b = torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">c = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">y = a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c </span><br><span class="line"></span><br><span class="line">gradient = torch.tensor([[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>]])</span><br><span class="line">z = torch.<span class="built_in">sum</span>(y*gradient)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x:&quot;</span>,x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y:&quot;</span>,y)</span><br><span class="line">z.backward()</span><br><span class="line">x_grad = x.grad</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x_grad:\n&quot;</span>,x_grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">x: tensor([[0., 0.],</span></span><br><span class="line"><span class="string">        [1., 2.]], requires_grad=True)</span></span><br><span class="line"><span class="string">y: tensor([[1., 1.],</span></span><br><span class="line"><span class="string">        [0., 1.]], grad_fn=&lt;AddBackward0&gt;)</span></span><br><span class="line"><span class="string">x_grad:</span></span><br><span class="line"><span class="string"> tensor([[-2., -2.],</span></span><br><span class="line"><span class="string">        [ 0.,  2.]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<p>利用autograd.grad方法求导数：<br />
<div class="tabs" id="two"><ul class="nav-tabs"><li class="tab active"><a href="#two-1">单个标量</a></li><li class="tab"><a href="#two-2">多个标量</a></li></ul><div class="tab-content"><div class="tab-pane active" id="two-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = a*x^2 + b*x + c的导数</span></span><br><span class="line">x = torch.tensor(<span class="number">0.0</span>, requires_grad=<span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">a = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">b = torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">c = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">y = a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c</span><br><span class="line"></span><br><span class="line"><span class="comment"># create_graph 设置为 True 将允许创建更高阶的导数 </span></span><br><span class="line">dy_dx = torch.autograd.grad(y,x, create_graph=<span class="literal">True</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(dy_dx.data)</span><br><span class="line"><span class="comment"># 求二阶导数</span></span><br><span class="line">dy2_dx2 = torch.autograd.grad(dy_dx,x)[<span class="number">0</span>] </span><br><span class="line"><span class="built_in">print</span>(dy2_dx2.data)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor(-2.)</span></span><br><span class="line"><span class="string">tensor(2.)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="two-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line">x1 = torch.tensor(<span class="number">1.0</span>, requires_grad=<span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">x2 = torch.tensor(<span class="number">2.0</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">y1 = x1*x2</span><br><span class="line">y2 = x1+x2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许同时对多个自变量求导数</span></span><br><span class="line">(dy1_dx1,dy1_dx2) = torch.autograd.grad(outputs=y1, inputs=[x1,x2], retain_graph=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(dy1_dx1,dy1_dx2)</span><br><span class="line"><span class="comment"># 如果有多个因变量，相当于把多个因变量的梯度结果求和</span></span><br><span class="line">(dy12_dx1,dy12_dx2) = torch.autograd.grad(outputs=[y1,y2], inputs=[x1,x2])</span><br><span class="line"><span class="built_in">print</span>(dy12_dx1,dy12_dx2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor(2.) tensor(1.)</span></span><br><span class="line"><span class="string">tensor(3.) tensor(2.)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<p>利用自动微分和优化器求最小值：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = a*x^2 + b*x + c的最小值</span></span><br><span class="line">x = torch.tensor(<span class="number">0.0</span>, requires_grad=<span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">a = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">b = torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">c = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.SGD(params=[x], lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    result = a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c </span><br><span class="line">    <span class="keyword">return</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    y = f(x)</span><br><span class="line">    y.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y=&quot;</span>,f(x).data,<span class="string">&quot;;&quot;</span>,<span class="string">&quot;x=&quot;</span>,x.data)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">y= tensor(0.) ; x= tensor(1.0000)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="动态计算图">动态计算图</h1>
<p>Pytorch的计算图由<strong>节点</strong>和<strong>边</strong>组成，节点表示张量或者Function，边表示张量和Function之间的依赖关系。<br />
Pytorch中的计算图是动态图。这里的动态主要有两重含义。<strong>第一层含义</strong>：计算图的<strong>正向传播是立即执行</strong>。无需等待完整的计算图创建完毕，每条语句都会在计算图中动态添加节点和边，并立即执行正向传播得到计算结果。<strong>第二层含义</strong>：计算图在<strong>反向传播后立即销毁</strong>。下次调用需要重新构建计算图。如果在程序中使用了backward方法执行了反向传播，或者利用torch.autograd.grad方法计算了梯度，那么创建的计算图会被立即销毁，释放存储空间，下次调用需要重新创建。<br />
<div class="tabs" id="ll"><ul class="nav-tabs"><li class="tab active"><a href="#ll-1">正向传播是立即执行</a></li><li class="tab"><a href="#ll-2">反向传播后立即销毁</a></li></ul><div class="tab-content"><div class="tab-pane active" id="ll-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line">w = torch.tensor([[<span class="number">3.0</span>,<span class="number">1.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([[<span class="number">3.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">X = torch.tensor([[<span class="number">2.0</span>,<span class="number">4.0</span>]])</span><br><span class="line">Y = torch.tensor(<span class="number">1</span>)</span><br><span class="line">Y_hat = X@w.t() + b  <span class="comment"># Y_hat定义后其正向传播被立即执行，与其后面的loss创建语句无关</span></span><br><span class="line">loss = torch.mean(torch.<span class="built_in">pow</span>(Y_hat-Y,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(loss.data)</span><br><span class="line"><span class="built_in">print</span>(Y_hat.data)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor(144.)</span></span><br><span class="line"><span class="string">tensor([[13.]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="ll-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line">w = torch.tensor([[<span class="number">3.0</span>,<span class="number">1.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([[<span class="number">3.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">X = torch.tensor([[<span class="number">2.0</span>,<span class="number">4.0</span>]],requires_grad=<span class="literal">False</span>)</span><br><span class="line">Y = torch.tensor(<span class="number">1</span>,requires_grad=<span class="literal">False</span>)</span><br><span class="line">Y_hat = X@w.t() + b  <span class="comment"># Y_hat定义后其正向传播被立即执行，与其后面的loss创建语句无关</span></span><br><span class="line">loss = torch.mean(torch.<span class="built_in">pow</span>(Y_hat-Y,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算图在反向传播后立即销毁，如果需要保留计算图, 需要backward中设置retain_graph=True</span></span><br><span class="line">loss.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#loss.backward() #若不加retain_graph，如果再次执行反向传播将报错</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<p>计算图中的 张量我们已经比较熟悉了, 计算图中的另外一种节点是Function,
实际上就是Pytorch中各种对张量操作的函数。这些Function和我们Python中的函数有一个较大的区别，那就是它同时包括正向计算逻辑和反向传播的逻辑。我们可以通过继承torch.autograd.Function来创建这种支持反向传播的Function。<br />
<div class="tabs" id="s"><ul class="nav-tabs"><li class="tab active"><a href="#s-1">自定义Function</a></li><li class="tab"><a href="#s-2">调用自定义Function</a></li><li class="tab"><a href="#s-3">反向传播计算过程</a></li></ul><div class="tab-content"><div class="tab-pane active" id="s-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyReLU</span>(torch.autograd.Function):</span><br><span class="line">    <span class="comment">#正向传播逻辑，可以用ctx存储一些值，供反向传播使用。</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">ctx, <span class="built_in">input</span></span>):</span><br><span class="line">        ctx.save_for_backward(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span>.clamp(<span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#反向传播逻辑</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">ctx, grad_output</span>):</span><br><span class="line">        <span class="built_in">input</span>, = ctx.saved_tensors</span><br><span class="line">        grad_input = grad_output.clone()</span><br><span class="line">        grad_input[<span class="built_in">input</span> &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> grad_input</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="s-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line">w = torch.tensor([[<span class="number">3.0</span>,<span class="number">1.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.tensor([[<span class="number">3.0</span>]],requires_grad=<span class="literal">True</span>)</span><br><span class="line">X = torch.tensor([[-<span class="number">1.0</span>,-<span class="number">1.0</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>]])</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>,<span class="number">3.0</span>]])</span><br><span class="line"></span><br><span class="line">relu = MyReLU.apply <span class="comment"># relu现在也可以具有正向传播和反向传播功能</span></span><br><span class="line">Y_hat = relu(X@w.t() + b)</span><br><span class="line">loss = torch.mean(torch.<span class="built_in">pow</span>(Y_hat-Y,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([[4.5000, 4.5000]])</span></span><br><span class="line"><span class="string">tensor([[4.5000]])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># Y_hat的梯度函数即是我们自己所定义的 MyReLU.backward</span></span><br><span class="line"><span class="built_in">print</span>(Y_hat.grad_fn)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;torch.autograd.function.MyReLUBackward object at 0x1205a46c8&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="s-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">loss.backward()语句调用后，依次发生以下计算过程：</span></span><br><span class="line"><span class="string">(1) loss自己的grad梯度赋值为1，即对自身的梯度为1。</span></span><br><span class="line"><span class="string">(2) loss根据其自身梯度以及关联的backward方法，计算出其对应的自变量即y1和y2的梯度，将该值赋值到y1.grad和y2.grad。</span></span><br><span class="line"><span class="string">(3) y2和y1根据其自身梯度以及关联的backward方法, 分别计算出其对应的自变量x的梯度，x.grad将其收到的多个梯度值累加。</span></span><br><span class="line"><span class="string">（注意，1,2,3步骤的求梯度顺序和对多个梯度值的累加规则恰好是求导链式法则的程序表述）</span></span><br><span class="line"><span class="string">正因为求导链式法则衍生的梯度累加规则，张量的grad梯度不会自动清零，在需要的时候需要手动置零。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">x = torch.tensor(<span class="number">3.0</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">y1 = x+<span class="number">1</span>  <span class="comment"># 梯度:dy1_dx=1</span></span><br><span class="line">y2 = <span class="number">2</span>*x  <span class="comment"># 梯度:dy2_dx=2</span></span><br><span class="line">loss = (y1-y2)**<span class="number">2</span>  </span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"><span class="comment"># 会出现UserWarning，y1和y2为非叶子节点，想看梯度需.retain_grad()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;loss.grad:&quot;</span>, loss.grad)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y1.grad:&quot;</span>, y1.grad)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y2.grad:&quot;</span>, y2.grad)</span><br><span class="line"><span class="comment"># 对x的梯度:2(y1-y2)*(dy1_dx-dy2_dx)=2(1-x)*(-1)，带入x=3得4</span></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">loss.grad: None</span></span><br><span class="line"><span class="string">y1.grad: None</span></span><br><span class="line"><span class="string">y2.grad: None</span></span><br><span class="line"><span class="string">tensor(4.)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(loss.is_leaf)</span><br><span class="line"><span class="built_in">print</span>(y1.is_leaf)</span><br><span class="line"><span class="built_in">print</span>(y2.is_leaf)</span><br><span class="line"><span class="built_in">print</span>(x.is_leaf)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div></div><br />
叶子节点和非叶子节点：<br />
反向传播计算过程中，会发现loss.grad并不是我们期望的1，而是None，类似地
y1.grad 以及 y2.grad也是None。<br />
这是为什么呢？这是由于它们不是叶子节点张量。</p>
<p>在反向传播过程中，只有 is_leaf=True
的叶子节点，需要求导的张量的导数结果才会被最后保留下来。<br />
那么什么是叶子节点张量呢？叶子节点张量需要满足两个条件。<br />
（1）叶子节点张量是由用户直接创建的张量，而非由某个Function通过计算得到的张量。<br />
（2）叶子节点张量的 requires_grad 属性必须为True。<br />
Pytorch设计这样的规则主要是为了节约内存或者显存空间，因为几乎所有的时候，用户只会关心他自己直接创建的张量的梯度。<br />
所有依赖于叶子节点张量的张量, 其 requires_grad
属性必定是True的，但其梯度值只在计算过程中被用到，不会最终存储到grad属性中。</p>
<p>如果需要保留中间计算结果的梯度到grad属性中，可以使用<code>retain_grad</code>方法。<br />
如果仅仅是为了调试代码查看梯度值，可以利用<code>register_hook</code>打印日志。<br />
如果不想保留梯度，可使用<code>with torch.no_grad()</code>方法或Tensor的<code>detach()</code>方法。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#非叶子节点梯度显示控制</span></span><br><span class="line">y1.retain_grad()  <span class="comment"># y1.register_hook(lambda grad: print(&#x27;y1 grad: &#x27;, grad))</span></span><br><span class="line">y2.retain_grad()</span><br><span class="line">loss.retain_grad()</span><br><span class="line"></span><br><span class="line"><span class="comment">#反向传播</span></span><br><span class="line">loss.backward()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;loss.grad:&quot;</span>, loss.grad)</span><br><span class="line"><span class="comment"># 对y1的梯度:2(y1-y2)=2(x+1-2x)，带入x=3得-4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y1.grad:&quot;</span>, y1.grad)</span><br><span class="line"><span class="comment"># 对y2的梯度:-2(y1-y2)=-2(x+1-2x)，带入x=3得4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y2.grad:&quot;</span>, y2.grad)</span><br><span class="line"><span class="comment"># 对x的梯度:2(y1-y2)*(dy1_dx-dy2_dx)=2(1-x)*(-1)，带入x=3得4</span></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">loss.grad: tensor(1.)</span></span><br><span class="line"><span class="string">y1 grad:  tensor(-4.)</span></span><br><span class="line"><span class="string">y2 grad:  tensor(4.)</span></span><br><span class="line"><span class="string">x.grad: tensor(4.)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 不想保留梯度，torch.no_grad或detach</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    loss = (y1-y2)**<span class="number">2</span> </span><br><span class="line"><span class="built_in">print</span>(loss.requires_grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">loss = (y1-y2)**<span class="number">2</span> </span><br><span class="line">loss.detach()</span><br><span class="line"><span class="built_in">print</span>(loss.requires_grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br />
计算图在TensorBoard中的可视化：<br />
可以利用 torch.utils.tensorboard 将计算图导出到
TensorBoard进行可视化。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.w = nn.Parameter(torch.randn(<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line">        self.b = nn.Parameter(torch.zeros(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        y = x@self.w + self.b</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;../data/tensorboard&#x27;</span>)</span><br><span class="line">writer.add_graph(net,input_to_model = torch.rand(<span class="number">10</span>,<span class="number">2</span>))</span><br><span class="line">writer.close()</span><br><span class="line"></span><br><span class="line">%load_ext tensorboard</span><br><span class="line"><span class="comment">#%tensorboard --logdir ../data/tensorboard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorboard <span class="keyword">import</span> notebook</span><br><span class="line">notebook.<span class="built_in">list</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">#在tensorboard中查看模型</span></span><br><span class="line">notebook.start(<span class="string">&quot;--logdir ../data/tensorboard&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="dataset和dataloader">Dataset和DataLoader</h1>
<p>Pytorch通常使用Dataset和DataLoader这两个工具类来构建数据管道(<span class="exturl" data-url="aHR0cHM6Ly9weXRvcmNoLm9yZy90dXRvcmlhbHMvYmVnaW5uZXIvYmFzaWNzL2RhdGFfdHV0b3JpYWwuaHRtbA==">官方讲解<i class="fa fa-external-link-alt"></i></span>)。<br />
Dataset定义了数据集的内容，它相当于一个类似列表的数据结构，具有确定的长度，能够用索引获取数据集中的元素。<br />
DataLoader定义了按batch加载数据集的方法，它是一个实现了<code>__iter__</code>方法的可迭代对象，每次迭代输出一个batch的数据。它能够控制batch的大小，batch中元素的采样方法，以及将batch结果整理成模型所需输入形式的方法，能够使用多进程读取数据。<br />
在绝大部分情况下，用户只需实现Dataset的<code>__init__</code>、<code>__len__</code>和<code>__getitem__</code>方法，就可以构建自己的数据集，并用默认数据管道进行加载。</p>
<p>获取一个batch数据的步骤(假定数据集的特征和标签分别表示为张量X和Y，数据集可以表示为(X,Y),
假定batch大小为m)：<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">（1）首先确定数据集的长度n。</span><br><span class="line">（2）然后从0到n-1的范围中抽样出m个数(batch大小)。假定m=4, 拿到的结果是一个列表，类似：indices=[1,4,8,9]。</span><br><span class="line">（3）接着从数据集中去取这m个数对应下标的元素。拿到的结果是一个元组列表，</span><br><span class="line">	 类似：samples=[(X[1],Y[1]),(X[4],Y[4]),(X[8],Y[8]),(X[9],Y[9])]。</span><br><span class="line">（4）最后将结果整理成两个张量作为输出。拿到的结果是两个张量：</span><br><span class="line">	 类似batch=(features,labels)，其中features=torch.stack([X[1],X[4],X[8],X[9]])，</span><br><span class="line">	 labels=torch.stack([Y[1],Y[4],Y[8],Y[9]])。</span><br><span class="line"></span><br><span class="line">第（1）个步骤确定数据集的长度是由 Dataset 的__len__方法实现的。</span><br><span class="line">第（2）个步骤从0到n-1的范围中抽样出m个数的方法是由 DataLoader的 sampler 和 batch_sampler 参数指定的。</span><br><span class="line">  sampler参数指定单个元素抽样方法，一般无需用户设置，程序默认在DataLoader的参数shuffle=True时采用随机抽样，</span><br><span class="line">  shuffle=False时采用顺序抽样，</span><br><span class="line">  batch_sampler参数将多个抽样的元素整理成一个列表，一般无需用户设置，</span><br><span class="line">  默认方法在DataLoader的参数drop_last=True时会丢弃数据集最后一个长度不能被batch大小整除的批次，</span><br><span class="line">  在drop_last=False时保留最后一个批次。</span><br><span class="line">第（3）个步骤的核心逻辑根据下标取数据集中的元素，是由 Dataset 的__getitem__方法实现的。</span><br><span class="line">第（4）个步骤的逻辑由 DataLoader 的参数collate_fn指定。一般情况下也无需用户设置。</span><br></pre></td></tr></table></figure><br />
以下是 Dataset和
DataLoader的核心接口逻辑伪代码，不完全和源码一致：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dataset</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataLoader</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,dataset,batch_size,collate_fn,shuffle = <span class="literal">True</span>,drop_last = <span class="literal">False</span></span>):</span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        self.sampler =torch.utils.data.RandomSampler <span class="keyword">if</span> shuffle <span class="keyword">else</span> \</span><br><span class="line">           torch.utils.data.SequentialSampler</span><br><span class="line">        self.batch_sampler = torch.utils.data.BatchSampler</span><br><span class="line">        self.sample_iter = self.batch_sampler(</span><br><span class="line">            self.sampler(<span class="built_in">range</span>(<span class="built_in">len</span>(dataset))),</span><br><span class="line">            batch_size = batch_size,drop_last = drop_last)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        indices = <span class="built_in">next</span>(self.sample_iter)</span><br><span class="line">        batch = self.collate_fn([self.dataset[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices])</span><br><span class="line">        <span class="keyword">return</span> batch</span><br></pre></td></tr></table></figure><br />
官网自定义数据集示例：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> torchvision.io <span class="keyword">import</span> read_image</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomImageDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, annotations_file, img_dir, transform=<span class="literal">None</span>, target_transform=<span class="literal">None</span></span>):</span><br><span class="line">        self.img_labels = pd.read_csv(annotations_file) <span class="comment"># 标签地址</span></span><br><span class="line">        self.img_dir = img_dir  <span class="comment"># 文件地址</span></span><br><span class="line">        self.transform = transform  <span class="comment"># 文件预处理函数</span></span><br><span class="line">        self.target_transform = target_transform <span class="comment"># 标签预处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_labels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, <span class="number">0</span>])  <span class="comment"># 第0列为地址</span></span><br><span class="line">        image = read_image(img_path)</span><br><span class="line">        label = self.img_labels.iloc[idx, <span class="number">1</span>]  <span class="comment"># 第1列为标签</span></span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            image = self.transform(image)</span><br><span class="line">        <span class="keyword">if</span> self.target_transform:</span><br><span class="line">            label = self.target_transform(label)</span><br><span class="line">        <span class="keyword">return</span> image, label</span><br></pre></td></tr></table></figure></p>
<p><strong>使用Dataset创建数据集</strong><br />
（1）使用 torch.utils.data.TensorDataset
根据Tensor创建数据集（numpy的array，Pandas的DataFrame需要先转换成Tensor）。<br />
（2）使用 torchvision.datasets.ImageFolder
根据图片目录创建图片数据集。<br />
（3）继承 torch.utils.data.Dataset 创建自定义数据集。<br />
torch.utils.data.random_split
将一个数据集分割成多份，常用于分割训练集，验证集和测试集。调用Dataset的加法运算符（+）将多个数据集合并成一个数据集。<br />
<div class="tabs" id="three"><ul class="nav-tabs"><li class="tab active"><a href="#three-1">根据Tensor创建数据集</a></li><li class="tab"><a href="#three-2">根据图片目录创建图片数据集</a></li><li class="tab"><a href="#three-3">自定义数据集</a></li></ul><div class="tab-content"><div class="tab-pane active" id="three-1"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> TensorDataset,Dataset,DataLoader,random_split </span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据Tensor创建数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets </span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">ds_iris = TensorDataset(torch.tensor(iris.data),torch.tensor(iris.target))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割成训练集和预测集</span></span><br><span class="line">n_train = <span class="built_in">int</span>(<span class="built_in">len</span>(ds_iris)*<span class="number">0.8</span>)</span><br><span class="line">n_valid = <span class="built_in">len</span>(ds_iris) - n_train</span><br><span class="line">ds_train,ds_valid = random_split(ds_iris,[n_train,n_valid])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ds_iris))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ds_train))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">torch.utils.data.dataset.TensorDataset</span></span><br><span class="line"><span class="string">torch.utils.data.dataset.Subset</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 使用DataLoader加载数据集</span></span><br><span class="line">dl_train,dl_valid = DataLoader(ds_train,batch_size=<span class="number">8</span>),DataLoader(ds_valid,batch_size=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> features,labels <span class="keyword">in</span> dl_train:</span><br><span class="line">    <span class="built_in">print</span>(features,labels)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([[5.4000, 3.4000, 1.5000, 0.4000],</span></span><br><span class="line"><span class="string">        [7.2000, 3.0000, 5.8000, 1.6000],</span></span><br><span class="line"><span class="string">        [5.7000, 2.6000, 3.5000, 1.0000],</span></span><br><span class="line"><span class="string">        [6.1000, 2.6000, 5.6000, 1.4000],</span></span><br><span class="line"><span class="string">        [6.7000, 3.1000, 4.4000, 1.4000],</span></span><br><span class="line"><span class="string">        [5.8000, 2.8000, 5.1000, 2.4000],</span></span><br><span class="line"><span class="string">        [5.6000, 2.5000, 3.9000, 1.1000],</span></span><br><span class="line"><span class="string">        [6.2000, 2.2000, 4.5000, 1.5000]], </span></span><br><span class="line"><span class="string">        dtype=torch.float64) tensor([0, 2, 1, 2, 1, 2, 1, 1], dtype=torch.int32)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 演示加法运算符（`+`）的合并作用</span></span><br><span class="line">ds_data = ds_train + ds_valid</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len(ds_train) = &#x27;</span>,<span class="built_in">len</span>(ds_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len(ds_valid) = &#x27;</span>,<span class="built_in">len</span>(ds_valid))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len(ds_train+ds_valid) = &#x27;</span>,<span class="built_in">len</span>(ds_data))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(ds_data))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">len(ds_train) =  120</span></span><br><span class="line"><span class="string">len(ds_valid) =  30</span></span><br><span class="line"><span class="string">len(ds_train+ds_valid) =  150</span></span><br><span class="line"><span class="string">torch.utils.data.dataset.ConcatDataset</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="three-2"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms,datasets </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;../data/cat.jpeg&#x27;</span>)</span><br><span class="line">img</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些常用的图片增强操作</span></span><br><span class="line"><span class="comment">#随机数值翻转</span></span><br><span class="line">transforms.RandomVerticalFlip()(img)</span><br><span class="line"><span class="comment">#随机旋转</span></span><br><span class="line">transforms.RandomRotation(<span class="number">45</span>)(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义图片增强操作</span></span><br><span class="line">transform_train = transforms.Compose([</span><br><span class="line">   transforms.RandomHorizontalFlip(), <span class="comment">#随机水平翻转</span></span><br><span class="line">   transforms.RandomVerticalFlip(), <span class="comment">#随机垂直翻转</span></span><br><span class="line">   transforms.RandomRotation(<span class="number">45</span>),  <span class="comment">#随机在45度角度内旋转</span></span><br><span class="line">   transforms.ToTensor() <span class="comment">#转换成张量</span></span><br><span class="line">  ]</span><br><span class="line">) </span><br><span class="line"><span class="comment"># 验证集不需要增强</span></span><br><span class="line">transform_valid = transforms.Compose([</span><br><span class="line">    transforms.ToTensor()</span><br><span class="line">  ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据图片目录创建数据集</span></span><br><span class="line">ds_train = datasets.ImageFolder(<span class="string">&quot;../data/cifar2/train/&quot;</span>,</span><br><span class="line">            transform = transform_train,target_transform= <span class="keyword">lambda</span> t:torch.tensor([t]).<span class="built_in">float</span>())</span><br><span class="line">ds_valid = datasets.ImageFolder(<span class="string">&quot;../data/cifar2/test/&quot;</span>,</span><br><span class="line">            transform = transform_train,target_transform= <span class="keyword">lambda</span> t:torch.tensor([t]).<span class="built_in">float</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ds_train.class_to_idx)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;0_airplane&#x27;: 0, &#x27;1_automobile&#x27;: 1&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 使用DataLoader加载数据集</span></span><br><span class="line">dl_train = DataLoader(ds_train,batch_size = <span class="number">50</span>,shuffle = <span class="literal">True</span>,num_workers=<span class="number">3</span>)</span><br><span class="line">dl_valid = DataLoader(ds_valid,batch_size = <span class="number">50</span>,shuffle = <span class="literal">True</span>,num_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> features,labels <span class="keyword">in</span> dl_train:</span><br><span class="line">    <span class="built_in">print</span>(features.shape)</span><br><span class="line">    <span class="built_in">print</span>(labels.shape)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">torch.Size([50, 3, 32, 32])</span></span><br><span class="line"><span class="string">torch.Size([50, 1])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="three-3"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先，对训练集文本分词构建词典。然后将训练集文本和测试集文本数据转换成token单词编码。</span></span><br><span class="line"><span class="comment"># 接着将转换成单词编码的训练集数据和测试集数据按样本分割成多个文件，一个文件代表一个样本。</span></span><br><span class="line"><span class="comment"># 最后，我们可以根据文件名列表获取对应序号的样本内容，从而构建Dataset数据集。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> re,string</span><br><span class="line"></span><br><span class="line">MAX_WORDS = <span class="number">10000</span>  <span class="comment"># 仅考虑最高频的10000个词</span></span><br><span class="line">MAX_LEN = <span class="number">200</span>  <span class="comment"># 每个样本保留200个词的长度</span></span><br><span class="line">BATCH_SIZE = <span class="number">20</span> </span><br><span class="line"></span><br><span class="line">train_data_path = <span class="string">&#x27;data/imdb/train.tsv&#x27;</span></span><br><span class="line">test_data_path = <span class="string">&#x27;data/imdb/test.tsv&#x27;</span></span><br><span class="line">train_token_path = <span class="string">&#x27;data/imdb/train_token.tsv&#x27;</span></span><br><span class="line">test_token_path =  <span class="string">&#x27;data/imdb/test_token.tsv&#x27;</span></span><br><span class="line">train_samples_path = <span class="string">&#x27;data/imdb/train_samples/&#x27;</span></span><br><span class="line">test_samples_path =  <span class="string">&#x27;data/imdb/test_samples/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建词典，并保留最高频的MAX_WORDS个词</span></span><br><span class="line"><span class="comment">#构建词典</span></span><br><span class="line">word_count_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#清洗文本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_text</span>(<span class="params">text</span>):</span><br><span class="line">    lowercase = text.lower().replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot; &quot;</span>)</span><br><span class="line">    stripped_html = re.sub(<span class="string">&#x27;&lt;br /&gt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>,lowercase)</span><br><span class="line">    cleaned_punctuation = re.sub(<span class="string">&#x27;[%s]&#x27;</span>%re.escape(string.punctuation),<span class="string">&#x27;&#x27;</span>,stripped_html)</span><br><span class="line">    <span class="keyword">return</span> cleaned_punctuation</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(train_data_path,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        label,text = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        cleaned_text = clean_text(text)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> cleaned_text.split(<span class="string">&quot; &quot;</span>):</span><br><span class="line">            word_count_dict[word] = word_count_dict.get(word,<span class="number">0</span>)+<span class="number">1</span> </span><br><span class="line"></span><br><span class="line">df_word_dict = pd.DataFrame(pd.Series(word_count_dict,name = <span class="string">&quot;count&quot;</span>))</span><br><span class="line">df_word_dict = df_word_dict.sort_values(by = <span class="string">&quot;count&quot;</span>,ascending =<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">df_word_dict = df_word_dict[<span class="number">0</span>:MAX_WORDS-<span class="number">2</span>]  </span><br><span class="line">df_word_dict[<span class="string">&quot;word_id&quot;</span>] = <span class="built_in">range</span>(<span class="number">2</span>,MAX_WORDS) <span class="comment"># 编号0和1分别留给未知词&lt;unkown&gt;和填充&lt;padding&gt;</span></span><br><span class="line"></span><br><span class="line">word_id_dict = df_word_dict[<span class="string">&quot;word_id&quot;</span>].to_dict()</span><br><span class="line"></span><br><span class="line">df_word_dict.head(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用构建好的词典，将文本转换成token序号</span></span><br><span class="line"><span class="comment">#转换token, 填充文本</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pad</span>(<span class="params">data_list,pad_length</span>):</span><br><span class="line">    padded_list = data_list.copy()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data_list)&gt; pad_length:</span><br><span class="line">         padded_list = data_list[-pad_length:]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data_list)&lt; pad_length:</span><br><span class="line">         padded_list = [<span class="number">1</span>]*(pad_length-<span class="built_in">len</span>(data_list))+data_list</span><br><span class="line">    <span class="keyword">return</span> padded_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">text_to_token</span>(<span class="params">text_file,token_file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(text_file,<span class="string">&quot;r&quot;</span>,encoding = <span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fin,\</span><br><span class="line">      <span class="built_in">open</span>(token_file,<span class="string">&quot;w&quot;</span>,encoding = <span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fin:</span><br><span class="line">            label,text = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">            cleaned_text = clean_text(text)</span><br><span class="line">            word_token_list = [word_id_dict.get(word, <span class="number">0</span>) <span class="keyword">for</span> word <span class="keyword">in</span> cleaned_text.split(<span class="string">&quot; &quot;</span>)]</span><br><span class="line">            pad_list = pad(word_token_list,MAX_LEN)</span><br><span class="line">            out_line = label+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> pad_list])</span><br><span class="line">            fout.write(out_line+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">text_to_token(train_data_path,train_token_path)</span><br><span class="line">text_to_token(test_data_path,test_token_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着将token文本按照样本分割，每个文件存放一个样本的数据</span></span><br><span class="line"><span class="comment">#分割样本</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(train_samples_path):</span><br><span class="line">    os.mkdir(train_samples_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(test_samples_path):</span><br><span class="line">    os.mkdir(test_samples_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_samples</span>(<span class="params">token_path,samples_dir</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(token_path,<span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fin:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(samples_dir+<span class="string">&quot;%d.txt&quot;</span>%i,<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fout:</span><br><span class="line">                fout.write(line)</span><br><span class="line">            i = i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">split_samples(train_token_path,train_samples_path)</span><br><span class="line">split_samples(test_token_path,test_samples_path)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.listdir(train_samples_path)[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;11303.txt&#x27;, &#x27;3644.txt&#x27;, &#x27;19987.txt&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 创建数据集Dataset, 从文件名称列表中读取文件内容了</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">imdbDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,samples_dir</span>):</span><br><span class="line">        self.samples_dir = samples_dir</span><br><span class="line">        self.samples_paths = os.listdir(samples_dir)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.samples_paths)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,index</span>):</span><br><span class="line">        path = self.samples_dir + self.samples_paths[index]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            line = f.readline()</span><br><span class="line">            label,tokens = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">            label = torch.tensor([<span class="built_in">float</span>(label)], dtype=torch.<span class="built_in">float</span>)</span><br><span class="line">            feature = torch.tensor([<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> tokens.split(<span class="string">&quot; &quot;</span>)], dtype=torch.long)</span><br><span class="line">            <span class="keyword">return</span>  (feature,label)</span><br><span class="line"></span><br><span class="line">ds_train = imdbDataset(train_samples_path)</span><br><span class="line">ds_test = imdbDataset(test_samples_path)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ds_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ds_test))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">20000</span></span><br><span class="line"><span class="string">5000</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">dl_train = DataLoader(ds_train, batch_size=BATCH_SIZE, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br><span class="line">dl_test = DataLoader(ds_test, batch_size=BATCH_SIZE, num_workers=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> features,labels <span class="keyword">in</span> dl_train:</span><br><span class="line">    <span class="built_in">print</span>(features)</span><br><span class="line">    <span class="built_in">print</span>(labels)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后构建模型测试一下数据集管道是否可用</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn </span><br><span class="line"><span class="keyword">import</span> importlib </span><br><span class="line"><span class="keyword">from</span> torchkeras <span class="keyword">import</span> Model,summary</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(<span class="title class_ inherited__">Model</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#设置padding_idx参数后将在训练过程中将填充的token始终赋值为0向量</span></span><br><span class="line">        self.embedding = nn.Embedding(num_embeddings=MAX_WORDS, embedding_dim=<span class="number">3</span>,padding_idx=<span class="number">1</span>)</span><br><span class="line">        self.conv = nn.Sequential()</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;conv_1&quot;</span>,nn.Conv1d(in_channels=<span class="number">3</span>, out_channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;pool_1&quot;</span>,nn.MaxPool1d(kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;relu_1&quot;</span>,nn.ReLU())</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;conv_2&quot;</span>,nn.Conv1d(in_channels=<span class="number">16</span>, out_channels=<span class="number">128</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;pool_2&quot;</span>,nn.MaxPool1d(kernel_size = <span class="number">2</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;relu_2&quot;</span>,nn.ReLU())</span><br><span class="line"></span><br><span class="line">        self.dense = nn.Sequential()</span><br><span class="line">        self.dense.add_module(<span class="string">&quot;flatten&quot;</span>,nn.Flatten())</span><br><span class="line">        self.dense.add_module(<span class="string">&quot;linear&quot;</span>,nn.Linear(<span class="number">6144</span>,<span class="number">1</span>))</span><br><span class="line">        self.dense.add_module(<span class="string">&quot;sigmoid&quot;</span>,nn.Sigmoid())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.embedding(x).transpose(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        y = self.dense(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = Net()</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"></span><br><span class="line">model.summary(input_shape=(<span class="number">200</span>,),input_dtype=torch.LongTensor)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Net(</span></span><br><span class="line"><span class="string">  (embedding): Embedding(10000, 3, padding_idx=1)</span></span><br><span class="line"><span class="string">  (conv): Sequential(</span></span><br><span class="line"><span class="string">    (conv_1): Conv1d(3, 16, kernel_size=(5,), stride=(1,))</span></span><br><span class="line"><span class="string">    (pool_1): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">    (relu_1): ReLU()</span></span><br><span class="line"><span class="string">    (conv_2): Conv1d(16, 128, kernel_size=(2,), stride=(1,))</span></span><br><span class="line"><span class="string">    (pool_2): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">    (relu_2): ReLU()</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">  (dense): Sequential(</span></span><br><span class="line"><span class="string">    (flatten): Flatten()</span></span><br><span class="line"><span class="string">    (linear): Linear(in_features=6144, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">    (sigmoid): Sigmoid()</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">        Layer (type)               Output Shape         Param #</span></span><br><span class="line"><span class="string">================================================================</span></span><br><span class="line"><span class="string">         Embedding-1               [-1, 200, 3]          30,000</span></span><br><span class="line"><span class="string">            Conv1d-2              [-1, 16, 196]             256</span></span><br><span class="line"><span class="string">         MaxPool1d-3               [-1, 16, 98]               0</span></span><br><span class="line"><span class="string">              ReLU-4               [-1, 16, 98]               0</span></span><br><span class="line"><span class="string">            Conv1d-5              [-1, 128, 97]           4,224</span></span><br><span class="line"><span class="string">         MaxPool1d-6              [-1, 128, 48]               0</span></span><br><span class="line"><span class="string">              ReLU-7              [-1, 128, 48]               0</span></span><br><span class="line"><span class="string">           Flatten-8                 [-1, 6144]               0</span></span><br><span class="line"><span class="string">            Linear-9                    [-1, 1]           6,145</span></span><br><span class="line"><span class="string">          Sigmoid-10                    [-1, 1]               0</span></span><br><span class="line"><span class="string">================================================================</span></span><br><span class="line"><span class="string">Total params: 40,625</span></span><br><span class="line"><span class="string">Trainable params: 40,625</span></span><br><span class="line"><span class="string">Non-trainable params: 0</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">Input size (MB): 0.000763</span></span><br><span class="line"><span class="string">Forward/backward pass size (MB): 0.287796</span></span><br><span class="line"><span class="string">Params size (MB): 0.154972</span></span><br><span class="line"><span class="string">Estimated Total Size (MB): 0.443531</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_pred,y_true</span>):</span><br><span class="line">    y_pred = torch.where(y_pred&gt;<span class="number">0.5</span>,torch.ones_like(y_pred, dtype=torch.float32),</span><br><span class="line">                      torch.zeros_like(y_pred,dtype=torch.float32))</span><br><span class="line">    acc = torch.mean(<span class="number">1</span>-torch.<span class="built_in">abs</span>(y_true-y_pred))</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(loss_func = nn.BCELoss(),optimizer= torch.optim.Adagrad(model.parameters(),lr=<span class="number">0.02</span>),</span><br><span class="line">             metrics_dict=&#123;<span class="string">&quot;accuracy&quot;</span>:accuracy&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">dfhistory = model.fit(<span class="number">10</span>,dl_train,dl_val=dl_test,log_step_freq=<span class="number">200</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Start Training ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">================================================================================2020-07-11 23:21:53</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 200, &#x27;loss&#x27;: 0.956, &#x27;accuracy&#x27;: 0.521&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 400, &#x27;loss&#x27;: 0.823, &#x27;accuracy&#x27;: 0.53&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 600, &#x27;loss&#x27;: 0.774, &#x27;accuracy&#x27;: 0.545&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 800, &#x27;loss&#x27;: 0.747, &#x27;accuracy&#x27;: 0.56&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 1000, &#x27;loss&#x27;: 0.726, &#x27;accuracy&#x27;: 0.572&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> +-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">| epoch |  loss | accuracy | val_loss | val_accuracy |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">|   1   | 0.726 |  0.572   |  0.661   |    0.613     |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">================================================================================2020-07-11 23:22:20</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 200, &#x27;loss&#x27;: 0.605, &#x27;accuracy&#x27;: 0.668&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 400, &#x27;loss&#x27;: 0.602, &#x27;accuracy&#x27;: 0.674&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 600, &#x27;loss&#x27;: 0.592, &#x27;accuracy&#x27;: 0.681&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 800, &#x27;loss&#x27;: 0.584, &#x27;accuracy&#x27;: 0.687&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 1000, &#x27;loss&#x27;: 0.575, &#x27;accuracy&#x27;: 0.696&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> +-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">| epoch |  loss | accuracy | val_loss | val_accuracy |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">|   2   | 0.575 |  0.696   |  0.553   |    0.716     |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">================================================================================2020-07-11 23:25:53</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 200, &#x27;loss&#x27;: 0.294, &#x27;accuracy&#x27;: 0.877&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 400, &#x27;loss&#x27;: 0.299, &#x27;accuracy&#x27;: 0.875&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 600, &#x27;loss&#x27;: 0.298, &#x27;accuracy&#x27;: 0.875&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 800, &#x27;loss&#x27;: 0.296, &#x27;accuracy&#x27;: 0.876&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 1000, &#x27;loss&#x27;: 0.298, &#x27;accuracy&#x27;: 0.875&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> +-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">| epoch |  loss | accuracy | val_loss | val_accuracy |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">|   10  | 0.298 |  0.875   |  0.464   |    0.795     |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">================================================================================2020-07-11 23:26:19</span></span><br><span class="line"><span class="string">Finished Training...</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></div></div></div></p>
<p><strong>使用DataLoader加载数据集</strong><br />
DataLoader能够控制batch的大小，batch中元素的采样方法，以及将batch结果整理成模型所需输入形式的方法，并且能够使用多进程读取数据。<br />
DataLoader的函数签名如下：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DataLoader(</span><br><span class="line">    dataset,  <span class="comment"># 数据集</span></span><br><span class="line">    batch_size=<span class="number">1</span>,  <span class="comment"># 批次大小</span></span><br><span class="line">    shuffle=<span class="literal">False</span>,  <span class="comment"># 是否乱序，shuffle=True和sampler和batch_sampler自定义会冲突。</span></span><br><span class="line">    sampler=<span class="literal">None</span>,  <span class="comment"># 样本采样函数，一般无需设置。</span></span><br><span class="line">    batch_sampler=<span class="literal">None</span>,  <span class="comment"># 批次采样后处理函数,一般无需设置.若设置了那么batch_size,shuffle,sampler,drop_last都不用设置了。</span></span><br><span class="line">    num_workers=<span class="number">0</span>,  <span class="comment"># 使用多进程读取数据，设置的进程数。</span></span><br><span class="line">    collate_fn=<span class="literal">None</span>,  <span class="comment"># 处理一个批次数据的函数,对采样完的每一个batch数据进行处理,输入batch输出batch.常用于padding等操作。</span></span><br><span class="line">    pin_memory=<span class="literal">False</span>,  <span class="comment"># 是否设置为锁业内存。默认为False,锁业内存不会使用虚拟内存(硬盘),从锁业内存拷贝到GPU上速度会更快。</span></span><br><span class="line">    drop_last=<span class="literal">False</span>,  <span class="comment"># 是否丢弃最后一个样本数量不足batch_size批次数据。</span></span><br><span class="line">    timeout=<span class="number">0</span>,  <span class="comment"># 加载一个数据批次的最长等待时间，一般无需设置。</span></span><br><span class="line">    worker_init_fn=<span class="literal">None</span>,  <span class="comment"># 每个worker中dataset的初始化函数，常用于 IterableDataset。一般不使用。</span></span><br><span class="line">    multiprocessing_context=<span class="literal">None</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 一般情况下，我们仅仅会配置 dataset, batch_size, shuffle, num_workers, drop_last这五个参数，其他参数使用默认值即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sampler源码中使用了RandomSample(shuffle=Ture时)和SequentialSample：</span></span><br><span class="line">  <span class="comment"># RandomSample中使用了torch.randperm方法。</span></span><br><span class="line">  <span class="comment"># SequentialSample直接是iter(range(len(self.data.source)))。</span></span><br><span class="line"><span class="comment"># batch_size!=None and batch_sampler==None时用BatchSampler(sample,batch_size,drop_last)。</span></span><br><span class="line"><span class="comment"># collate_fn=None时默认会用default_conllate(batch)，它可以看作什么也没处理。如果自定义要遵循输入batch输出batch的格式。</span></span><br><span class="line"><span class="comment"># 支持迭代方式，__iter__中调用了self._get_iterator(),它又调用了_SingleProcessDataLoaderIter(当num_workers=0时),</span></span><br><span class="line">  <span class="comment"># 多进程用_MultiProcessingDataLoaderIter，不详细介绍此方法了。</span></span><br><span class="line">  <span class="comment"># _SingleProcessDataLoaderIter定义了_next_data方法,调用了_DatasetKind.create_fetcher(...).fetch(index)获取batch数据。</span></span><br><span class="line">  <span class="comment"># _SingleProcessDataLoaderIter继承自_BaseDataLoaderIter类，该类定义了__next__方法调用了_next_data方法，</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br />
两种加载数据方式：DataLoader除了可以加载
torch.utils.data.Dataset(官网叫<span class="exturl" data-url="aHR0cHM6Ly9weXRvcmNoLm9yZy9kb2NzL3N0YWJsZS9kYXRhLmh0bWwjbWFwLXN0eWxlLWRhdGFzZXRz">map-style
datasets<i class="fa fa-external-link-alt"></i></span>) 外，还能够加载另外一种数据集
torch.utils.data.IterableDataset(官网叫<span class="exturl" data-url="aHR0cHM6Ly9weXRvcmNoLm9yZy9kb2NzL3N0YWJsZS9kYXRhLmh0bWwjaXRlcmFibGUtc3R5bGUtZGF0YXNldHM=">iterable-style
datasets<i class="fa fa-external-link-alt"></i></span>)。和Dataset数据集相当于一种列表结构不同，IterableDataset相当于一种迭代器结构，
它更加复杂，多用于流式读取数据，一般较少使用。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构建输入数据管道</span></span><br><span class="line">ds = TensorDataset(torch.arange(<span class="number">1</span>,<span class="number">50</span>))</span><br><span class="line">dl = DataLoader(ds, batch_size=<span class="number">10</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#迭代数据</span></span><br><span class="line"><span class="keyword">for</span> batch, <span class="keyword">in</span> dl:</span><br><span class="line">    <span class="built_in">print</span>(batch)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">tensor([43, 44, 21, 36,  9,  5, 28, 16, 20, 14])</span></span><br><span class="line"><span class="string">tensor([23, 49, 35, 38,  2, 34, 45, 18, 15, 40])</span></span><br><span class="line"><span class="string">tensor([26,  6, 27, 39,  8,  4, 24, 19, 32, 17])</span></span><br><span class="line"><span class="string">tensor([ 1, 29, 11, 47, 12, 22, 48, 42, 10,  7])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="nn.functional和-nn.module">nn.functional和 nn.Module</h1>
<p>Pytorch和神经网络相关的功能组件大多都封装在torch.nn模块下。这些功能组件的绝大部分既有函数形式实现，也有类形式实现。其中nn.functional（一般引入后改名为F）有各种功能组件的函数实现。为了便于对参数进行管理，一般通过继承
nn.Module 转换成为类的实现形式，并直接封装在 nn 模块下：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 激活函数</span></span><br><span class="line">F.relu/nn.ReLU</span><br><span class="line">F.sigmoid/nn.Sigmoid</span><br><span class="line">F.tanh/nn.Tanh</span><br><span class="line">F.softmax/nn.Softmax</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型层</span></span><br><span class="line">F.linear/nn.Linear</span><br><span class="line">F.conv2d/nn.Conv2d</span><br><span class="line">F.max_pool2d/nn.MaxPool2d</span><br><span class="line">F.dropout2d/nn.Dropout2d</span><br><span class="line">F.embedding/nn.Embedding</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">F.binary_cross_entropy/nn.BCELoss</span><br><span class="line">F.mse_loss/nn.MSELoss</span><br><span class="line">F.cross_entropy/nn.CrossEntropyLoss</span><br></pre></td></tr></table></figure></p>
<p><strong>nn.Modules类的方法</strong>：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nn.Modules类是一切模块的基类，创建层或者网络结构都要继承此类。</span></span><br><span class="line">add_module(name, module) <span class="comment"># 添加子模块。</span></span><br><span class="line">apply(fn) <span class="comment"># 对子模块(.children()返回的模块)应用fn函数，可用于初始化。</span></span><br><span class="line"><span class="comment"># fn实际上也作用于parameter和buffer上了。</span></span><br><span class="line"></span><br><span class="line">children() <span class="comment"># 返回所有子模块(迭代器)。</span></span><br><span class="line">modules() <span class="comment"># 返回所有层级模块(迭代器)，包括本身。</span></span><br><span class="line"><span class="comment"># 可用._moudles返回字典。</span></span><br><span class="line">parameters(recurse=<span class="literal">True</span>) <span class="comment"># 返回所有参数(可反向传播)(迭代器)。</span></span><br><span class="line"><span class="comment"># ._parameters只提供模型中显示创建的Parameter类变量(不会遍历子模块)，空字典不代表模型没有参数。</span></span><br><span class="line">buffers(recurse=<span class="literal">True</span>) <span class="comment"># 类似tf.constant，存储常量。Parameter和buffer关系：https://zhuanlan.zhihu.com/p/89442276</span></span><br><span class="line"><span class="comment"># ._buffers和._parameters一样，只提供模型中显示创建的buffers(不会遍历子模块)。</span></span><br><span class="line"></span><br><span class="line">named_children() <span class="comment"># 返回所有子模块名称和值。</span></span><br><span class="line">named_modules(memo=<span class="literal">None</span>, prefix=<span class="string">&#x27;&#x27;</span>, remove_duplicate=<span class="literal">True</span>) <span class="comment"># 返回所有层级模块名称和值，包括本身。</span></span><br><span class="line">named_parameters(prefix=<span class="string">&#x27;&#x27;</span>, recurse=<span class="literal">True</span>) <span class="comment"># 返回所有参数名称和值。</span></span><br><span class="line">named_buffers(prefix=<span class="string">&#x27;&#x27;</span>, recurse=<span class="literal">True</span>) <span class="comment"># 返回所有buffer名称和值。</span></span><br><span class="line"></span><br><span class="line">register_buffer(name, tensor, persistent=<span class="literal">True</span>) <span class="comment"># 注册buffer到model。</span></span><br><span class="line"><span class="comment"># persistent是否作为参数保存到磁盘上，在torch.save中调用model.state_dict()生效。</span></span><br><span class="line">register_parameter(name, param) <span class="comment"># 注册parameter到model。</span></span><br><span class="line"><span class="comment"># param必须是torch.nn.parameter.Parameter类的实例。</span></span><br><span class="line"></span><br><span class="line">get_buffer(target) <span class="comment"># 获取buffer，target为目标名称(字符串)。</span></span><br><span class="line">get_parameter(target) <span class="comment"># 获取parameter，target为目标名称(字符串)。</span></span><br><span class="line">get_submodule(target) <span class="comment"># 获取子模块，target为目标名称(字符串)。</span></span><br><span class="line"></span><br><span class="line">cpu() <span class="comment"># 模型(parameters and buffers)放入cpu运行。</span></span><br><span class="line">cuda(device=<span class="literal">None</span>) <span class="comment"># 模型(parameters and buffers)放入gpu运行。</span></span><br><span class="line"><span class="built_in">eval</span>() <span class="comment"># 设置成验证模式，不进行梯度计算。 </span></span><br><span class="line">train(mode=<span class="literal">True</span>) <span class="comment"># 设置成训练模式。</span></span><br><span class="line"></span><br><span class="line">load_state_dict(state_dict, strict=<span class="literal">True</span>) <span class="comment"># 加载parameter和buffer到模型中。</span></span><br><span class="line">state_dict(destination=<span class="literal">None</span>, prefix=<span class="string">&#x27;&#x27;</span>, keep_vars=<span class="literal">False</span>) <span class="comment"># 返回模型所有参数，字典格式。</span></span><br><span class="line">requires_grad_(requires_grad=<span class="literal">True</span>) <span class="comment"># 参数是否需要梯度更新？</span></span><br><span class="line">zero_grad(set_to_none=<span class="literal">False</span>) <span class="comment"># 参数梯度清零。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下转换都是针对parameter和buffer。</span></span><br><span class="line">bfloat16() <span class="comment"># float转换成bfloat16(只对float有效)。</span></span><br><span class="line">half() <span class="comment"># float转换成半精度float(只对float有效)。</span></span><br><span class="line"><span class="built_in">float</span>() <span class="comment"># float转换成float(只对float有效)。</span></span><br><span class="line">double() <span class="comment"># # float转换成双精度(只对float有效)。</span></span><br><span class="line">to_empty(*, device) <span class="comment"># 拷贝parameter和buffer的空张量，到指定设备。</span></span><br><span class="line">to(*args, **kwargs)：<span class="comment"># 转换，多种选择。</span></span><br><span class="line">    <span class="comment">#to(device=None, dtype=None, non_blocking=False)</span></span><br><span class="line">    <span class="comment">#to(dtype, non_blocking=False)</span></span><br><span class="line">    <span class="comment">#to(tensor, non_blocking=False)</span></span><br><span class="line">    <span class="comment">#to(memory_format=torch.channels_last)</span></span><br></pre></td></tr></table></figure><br />
<strong>使用nn.Module来管理参数</strong>：<br />
在Pytorch中，模型的参数是需要被优化器训练的，因此，通常要设置参数为
requires_grad=True 的张量。<br />
同时，在一个模型中，往往有许多的参数，要手动管理这些参数并不是一件容易的事情。<br />
Pytorch一般将参数用nn.Parameter来表示，并且用nn.Module来管理其结构下的所有参数。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn </span><br><span class="line"><span class="keyword">import</span> torch.nn.functional  <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># nn.Parameter 具有 requires_grad=True 属性</span></span><br><span class="line">w = nn.Parameter(torch.randn(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(w)</span><br><span class="line"><span class="built_in">print</span>(w.requires_grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Parameter containing:</span></span><br><span class="line"><span class="string">tensor([[ 0.3544, -1.1643],</span></span><br><span class="line"><span class="string">        [ 1.2302,  1.3952]], requires_grad=True)</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># nn.ParameterList 可以将多个nn.Parameter组成一个列表</span></span><br><span class="line">params_list = nn.ParameterList([nn.Parameter(torch.rand(<span class="number">2</span>,i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3</span>)])</span><br><span class="line"><span class="built_in">print</span>(params_list)</span><br><span class="line"><span class="built_in">print</span>(params_list[<span class="number">0</span>].requires_grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ParameterList(</span></span><br><span class="line"><span class="string">    (0): Parameter containing: [torch.FloatTensor of size 2x1]</span></span><br><span class="line"><span class="string">    (1): Parameter containing: [torch.FloatTensor of size 2x2]</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># nn.ParameterDict 可以将多个nn.Parameter组成一个字典</span></span><br><span class="line">params_dict = nn.ParameterDict(&#123;<span class="string">&quot;a&quot;</span>:nn.Parameter(torch.rand(<span class="number">2</span>,<span class="number">2</span>)),</span><br><span class="line">                                <span class="string">&quot;b&quot;</span>:nn.Parameter(torch.zeros(<span class="number">2</span>))&#125;)</span><br><span class="line"><span class="built_in">print</span>(params_dict)</span><br><span class="line"><span class="built_in">print</span>(params_dict[<span class="string">&quot;a&quot;</span>].requires_grad)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ParameterDict(</span></span><br><span class="line"><span class="string">    (a): Parameter containing: [torch.FloatTensor of size 2x2]</span></span><br><span class="line"><span class="string">    (b): Parameter containing: [torch.FloatTensor of size 2]</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 可以用Module将它们管理起来</span></span><br><span class="line"><span class="comment"># module.parameters()返回一个生成器，包括其结构下的所有parameters</span></span><br><span class="line">module = nn.Module()</span><br><span class="line">module.w = w</span><br><span class="line">module.params_list = params_list</span><br><span class="line">module.params_dict = params_dict</span><br><span class="line"></span><br><span class="line">num_param = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> module.parameters():</span><br><span class="line">    <span class="built_in">print</span>(param,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    num_param = num_param + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;number of Parameters =&quot;</span>, num_param)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Parameter containing:</span></span><br><span class="line"><span class="string">tensor([[ 0.3544, -1.1643],</span></span><br><span class="line"><span class="string">        [ 1.2302,  1.3952]], requires_grad=True) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameter containing:</span></span><br><span class="line"><span class="string">tensor([[0.9391],</span></span><br><span class="line"><span class="string">        [0.1353]], requires_grad=True) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameter containing:</span></span><br><span class="line"><span class="string">tensor([[0.8012, 0.9587],</span></span><br><span class="line"><span class="string">        [0.3418, 0.7291]], requires_grad=True) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameter containing:</span></span><br><span class="line"><span class="string">tensor([[0.7729, 0.2383],</span></span><br><span class="line"><span class="string">        [0.7054, 0.9937]], requires_grad=True) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Parameter containing:</span></span><br><span class="line"><span class="string">tensor([0., 0.], requires_grad=True) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">number of Parameters = 5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实践当中，一般通过继承nn.Module来构建模块类，并将所有含有需要学习的参数的部分放在构造函数中。</span></span><br><span class="line"><span class="comment">#以下范例为Pytorch中nn.Linear的源码的简化版本</span></span><br><span class="line"><span class="comment">#可以看到它将需要学习的参数放在了__init__构造函数中，并在forward中调用F.linear函数来实现计算逻辑。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span>(nn.Module):</span><br><span class="line">    __constants__ = [<span class="string">&#x27;in_features&#x27;</span>, <span class="string">&#x27;out_features&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_features, out_features, bias=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Linear, self).__init__()</span><br><span class="line">        self.in_features = in_features</span><br><span class="line">        self.out_features = out_features</span><br><span class="line">        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))</span><br><span class="line">        <span class="keyword">if</span> bias:</span><br><span class="line">            self.bias = nn.Parameter(torch.Tensor(out_features))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.register_parameter(<span class="string">&#x27;bias&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        <span class="keyword">return</span> F.linear(<span class="built_in">input</span>, self.weight, self.bias)</span><br></pre></td></tr></table></figure></p>
<p><strong>使用nn.Module来管理子模块</strong>：<br />
一般情况下，我们都很少直接使用nn.Parameter来定义参数构建模型，而是通过一些拼装一些常用的模型层来构造模型。这些模型层也是继承自nn.Module的对象，本身也包括参数，属于我们要定义的模块的子模块。nn.Module提供了一些方法可以管理这些子模块：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">children() <span class="comment"># 返回生成器，包括模块下的所有子模块。</span></span><br><span class="line">named_children() <span class="comment"># 返回一个生成器，包括模块下的所有子模块，以及它们的名字。</span></span><br><span class="line">modules() <span class="comment"># 返回一个生成器，包括模块下的所有各个层级的模块，包括模块本身。</span></span><br><span class="line">named_modules() <span class="comment"># 返回一个生成器，包括模块下的所有各个层级的模块以及它们的名字，包括模块本身。</span></span><br></pre></td></tr></table></figure><br />
其中chidren()方法和named_children()方法较多使用。<br />
modules()方法和named_modules()方法较少使用，其功能可以通过多个named_children()的嵌套使用实现。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.embedding = nn.Embedding(num_embeddings=<span class="number">10000</span>,embedding_dim=<span class="number">3</span>,padding_idx=<span class="number">1</span>)</span><br><span class="line">        self.conv = nn.Sequential()</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;conv_1&quot;</span>,nn.Conv1d(in_channels=<span class="number">3</span>,out_channels=<span class="number">16</span>,kernel_size=<span class="number">5</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;pool_1&quot;</span>,nn.MaxPool1d(kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;relu_1&quot;</span>,nn.ReLU())</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;conv_2&quot;</span>,nn.Conv1d(in_channels=<span class="number">16</span>,out_channels=<span class="number">128</span>,kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;pool_2&quot;</span>,nn.MaxPool1d(kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv.add_module(<span class="string">&quot;relu_2&quot;</span>,nn.ReLU())</span><br><span class="line"></span><br><span class="line">        self.dense = nn.Sequential()</span><br><span class="line">        self.dense.add_module(<span class="string">&quot;flatten&quot;</span>,nn.Flatten())</span><br><span class="line">        self.dense.add_module(<span class="string">&quot;linear&quot;</span>,nn.Linear(<span class="number">6144</span>,<span class="number">1</span>))</span><br><span class="line">        self.dense.add_module(<span class="string">&quot;sigmoid&quot;</span>,nn.Sigmoid())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.embedding(x).transpose(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">        x = self.conv(x)</span><br><span class="line">        y = self.dense(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印子模块</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> net.children():</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(child,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;child number&quot;</span>,i)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Embedding(10000, 3, padding_idx=1) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sequential(</span></span><br><span class="line"><span class="string">  (conv_1): Conv1d(3, 16, kernel_size=(5,), stride=(1,))</span></span><br><span class="line"><span class="string">  (pool_1): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">  (relu_1): ReLU()</span></span><br><span class="line"><span class="string">  (conv_2): Conv1d(16, 128, kernel_size=(2,), stride=(1,))</span></span><br><span class="line"><span class="string">  (pool_2): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">  (relu_2): ReLU()</span></span><br><span class="line"><span class="string">) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Sequential(</span></span><br><span class="line"><span class="string">  (flatten): Flatten()</span></span><br><span class="line"><span class="string">  (linear): Linear(in_features=6144, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">  (sigmoid): Sigmoid()</span></span><br><span class="line"><span class="string">) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">child number 3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 打印子模块名字和子模块</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> name,child <span class="keyword">in</span> net.named_children():</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(name,<span class="string">&quot;:&quot;</span>,child,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;child number&quot;</span>,i)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">embedding : Embedding(10000, 3, padding_idx=1) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">conv : Sequential(</span></span><br><span class="line"><span class="string">  (conv_1): Conv1d(3, 16, kernel_size=(5,), stride=(1,))</span></span><br><span class="line"><span class="string">  (pool_1): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">  (relu_1): ReLU()</span></span><br><span class="line"><span class="string">  (conv_2): Conv1d(16, 128, kernel_size=(2,), stride=(1,))</span></span><br><span class="line"><span class="string">  (pool_2): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">  (relu_2): ReLU()</span></span><br><span class="line"><span class="string">) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dense : Sequential(</span></span><br><span class="line"><span class="string">  (flatten): Flatten()</span></span><br><span class="line"><span class="string">  (linear): Linear(in_features=6144, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">  (sigmoid): Sigmoid()</span></span><br><span class="line"><span class="string">) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">child number 3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 打印各级模块</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> module <span class="keyword">in</span> net.modules():</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(module)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;module number:&quot;</span>,i)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Net(</span></span><br><span class="line"><span class="string">  (embedding): Embedding(10000, 3, padding_idx=1)</span></span><br><span class="line"><span class="string">  (conv): Sequential(</span></span><br><span class="line"><span class="string">    (conv_1): Conv1d(3, 16, kernel_size=(5,), stride=(1,))</span></span><br><span class="line"><span class="string">    (pool_1): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">    (relu_1): ReLU()</span></span><br><span class="line"><span class="string">    (conv_2): Conv1d(16, 128, kernel_size=(2,), stride=(1,))</span></span><br><span class="line"><span class="string">    (pool_2): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">    (relu_2): ReLU()</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">  (dense): Sequential(</span></span><br><span class="line"><span class="string">    (flatten): Flatten()</span></span><br><span class="line"><span class="string">    (linear): Linear(in_features=6144, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">    (sigmoid): Sigmoid()</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">Embedding(10000, 3, padding_idx=1)</span></span><br><span class="line"><span class="string">Sequential(</span></span><br><span class="line"><span class="string">  (conv_1): Conv1d(3, 16, kernel_size=(5,), stride=(1,))</span></span><br><span class="line"><span class="string">  (pool_1): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">  (relu_1): ReLU()</span></span><br><span class="line"><span class="string">  (conv_2): Conv1d(16, 128, kernel_size=(2,), stride=(1,))</span></span><br><span class="line"><span class="string">  (pool_2): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">  (relu_2): ReLU()</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">Conv1d(3, 16, kernel_size=(5,), stride=(1,))</span></span><br><span class="line"><span class="string">MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">ReLU()</span></span><br><span class="line"><span class="string">Conv1d(16, 128, kernel_size=(2,), stride=(1,))</span></span><br><span class="line"><span class="string">MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">ReLU()</span></span><br><span class="line"><span class="string">Sequential(</span></span><br><span class="line"><span class="string">  (flatten): Flatten()</span></span><br><span class="line"><span class="string">  (linear): Linear(in_features=6144, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">  (sigmoid): Sigmoid()</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">Flatten()</span></span><br><span class="line"><span class="string">Linear(in_features=6144, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">Sigmoid()</span></span><br><span class="line"><span class="string">module number: 13</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br />
可通过named_children方法找到embedding层，并将其参数设置为不可训练(相当于冻结embedding层)。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">children_dict = &#123;name:module <span class="keyword">for</span> name,module <span class="keyword">in</span> net.named_children()&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(children_dict)</span><br><span class="line">embedding = children_dict[<span class="string">&quot;embedding&quot;</span>]</span><br><span class="line">embedding.requires_grad_(<span class="literal">False</span>) <span class="comment">#冻结其参数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;embedding&#x27;: Embedding(10000, 3, padding_idx=1), &#x27;conv&#x27;: Sequential(</span></span><br><span class="line"><span class="string">  (conv_1): Conv1d(3, 16, kernel_size=(5,), stride=(1,))</span></span><br><span class="line"><span class="string">  (pool_1): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">  (relu_1): ReLU()</span></span><br><span class="line"><span class="string">  (conv_2): Conv1d(16, 128, kernel_size=(2,), stride=(1,))</span></span><br><span class="line"><span class="string">  (pool_2): MaxPool1d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">  (relu_2): ReLU()</span></span><br><span class="line"><span class="string">), &#x27;dense&#x27;: Sequential(</span></span><br><span class="line"><span class="string">  (flatten): Flatten()</span></span><br><span class="line"><span class="string">  (linear): Linear(in_features=6144, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">  (sigmoid): Sigmoid()</span></span><br><span class="line"><span class="string">)&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#可以看到其第一层的参数已经不可以被训练了。</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> embedding.parameters():</span><br><span class="line">    <span class="built_in">print</span>(param.requires_grad)</span><br><span class="line">    <span class="built_in">print</span>(param.numel())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">30000</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># totchsummary包也实现了summary功能，用法一样</span></span><br><span class="line"><span class="keyword">from</span> torchkeras <span class="keyword">import</span> summary</span><br><span class="line">summary(net,input_shape=(<span class="number">200</span>,),input_dtype=torch.LongTensor)</span><br><span class="line"><span class="comment"># 不可训练参数数量增加</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">        Layer (type)               Output Shape         Param #</span></span><br><span class="line"><span class="string">================================================================</span></span><br><span class="line"><span class="string">         Embedding-1               [-1, 200, 3]          30,000</span></span><br><span class="line"><span class="string">            Conv1d-2              [-1, 16, 196]             256</span></span><br><span class="line"><span class="string">         MaxPool1d-3               [-1, 16, 98]               0</span></span><br><span class="line"><span class="string">              ReLU-4               [-1, 16, 98]               0</span></span><br><span class="line"><span class="string">            Conv1d-5              [-1, 128, 97]           4,224</span></span><br><span class="line"><span class="string">         MaxPool1d-6              [-1, 128, 48]               0</span></span><br><span class="line"><span class="string">              ReLU-7              [-1, 128, 48]               0</span></span><br><span class="line"><span class="string">           Flatten-8                 [-1, 6144]               0</span></span><br><span class="line"><span class="string">            Linear-9                    [-1, 1]           6,145</span></span><br><span class="line"><span class="string">          Sigmoid-10                    [-1, 1]               0</span></span><br><span class="line"><span class="string">================================================================</span></span><br><span class="line"><span class="string">Total params: 40,625</span></span><br><span class="line"><span class="string">Trainable params: 10,625</span></span><br><span class="line"><span class="string">Non-trainable params: 30,000</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">Input size (MB): 0.000763</span></span><br><span class="line"><span class="string">Forward/backward pass size (MB): 0.287796</span></span><br><span class="line"><span class="string">Params size (MB): 0.154972</span></span><br><span class="line"><span class="string">Estimated Total Size (MB): 0.443531</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br />
<strong>创建基础的神经网络：</strong><br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Using <span class="subst">&#123;device&#125;</span> device&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Using cuda device</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(NeuralNetwork, self).__init__()</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.linear_relu_stack = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">28</span>*<span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        logits = self.linear_relu_stack(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line">model = NeuralNetwork().to(device)</span><br><span class="line"><span class="built_in">print</span>(model)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">NeuralNetwork(</span></span><br><span class="line"><span class="string">  (flatten): Flatten(start_dim=1, end_dim=-1)</span></span><br><span class="line"><span class="string">  (linear_relu_stack): Sequential(</span></span><br><span class="line"><span class="string">    (0): Linear(in_features=784, out_features=512, bias=True)</span></span><br><span class="line"><span class="string">    (1): ReLU()</span></span><br><span class="line"><span class="string">    (2): Linear(in_features=512, out_features=512, bias=True)</span></span><br><span class="line"><span class="string">    (3): ReLU()</span></span><br><span class="line"><span class="string">    (4): Linear(in_features=512, out_features=10, bias=True)</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">X = torch.rand(<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, device=device)</span><br><span class="line">logits = model(X)</span><br><span class="line">pred_probab = nn.Softmax(dim=<span class="number">1</span>)(logits)</span><br><span class="line">y_pred = pred_probab.argmax(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Predicted class: <span class="subst">&#123;y_pred&#125;</span>&quot;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Predicted class: tensor([7], device=&#x27;cuda:0&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="containers">containers</h1>
<p>Pytorch中除了torch.nn.Module，还有很多<span class="exturl" data-url="aHR0cHM6Ly9weXRvcmNoLm9yZy9kb2NzL3N0YWJsZS9ubi5odG1sI2NvbnRhaW5lcnM=">容器<i class="fa fa-external-link-alt"></i></span>：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sequential具有forward方法，而ModuleList等只是容器，所以Sequential用的更多些。</span></span><br><span class="line">torch.nn.Sequential(*args) </span><br><span class="line">torch.nn.ModuleList(modules=<span class="literal">None</span>) <span class="comment"># 模块列表，和python列表不同的是继承了nn.Module方法。默认module名称是从0开始。</span></span><br><span class="line">torch.nn.ModuleDict(modules=<span class="literal">None</span>) <span class="comment"># 模块字典，可自定义模型名称了。</span></span><br><span class="line">torch.nn.ParameterList(parameters=<span class="literal">None</span>)</span><br><span class="line">torch.nn.ParameterDict(parameters=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="save">save</h1>
<p>Pytorch模型的保存：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://pytorch.org/tutorials/recipes/recipes/saving_and_loading_a_general_checkpoint.html</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the general checkpoint</span></span><br><span class="line">EPOCH = <span class="number">5</span></span><br><span class="line">PATH = <span class="string">&quot;model.pt&quot;</span></span><br><span class="line">LOSS = <span class="number">0.4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">torch.save(&#123;</span><br><span class="line">            <span class="string">&#x27;epoch&#x27;</span>: EPOCH,</span><br><span class="line">            <span class="string">&#x27;model_state_dict&#x27;</span>: net.state_dict(), <span class="comment"># 包括parameter和buffer</span></span><br><span class="line">            <span class="string">&#x27;optimizer_state_dict&#x27;</span>: optimizer.state_dict(),</span><br><span class="line">            <span class="string">&#x27;loss&#x27;</span>: LOSS,</span><br><span class="line">            &#125;, PATH)</span><br><span class="line"><span class="comment"># Load the general checkpoint</span></span><br><span class="line">model = Net()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line">checkpoint = torch.load(PATH)</span><br><span class="line">model.load_state_dict(checkpoint[<span class="string">&#x27;model_state_dict&#x27;</span>])</span><br><span class="line">optimizer.load_state_dict(checkpoint[<span class="string">&#x27;optimizer_state_dict&#x27;</span>])</span><br><span class="line">epoch = checkpoint[<span class="string">&#x27;epoch&#x27;</span>]</span><br><span class="line">loss = checkpoint[<span class="string">&#x27;loss&#x27;</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="layers">layers</h1>
<p>深度学习模型一般由各种模型层组合而成。torch.nn中内置了非常丰富的各种模型层。它们都属于nn.Module的子类，具备参数管理功能。如果这些内置模型层不能够满足需求，也可以通过继承nn.Module基类构建自定义的模型层。实际上，Pytorch不区分模型和模型层，都是通过继承nn.Module进行构建。因此，只要继承nn.Module基类并实现forward方法即可自定义模型层。更多层的定义参考<span class="exturl" data-url="aHR0cHM6Ly9weXRvcmNoLm9yZy9kb2NzL3N0YWJsZS9ubi5odG1s">torch.nn<i class="fa fa-external-link-alt"></i></span>。</p>
<p>基础层：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">nn.Linear <span class="comment"># 全连接层。参数个数=输入层特征数×输出层特征数(weight)＋输出层特征数(bias)</span></span><br><span class="line"></span><br><span class="line">nn.Flatten <span class="comment"># 压平层，用于将多维张量(从维度1开始)样本压成一维张量样本。</span></span><br><span class="line"></span><br><span class="line">nn.BatchNorm1d <span class="comment"># 一维批标准化层。通过线性变换将输入批次缩放平移到稳定的均值和标准差。</span></span><br><span class="line"><span class="comment"># 可以增强模型对输入不同分布的适应性，加快模型训练速度，有轻微正则化效果。</span></span><br><span class="line"><span class="comment"># 一般在激活函数之前使用。可以用afine参数设置该层是否含有可以训练的参数。</span></span><br><span class="line"></span><br><span class="line">nn.BatchNorm2d <span class="comment"># 二维批标准化层。</span></span><br><span class="line"></span><br><span class="line">nn.BatchNorm3d <span class="comment"># 三维批标准化层。</span></span><br><span class="line"></span><br><span class="line">nn.Dropout <span class="comment"># 一维随机丢弃层。一种正则化手段。</span></span><br><span class="line"></span><br><span class="line">nn.Dropout2d <span class="comment"># 二维随机丢弃层。</span></span><br><span class="line"></span><br><span class="line">nn.Dropout3d <span class="comment"># 三维随机丢弃层。</span></span><br><span class="line"></span><br><span class="line">nn.Threshold <span class="comment"># 限幅层。当输入大于或小于阈值范围时，截断之。</span></span><br><span class="line"></span><br><span class="line">nn.ConstantPad2d <span class="comment"># 二维常数填充层。对二维张量样本填充常数扩展长度。</span></span><br><span class="line"></span><br><span class="line">nn.ReplicationPad1d <span class="comment"># 一维复制填充层。对一维张量样本通过复制边缘值填充扩展长度。</span></span><br><span class="line"></span><br><span class="line">nn.ZeroPad2d <span class="comment"># 二维零值填充层。对二维张量样本在边缘填充0值.</span></span><br><span class="line"></span><br><span class="line">nn.GroupNorm <span class="comment"># 组归一化。一种替代批归一化的方法，将通道分成若干组进行归一。</span></span><br><span class="line"><span class="comment"># 不受batch大小限制，据称性能和效果都优于BatchNorm。</span></span><br><span class="line"></span><br><span class="line">nn.LayerNorm <span class="comment"># 层归一化。较少使用。</span></span><br><span class="line"></span><br><span class="line">nn.InstanceNorm2d <span class="comment"># 样本归一化。较少使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各种归一化技术参考如下知乎文章:https://zhuanlan.zhihu.com/p/34858971</span></span><br></pre></td></tr></table></figure><br />
卷积网络相关层：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">nn.Conv1d <span class="comment"># 普通一维卷积，常用于文本。参数个数=输入通道数×卷积核尺寸(如3)×卷积核个数+卷积核尺寸(如3)。</span></span><br><span class="line"></span><br><span class="line">nn.Conv2d <span class="comment"># 普通二维卷积，常用于图像。参数个数=输入通道数×卷积核尺寸(如3乘3)×卷积核个数+卷积核尺寸(如3乘3)。</span></span><br><span class="line"><span class="comment"># 通过调整dilation参数大于1，可以变成空洞卷积，增大卷积核感受野。</span></span><br><span class="line"><span class="comment"># 通过调整groups参数不为1，可以变成分组卷积。分组卷积中不同分组使用相同的卷积核，显著减少参数数量。</span></span><br><span class="line"><span class="comment"># 当groups参数等于通道数时，相当于tensorflow中的二维深度卷积层tf.keras.layers.DepthwiseConv2D。</span></span><br><span class="line"><span class="comment"># 利用分组卷积和1乘1卷积的组合操作，可以构造相当于Keras中的二维深度可分离卷积层tf.keras.layers.SeparableConv2D。</span></span><br><span class="line"></span><br><span class="line">nn.Conv3d <span class="comment"># 普通三维卷积，常用于视频。参数个数=输入通道数×卷积核尺寸(如3乘3乘3)×卷积核个数+卷积核尺寸(如3乘3乘3)。</span></span><br><span class="line"></span><br><span class="line">nn.MaxPool1d <span class="comment"># 一维最大池化。</span></span><br><span class="line"></span><br><span class="line">nn.MaxPool2d <span class="comment"># 二维最大池化。一种下采样方式。没有需要训练的参数。</span></span><br><span class="line"></span><br><span class="line">nn.MaxPool3d <span class="comment"># 三维最大池化。</span></span><br><span class="line"></span><br><span class="line">nn.AdaptiveMaxPool2d <span class="comment"># 二维自适应最大池化。无论输入图像的尺寸如何变化，输出的图像尺寸是固定的。</span></span><br><span class="line"><span class="comment"># 该函数的实现原理，大概是通过输入图像的尺寸和要得到的输出图像的尺寸来反向推算池化算子的padding,stride等参数。</span></span><br><span class="line"></span><br><span class="line">nn.FractionalMaxPool2d <span class="comment"># 二维分数最大池化。普通最大池化通常输入尺寸是输出的整数倍。而分数最大池化则可以不必是整数。</span></span><br><span class="line"><span class="comment"># 分数最大池化使用了一些随机采样策略，有一定的正则效果，可以用它来代替普通最大池化和Dropout层。</span></span><br><span class="line"></span><br><span class="line">nn.AvgPool2d <span class="comment"># 二维平均池化。</span></span><br><span class="line"></span><br><span class="line">nn.AdaptiveAvgPool2d <span class="comment"># 二维自适应平均池化。无论输入的维度如何变化，输出的维度是固定的。</span></span><br><span class="line"></span><br><span class="line">nn.ConvTranspose2d <span class="comment"># 二维卷积转置层，俗称反卷积层。</span></span><br><span class="line"><span class="comment"># 并非卷积的逆操作，但在卷积核相同的情况下，当其输入尺寸是卷积操作输出尺寸的情况下，</span></span><br><span class="line"><span class="comment"># 卷积转置的输出尺寸恰好是卷积操作的输入尺寸。在语义分割中可用于上采样。</span></span><br><span class="line"></span><br><span class="line">nn.Upsample <span class="comment"># 上采样层，操作效果和池化相反。可以通过mode参数控制上采样策略为&quot;nearest&quot;最邻近策略或&quot;linear&quot;线性插值策略。</span></span><br><span class="line"></span><br><span class="line">nn.Unfold <span class="comment"># 滑动窗口提取层。其参数和卷积操作nn.Conv2d相同。</span></span><br><span class="line"><span class="comment"># 实际上，卷积操作可以等价于nn.Unfold和nn.Linear以及nn.Fold的一个组合。</span></span><br><span class="line"><span class="comment"># 其中nn.Unfold操作可以从输入中提取各个滑动窗口的数值矩阵，并将其压平成一维。</span></span><br><span class="line"><span class="comment"># 利用nn.Linear将nn.Unfold的输出和卷积核做乘法后，再使用nn.Fold操作将结果转换成输出图片形状。</span></span><br><span class="line"></span><br><span class="line">nn.Fold <span class="comment"># 逆滑动窗口提取层。</span></span><br></pre></td></tr></table></figure><br />
循环网络相关层：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nn.Embedding <span class="comment"># 嵌入层。一种比Onehot更加有效的对离散特征进行编码的方法。</span></span><br><span class="line"><span class="comment"># 一般用于将输入中的单词映射为稠密向量。嵌入层的参数需要学习。</span></span><br><span class="line"></span><br><span class="line">nn.LSTM <span class="comment"># 长短记忆循环网络层【支持多层】。最普遍使用的循环网络层。</span></span><br><span class="line"><span class="comment"># 具有携带轨道，遗忘门，更新门，输出门。可以较为有效地缓解梯度消失问题，从而能够适用长期依赖问题。</span></span><br><span class="line"><span class="comment"># 设置bidirectional=True时可以得到双向LSTM。需要注意的是，</span></span><br><span class="line"><span class="comment"># 默认的输入和输出形状是(seq,batch,feature), 如果需要将batch维度放在第0维，则要设置batch_first参数设置为True。</span></span><br><span class="line"></span><br><span class="line">nn.GRU <span class="comment"># 门控循环网络层【支持多层】。LSTM的低配版，不具有携带轨道，参数数量少于LSTM，训练速度更快。</span></span><br><span class="line"></span><br><span class="line">nn.RNN <span class="comment"># 简单循环网络层【支持多层】。容易存在梯度消失，不能够适用长期依赖问题。一般较少使用。</span></span><br><span class="line"></span><br><span class="line">nn.LSTMCell <span class="comment"># 长短记忆循环网络单元。和nn.LSTM在整个序列上迭代相比，它仅在序列上迭代一步。一般较少使用。</span></span><br><span class="line"></span><br><span class="line">nn.GRUCell <span class="comment"># 门控循环网络单元。和nn.GRU在整个序列上迭代相比，它仅在序列上迭代一步。一般较少使用。</span></span><br><span class="line"></span><br><span class="line">nn.RNNCell <span class="comment"># 简单循环网络单元。和nn.RNN在整个序列上迭代相比，它仅在序列上迭代一步。一般较少使用。</span></span><br></pre></td></tr></table></figure><br />
Transformer相关层(它是目前NLP任务的主流模型的主要构成部分)：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Transformer网络结构是替代循环网络的一种结构，解决了循环网络难以并行，难以捕捉长期依赖的缺陷。</span></span><br><span class="line"><span class="comment"># Transformer网络结构由TransformerEncoder编码器和TransformerDecoder解码器组成。</span></span><br><span class="line"><span class="comment"># 编码器和解码器的核心是MultiheadAttention多头注意力层。</span></span><br><span class="line"><span class="comment"># Transformer原理介绍可以参考如下知乎文章：https://zhuanlan.zhihu.com/p/48508221</span></span><br><span class="line">nn.Transformer <span class="comment"># Transformer网络结构。</span></span><br><span class="line"></span><br><span class="line">nn.TransformerEncoder <span class="comment"># Transformer编码器结构。由多个 nn.TransformerEncoderLayer编码器层组成。</span></span><br><span class="line"></span><br><span class="line">nn.TransformerDecoder <span class="comment"># Transformer解码器结构。由多个 nn.TransformerDecoderLayer解码器层组成。</span></span><br><span class="line"></span><br><span class="line">nn.TransformerEncoderLayer <span class="comment"># Transformer的编码器层。</span></span><br><span class="line"></span><br><span class="line">nn.TransformerDecoderLayer <span class="comment"># Transformer的解码器层。</span></span><br><span class="line"></span><br><span class="line">nn.MultiheadAttention <span class="comment"># 多头注意力层。</span></span><br></pre></td></tr></table></figure></p>
<h1 id="losses">losses</h1>
<p>一般来说，监督学习的目标函数由损失函数和正则化项组成。(Objective =
Loss + Regularization)</p>
<p>Pytorch中的损失函数一般在训练模型时候指定。注意Pytorch中内置的损失函数的参数和tensorflow不同，是y_pred在前，y_true在后，而Tensorflow是y_true在前，y_pred在后。</p>
<p>对于回归模型，通常使用的内置损失函数是均方损失函数nn.MSELoss
。对于二分类模型，通常使用的是二元交叉熵损失函数nn.BCELoss
(输入已经是sigmoid激活函数之后的结果) 或者 nn.BCEWithLogitsLoss
(输入尚未经过nn.Sigmoid激活函数) 。</p>
<p>对于多分类模型，一般推荐使用交叉熵损失函数
nn.CrossEntropyLoss。(y_true需要是一维的，是类别编码。y_pred未经过nn.Softmax激活)。此外，如果多分类的y_pred经过了nn.LogSoftmax激活，可以使用nn.NLLLoss损失函数(The
negative log likelihood
loss)。这种方法和直接使用nn.CrossEntropyLoss等价。</p>
<p>也可以自定义损失函数，自定义损失函数需要接收两个张量y_pred，y_true作为输入参数，并输出一个标量作为损失函数值。Pytorch中的正则化项一般通过自定义的方式和损失函数一起添加作为目标函数。如果仅仅使用L2正则化，也可以利用优化器的weight_decay参数来实现相同的效果。</p>
<p>常用的一些内置损失函数：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更多损失函数：https://zhuanlan.zhihu.com/p/61379965</span></span><br><span class="line"><span class="comment"># 官网：https://pytorch.org/docs/stable/nn.html#loss-functions</span></span><br><span class="line">nn.MSELoss <span class="comment"># 均方误差损失，也叫做L2损失，用于回归</span></span><br><span class="line"></span><br><span class="line">nn.L1Loss <span class="comment"># L1损失，也叫做绝对值误差损失，用于回归</span></span><br><span class="line"></span><br><span class="line">nn.SmoothL1Loss  <span class="comment"># 平滑L1损失，当输入在-1到1之间时，平滑为L2损失，用于回归</span></span><br><span class="line"></span><br><span class="line">nn.BCELoss <span class="comment"># 二元交叉熵，用于二分类，输入已经过nn.Sigmoid激活，对不平衡数据集可以用weigths参数调整类别权重</span></span><br><span class="line"></span><br><span class="line">nn.BCEWithLogitsLoss <span class="comment"># 二元交叉熵，用于二分类，输入未经过nn.Sigmoid激活</span></span><br><span class="line"></span><br><span class="line">nn.CrossEntropyLoss <span class="comment"># 交叉熵，用于多分类。</span></span><br><span class="line"><span class="comment"># 要求label为稀疏编码，输入未经过nn.Softmax激活，对不平衡数据集可以用weigths参数调整类别权重</span></span><br><span class="line"></span><br><span class="line">nn.NLLLoss <span class="comment"># 负对数似然损失，用于多分类，要求label为稀疏编码，输入经过nn.LogSoftmax激活</span></span><br><span class="line"></span><br><span class="line">nn.CosineSimilarity <span class="comment"># 余弦相似度，可用于多分类</span></span><br><span class="line"></span><br><span class="line">nn.AdaptiveLogSoftmaxWithLoss <span class="comment"># 一种适合非常多类别且类别分布很不均衡的损失函数，会自适应地将多个小类别合成一个cluster</span></span><br></pre></td></tr></table></figure></p>
<p><strong>自定义损失函数</strong>：<br />
自定义损失函数接收两个张量 y_pred 和 y_true
作为输入参数，并输出一个标量作为损失函数值。也可以对nn.Module进行子类化，重写forward方法实现损失的计算逻辑，从而得到损失函数的类的实现。</p>
<p>下面是一个Focal Loss的自定义实现示范。Focal
Loss是一种对binary_crossentropy的改进损失函数形式。它在样本不均衡和存在较多易分类的样本时相比binary_crossentropy具有明显的优势。它有两个可调参数，alpha和gamma。其中alpha参数主要用于衰减负样本的权重，gamma参数主要用于衰减容易训练样本的权重。从而让模型更加聚焦在正样本和困难样本上。这就是为什么这个损失函数叫做Focal
Loss。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 详见https://zhuanlan.zhihu.com/p/80594704</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FocalLoss</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,gamma=<span class="number">2.0</span>,alpha=<span class="number">0.75</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.gamma = gamma</span><br><span class="line">        self.alpha = alpha</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,y_pred,y_true</span>):</span><br><span class="line">        bce = torch.nn.BCELoss(reduction = <span class="string">&quot;none&quot;</span>)(y_pred,y_true)</span><br><span class="line">        p_t = (y_true * y_pred) + ((<span class="number">1</span> - y_true) * (<span class="number">1</span> - y_pred))</span><br><span class="line">        alpha_factor = y_true * self.alpha + (<span class="number">1</span> - y_true) * (<span class="number">1</span> - self.alpha)</span><br><span class="line">        modulating_factor = torch.<span class="built_in">pow</span>(<span class="number">1.0</span> - p_t, self.gamma)</span><br><span class="line">        loss = torch.mean(alpha_factor * modulating_factor * bce)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"><span class="comment">#困难样本</span></span><br><span class="line">y_pred_hard = torch.tensor([[<span class="number">0.5</span>],[<span class="number">0.5</span>]])</span><br><span class="line">y_true_hard = torch.tensor([[<span class="number">1.0</span>],[<span class="number">0.0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">#容易样本</span></span><br><span class="line">y_pred_easy = torch.tensor([[<span class="number">0.9</span>],[<span class="number">0.1</span>]])</span><br><span class="line">y_true_easy = torch.tensor([[<span class="number">1.0</span>],[<span class="number">0.0</span>]])</span><br><span class="line"></span><br><span class="line">focal_loss = FocalLoss()</span><br><span class="line">bce_loss = nn.BCELoss()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;focal_loss(hard samples):&quot;</span>, focal_loss(y_pred_hard,y_true_hard))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bce_loss(hard samples):&quot;</span>, bce_loss(y_pred_hard,y_true_hard))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;focal_loss(easy samples):&quot;</span>, focal_loss(y_pred_easy,y_true_easy))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bce_loss(easy samples):&quot;</span>, bce_loss(y_pred_easy,y_true_easy))</span><br><span class="line"></span><br><span class="line"><span class="comment">#可见 focal_loss让容易样本的权重衰减到原来的 0.0005/0.1054 = 0.00474</span></span><br><span class="line"><span class="comment">#而让困难样本的权重只衰减到原来的 0.0866/0.6931=0.12496</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此相对而言，focal_loss可以衰减容易样本的权重。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">focal_loss(hard samples): tensor(0.0866)</span></span><br><span class="line"><span class="string">bce_loss(hard samples): tensor(0.6931)</span></span><br><span class="line"><span class="string">focal_loss(easy samples): tensor(0.0005)</span></span><br><span class="line"><span class="string">bce_loss(easy samples): tensor(0.1054)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br />
FocalLoss的使用完整范例，可以参考下面中自定义L1和L2正则化项中的范例，该范例既演示了自定义正则化项的方法，也演示了FocalLoss的使用方法。</p>
<p><strong>自定义L1和L2正则化项</strong>：<br />
通常认为 L1
正则化可以产生稀疏权值矩阵，即产生一个稀疏模型，可以用于特征选择。而 L2
正则化可以防止模型过拟合（overfitting）。一定程度上，L1也可以防止过拟合。</p>
<p>下面以一个二分类问题为例，演示给模型的目标函数添加自定义L1和L2正则化项的方法。这个范例同时演示了上一部分的FocalLoss的使用。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader,TensorDataset</span><br><span class="line"><span class="keyword">import</span> torchkeras </span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format = <span class="string">&#x27;svg&#x27;</span></span><br><span class="line"><span class="comment"># 1, 准备数据</span></span><br><span class="line"><span class="comment">#正负样本数量</span></span><br><span class="line">n_positive,n_negative = <span class="number">200</span>,<span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成正样本, 小圆环分布</span></span><br><span class="line">r_p = <span class="number">5.0</span> + torch.normal(<span class="number">0.0</span>,<span class="number">1.0</span>,size = [n_positive,<span class="number">1</span>]) </span><br><span class="line">theta_p = <span class="number">2</span>*np.pi*torch.rand([n_positive,<span class="number">1</span>])</span><br><span class="line">Xp = torch.cat([r_p*torch.cos(theta_p),r_p*torch.sin(theta_p)],axis = <span class="number">1</span>)</span><br><span class="line">Yp = torch.ones_like(r_p)</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成负样本, 大圆环分布</span></span><br><span class="line">r_n = <span class="number">8.0</span> + torch.normal(<span class="number">0.0</span>,<span class="number">1.0</span>,size = [n_negative,<span class="number">1</span>]) </span><br><span class="line">theta_n = <span class="number">2</span>*np.pi*torch.rand([n_negative,<span class="number">1</span>])</span><br><span class="line">Xn = torch.cat([r_n*torch.cos(theta_n),r_n*torch.sin(theta_n)],axis = <span class="number">1</span>)</span><br><span class="line">Yn = torch.zeros_like(r_n)</span><br><span class="line"></span><br><span class="line"><span class="comment">#汇总样本</span></span><br><span class="line">X = torch.cat([Xp,Xn],axis = <span class="number">0</span>)</span><br><span class="line">Y = torch.cat([Yp,Yn],axis = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#可视化</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">6</span>))</span><br><span class="line">plt.scatter(Xp[:,<span class="number">0</span>],Xp[:,<span class="number">1</span>],c = <span class="string">&quot;r&quot;</span>)</span><br><span class="line">plt.scatter(Xn[:,<span class="number">0</span>],Xn[:,<span class="number">1</span>],c = <span class="string">&quot;g&quot;</span>)</span><br><span class="line">plt.legend([<span class="string">&quot;positive&quot;</span>,<span class="string">&quot;negative&quot;</span>])</span><br><span class="line"></span><br><span class="line">ds = TensorDataset(X,Y)</span><br><span class="line"></span><br><span class="line">ds_train,ds_valid = torch.utils.data.random_split(ds,[<span class="built_in">int</span>(<span class="built_in">len</span>(ds)*<span class="number">0.7</span>),<span class="built_in">len</span>(ds)-<span class="built_in">int</span>(<span class="built_in">len</span>(ds)*<span class="number">0.7</span>)])</span><br><span class="line">dl_train = DataLoader(ds_train,batch_size = <span class="number">100</span>,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line">dl_valid = DataLoader(ds_valid,batch_size = <span class="number">100</span>,num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2, 定义模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DNNModel</span>(torchkeras.Model):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DNNModel, self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">4</span>,<span class="number">8</span>) </span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">8</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        y = nn.Sigmoid()(self.fc3(x))</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">model = DNNModel()</span><br><span class="line"></span><br><span class="line">model.summary(input_shape =(<span class="number">2</span>,))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">        Layer (type)               Output Shape         Param #</span></span><br><span class="line"><span class="string">================================================================</span></span><br><span class="line"><span class="string">            Linear-1                    [-1, 4]              12</span></span><br><span class="line"><span class="string">            Linear-2                    [-1, 8]              40</span></span><br><span class="line"><span class="string">            Linear-3                    [-1, 1]               9</span></span><br><span class="line"><span class="string">================================================================</span></span><br><span class="line"><span class="string">Total params: 61</span></span><br><span class="line"><span class="string">Trainable params: 61</span></span><br><span class="line"><span class="string">Non-trainable params: 0</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">Input size (MB): 0.000008</span></span><br><span class="line"><span class="string">Forward/backward pass size (MB): 0.000099</span></span><br><span class="line"><span class="string">Params size (MB): 0.000233</span></span><br><span class="line"><span class="string">Estimated Total Size (MB): 0.000340</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 3，训练模型</span></span><br><span class="line"><span class="comment"># 准确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_pred,y_true</span>):</span><br><span class="line">    y_pred = torch.where(y_pred&gt;<span class="number">0.5</span>,torch.ones_like(y_pred,dtype = torch.float32),</span><br><span class="line">                      torch.zeros_like(y_pred,dtype = torch.float32))</span><br><span class="line">    acc = torch.mean(<span class="number">1</span>-torch.<span class="built_in">abs</span>(y_true-y_pred))</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line"></span><br><span class="line"><span class="comment"># L2正则化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">L2Loss</span>(<span class="params">model,alpha</span>):</span><br><span class="line">    l2_loss = torch.tensor(<span class="number">0.0</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;bias&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> name: <span class="comment">#一般不对偏置项使用正则</span></span><br><span class="line">            l2_loss = l2_loss + (<span class="number">0.5</span> * alpha * torch.<span class="built_in">sum</span>(torch.<span class="built_in">pow</span>(param, <span class="number">2</span>)))</span><br><span class="line">    <span class="keyword">return</span> l2_loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># L1正则化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">L1Loss</span>(<span class="params">model,beta</span>):</span><br><span class="line">    l1_loss = torch.tensor(<span class="number">0.0</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;bias&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> name:</span><br><span class="line">            l1_loss = l1_loss +  beta * torch.<span class="built_in">sum</span>(torch.<span class="built_in">abs</span>(param))</span><br><span class="line">    <span class="keyword">return</span> l1_loss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将L2正则和L1正则添加到FocalLoss损失，一起作为目标函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">focal_loss_with_regularization</span>(<span class="params">y_pred,y_true</span>):</span><br><span class="line">    focal = FocalLoss()(y_pred,y_true) </span><br><span class="line">    l2_loss = L2Loss(model,<span class="number">0.001</span>) <span class="comment">#注意设置正则化项系数</span></span><br><span class="line">    l1_loss = L1Loss(model,<span class="number">0.001</span>)</span><br><span class="line">    total_loss = focal + l2_loss + l1_loss</span><br><span class="line">    <span class="keyword">return</span> total_loss</span><br><span class="line"></span><br><span class="line">model.<span class="built_in">compile</span>(loss_func =focal_loss_with_regularization,</span><br><span class="line">              optimizer= torch.optim.Adam(model.parameters(),lr = <span class="number">0.01</span>),</span><br><span class="line">             metrics_dict=&#123;<span class="string">&quot;accuracy&quot;</span>:accuracy&#125;)</span><br><span class="line"></span><br><span class="line">dfhistory = model.fit(<span class="number">30</span>,dl_train = dl_train,dl_val = dl_valid,log_step_freq = <span class="number">30</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Start Training ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">================================================================================2020-07-11 23:34:17</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 30, &#x27;loss&#x27;: 0.021, &#x27;accuracy&#x27;: 0.972&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> +-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">| epoch |  loss | accuracy | val_loss | val_accuracy |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">|   1   | 0.022 |  0.971   |  0.025   |     0.96     |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">================================================================================2020-07-11 23:34:27</span></span><br><span class="line"><span class="string">&#123;&#x27;step&#x27;: 30, &#x27;loss&#x27;: 0.016, &#x27;accuracy&#x27;: 0.984&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> +-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">| epoch |  loss | accuracy | val_loss | val_accuracy |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string">|   30  | 0.016 |  0.981   |  0.017   |    0.983     |</span></span><br><span class="line"><span class="string">+-------+-------+----------+----------+--------------+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">================================================================================2020-07-11 23:34:27</span></span><br><span class="line"><span class="string">Finished Training...</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 结果可视化</span></span><br><span class="line">fig, (ax1,ax2) = plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">2</span>,figsize = (<span class="number">12</span>,<span class="number">5</span>))</span><br><span class="line">ax1.scatter(Xp[:,<span class="number">0</span>],Xp[:,<span class="number">1</span>], c=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">ax1.scatter(Xn[:,<span class="number">0</span>],Xn[:,<span class="number">1</span>],c = <span class="string">&quot;g&quot;</span>)</span><br><span class="line">ax1.legend([<span class="string">&quot;positive&quot;</span>,<span class="string">&quot;negative&quot;</span>]);</span><br><span class="line">ax1.set_title(<span class="string">&quot;y_true&quot;</span>);</span><br><span class="line"></span><br><span class="line">Xp_pred = X[torch.squeeze(model.forward(X)&gt;=<span class="number">0.5</span>)]</span><br><span class="line">Xn_pred = X[torch.squeeze(model.forward(X)&lt;<span class="number">0.5</span>)]</span><br><span class="line"></span><br><span class="line">ax2.scatter(Xp_pred[:,<span class="number">0</span>],Xp_pred[:,<span class="number">1</span>],c = <span class="string">&quot;r&quot;</span>)</span><br><span class="line">ax2.scatter(Xn_pred[:,<span class="number">0</span>],Xn_pred[:,<span class="number">1</span>],c = <span class="string">&quot;g&quot;</span>)</span><br><span class="line">ax2.legend([<span class="string">&quot;positive&quot;</span>,<span class="string">&quot;negative&quot;</span>]);</span><br><span class="line">ax2.set_title(<span class="string">&quot;y_pred&quot;</span>)</span><br></pre></td></tr></table></figure><br />
<strong>通过优化器实现L2正则化</strong>：<br />
如果仅仅需要使用L2正则化，那么也可以利用优化器的weight_decay参数来实现。weight_decay参数可以设置参数在训练过程中的衰减，这和L2正则化的作用效果等价。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before L2 regularization:</span><br><span class="line">gradient descent: w = w - lr * dloss_dw </span><br><span class="line"></span><br><span class="line">after L2 regularization:</span><br><span class="line">gradient descent: w = w - lr * (dloss_dw+beta*w) = (<span class="number">1</span>-lr*beta)*w - lr*dloss_dw</span><br><span class="line"></span><br><span class="line">so （<span class="number">1</span>-lr*beta）<span class="keyword">is</span> the weight decay ratio.</span><br></pre></td></tr></table></figure><br />
Pytorch的优化器支持一种称之为Per-parameter
options的操作，就是对每一个参数进行特定的学习率，权重衰减率指定，以满足更为细致的要求。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weight_params = [param <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters() <span class="keyword">if</span> <span class="string">&quot;bias&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> name]</span><br><span class="line">bias_params = [param <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters() <span class="keyword">if</span> <span class="string">&quot;bias&quot;</span> <span class="keyword">in</span> name]</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.SGD([&#123;<span class="string">&#x27;params&#x27;</span>: weight_params, <span class="string">&#x27;weight_decay&#x27;</span>:<span class="number">1e-5</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&#x27;params&#x27;</span>: bias_params, <span class="string">&#x27;weight_decay&#x27;</span>:<span class="number">0</span>&#125;],</span><br><span class="line">                            lr=<span class="number">1e-2</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="tensorboard可视化">TensorBoard可视化</h1>
<p>TensorBoard是炼丹可视化辅助工具。它原是TensorFlow的小弟，但它也能够很好地和Pytorch进行配合。甚至在Pytorch中使用TensorBoard比TensorFlow中使用TensorBoard还要来的更加简单和自然。Pytorch中利用TensorBoard可视化的大概过程如下：<br />
（1）在Pytorch中指定一个目录创建一个torch.utils.tensorboard.SummaryWriter日志写入器。<br />
（2）根据需要可视化的信息，利用日志写入器将相应信息日志写入我们指定的目录。<br />
（3）传入日志目录作为参数启动TensorBoard，然后就可以在TensorBoard中愉快地看片了。</p>
<p>我们主要介绍Pytorch中利用TensorBoard进行如下方面信息的可视化的方法：<br />
可视化模型结构：writer.add_graph<br />
可视化指标变化：writer.add_scalar<br />
可视化参数分布：writer.add_histogram<br />
可视化原始图像：writer.add_image 或 writer.add_images<br />
可视化人工绘图：writer.add_figure</p>
<p><strong>可视化模型结构</strong>：<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchkeras <span class="keyword">import</span> Model,summary</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(in_channels=<span class="number">3</span>,out_channels=<span class="number">32</span>,kernel_size = <span class="number">3</span>)</span><br><span class="line">        self.pool = nn.MaxPool2d(kernel_size = <span class="number">2</span>,stride = <span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(in_channels=<span class="number">32</span>,out_channels=<span class="number">64</span>,kernel_size = <span class="number">5</span>)</span><br><span class="line">        self.dropout = nn.Dropout2d(p = <span class="number">0.1</span>)</span><br><span class="line">        self.adaptive_pool = nn.AdaptiveMaxPool2d((<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">        self.flatten = nn.Flatten()</span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">64</span>,<span class="number">32</span>)</span><br><span class="line">        self.relu = nn.ReLU()</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">32</span>,<span class="number">1</span>)</span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        x = self.dropout(x)</span><br><span class="line">        x = self.adaptive_pool(x)</span><br><span class="line">        x = self.flatten(x)</span><br><span class="line">        x = self.linear1(x)</span><br><span class="line">        x = self.relu(x)</span><br><span class="line">        x = self.linear2(x)</span><br><span class="line">        y = self.sigmoid(x)</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line"><span class="built_in">print</span>(net)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Net(</span></span><br><span class="line"><span class="string">  (conv1): Conv2d(3, 32, kernel_size=(3, 3), stride=(1, 1))</span></span><br><span class="line"><span class="string">  (pool): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)</span></span><br><span class="line"><span class="string">  (conv2): Conv2d(32, 64, kernel_size=(5, 5), stride=(1, 1))</span></span><br><span class="line"><span class="string">  (dropout): Dropout2d(p=0.1, inplace=False)</span></span><br><span class="line"><span class="string">  (adaptive_pool): AdaptiveMaxPool2d(output_size=(1, 1))</span></span><br><span class="line"><span class="string">  (flatten): Flatten()</span></span><br><span class="line"><span class="string">  (linear1): Linear(in_features=64, out_features=32, bias=True)</span></span><br><span class="line"><span class="string">  (relu): ReLU()</span></span><br><span class="line"><span class="string">  (linear2): Linear(in_features=32, out_features=1, bias=True)</span></span><br><span class="line"><span class="string">  (sigmoid): Sigmoid()</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">summary(net,input_shape= (<span class="number">3</span>,<span class="number">32</span>,<span class="number">32</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">        Layer (type)               Output Shape         Param #</span></span><br><span class="line"><span class="string">================================================================</span></span><br><span class="line"><span class="string">            Conv2d-1           [-1, 32, 30, 30]             896</span></span><br><span class="line"><span class="string">         MaxPool2d-2           [-1, 32, 15, 15]               0</span></span><br><span class="line"><span class="string">            Conv2d-3           [-1, 64, 11, 11]          51,264</span></span><br><span class="line"><span class="string">         MaxPool2d-4             [-1, 64, 5, 5]               0</span></span><br><span class="line"><span class="string">         Dropout2d-5             [-1, 64, 5, 5]               0</span></span><br><span class="line"><span class="string"> AdaptiveMaxPool2d-6             [-1, 64, 1, 1]               0</span></span><br><span class="line"><span class="string">           Flatten-7                   [-1, 64]               0</span></span><br><span class="line"><span class="string">            Linear-8                   [-1, 32]           2,080</span></span><br><span class="line"><span class="string">              ReLU-9                   [-1, 32]               0</span></span><br><span class="line"><span class="string">           Linear-10                    [-1, 1]              33</span></span><br><span class="line"><span class="string">          Sigmoid-11                    [-1, 1]               0</span></span><br><span class="line"><span class="string">================================================================</span></span><br><span class="line"><span class="string">Total params: 54,273</span></span><br><span class="line"><span class="string">Trainable params: 54,273</span></span><br><span class="line"><span class="string">Non-trainable params: 0</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">Input size (MB): 0.011719</span></span><br><span class="line"><span class="string">Forward/backward pass size (MB): 0.359634</span></span><br><span class="line"><span class="string">Params size (MB): 0.207035</span></span><br><span class="line"><span class="string">Estimated Total Size (MB): 0.578388</span></span><br><span class="line"><span class="string">----------------------------------------------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;../data/tensorboard&#x27;</span>)</span><br><span class="line">writer.add_graph(net,input_to_model = torch.rand(<span class="number">1</span>,<span class="number">3</span>,<span class="number">32</span>,<span class="number">32</span>))</span><br><span class="line">writer.close()</span><br><span class="line"></span><br><span class="line">%load_ext tensorboard</span><br><span class="line"><span class="comment">#%tensorboard --logdir ../data/tensorboard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tensorboard <span class="keyword">import</span> notebook</span><br><span class="line"><span class="comment">#查看启动的tensorboard程序</span></span><br><span class="line">notebook.<span class="built_in">list</span>() </span><br><span class="line"></span><br><span class="line"><span class="comment">#启动tensorboard程序</span></span><br><span class="line">notebook.start(<span class="string">&quot;--logdir ../data/tensorboard&quot;</span>)</span><br><span class="line"><span class="comment">#等价于在命令行中执行 tensorboard --logdir ../data/tensorboard</span></span><br><span class="line"><span class="comment">#可以在浏览器中打开 http://localhost:6006/ 查看</span></span><br></pre></td></tr></table></figure><br />
<strong>可视化指标变化</strong>：<br />
有时候在训练过程中，如果能够实时动态地查看loss和各种metric的变化曲线，那么无疑可以帮助我们更加直观地了解模型的训练情况。</p>
<p>注意，writer.add_scalar仅能对标量的值的变化进行可视化。因此它一般用于对loss和metric的变化进行可视化分析。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = a*x**2 + b*x + c的最小值</span></span><br><span class="line">x = torch.tensor(<span class="number">0.0</span>,requires_grad = <span class="literal">True</span>) <span class="comment"># x需要被求导</span></span><br><span class="line">a = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line">b = torch.tensor(-<span class="number">2.0</span>)</span><br><span class="line">c = torch.tensor(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.SGD(params=[x],lr = <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    result = a*torch.<span class="built_in">pow</span>(x,<span class="number">2</span>) + b*x + c </span><br><span class="line">    <span class="keyword">return</span>(result)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;../data/tensorboard&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    y = f(x)</span><br><span class="line">    y.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;x&quot;</span>,x.item(),i) <span class="comment">#日志中记录x在第step i 的值</span></span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y&quot;</span>,y.item(),i) <span class="comment">#日志中记录y在第step i 的值</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y=&quot;</span>,f(x).data,<span class="string">&quot;;&quot;</span>,<span class="string">&quot;x=&quot;</span>,x.data)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">y= tensor(0.) ; x= tensor(1.0000)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br />
<strong>可视化参数分布</strong>：<br />
如果需要对模型的参数(一般非标量)在训练过程中的变化进行可视化，可以使用
writer.add_histogram。</p>
<p>它能够观测张量值分布的直方图随训练步骤的变化趋势。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch </span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建正态分布的张量模拟参数矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">norm</span>(<span class="params">mean,std</span>):</span><br><span class="line">    t = std*torch.randn((<span class="number">100</span>,<span class="number">20</span>))+mean</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;../data/tensorboard&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> step,mean <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">range</span>(-<span class="number">10</span>,<span class="number">10</span>,<span class="number">1</span>)):</span><br><span class="line">    w = norm(mean,<span class="number">1</span>)</span><br><span class="line">    writer.add_histogram(<span class="string">&quot;w&quot;</span>,w, step)</span><br><span class="line">    writer.flush()</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><br />
<strong>可视化原始图像</strong>：<br />
如果我们做图像相关的任务，也可以将原始的图片在tensorboard中进行可视化展示。</p>
<p>如果只写入一张图片信息，可以使用writer.add_image。<br />
如果要写入多张图片信息，可以使用writer.add_images。<br />
也可以用
torchvision.utils.make_grid将多张图片拼成一张图片，然后用writer.add_image写入。</p>
<p>注意，传入的是代表图片信息的Pytorch中的张量数据。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms,datasets </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transform_train = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor()])</span><br><span class="line">transform_valid = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor()])</span><br><span class="line"></span><br><span class="line">ds_train = datasets.ImageFolder(<span class="string">&quot;../data/cifar2/train/&quot;</span>,</span><br><span class="line">            transform = transform_train,target_transform= <span class="keyword">lambda</span> t:torch.tensor([t]).<span class="built_in">float</span>())</span><br><span class="line">ds_valid = datasets.ImageFolder(<span class="string">&quot;../data/cifar2/test/&quot;</span>,</span><br><span class="line">            transform = transform_train,target_transform= <span class="keyword">lambda</span> t:torch.tensor([t]).<span class="built_in">float</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ds_train.class_to_idx)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;0_airplane&#x27;: 0, &#x27;1_automobile&#x27;: 1&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">dl_train = DataLoader(ds_train,batch_size = <span class="number">50</span>,shuffle = <span class="literal">True</span>,num_workers=<span class="number">3</span>)</span><br><span class="line">dl_valid = DataLoader(ds_valid,batch_size = <span class="number">50</span>,shuffle = <span class="literal">True</span>,num_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">dl_train_iter = <span class="built_in">iter</span>(dl_train)</span><br><span class="line">images, labels = dl_train_iter.<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅查看一张图片</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;../data/tensorboard&#x27;</span>)</span><br><span class="line">writer.add_image(<span class="string">&#x27;images[0]&#x27;</span>, images[<span class="number">0</span>])</span><br><span class="line">writer.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将多张图片拼接成一张图片，中间用黑色网格分割</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;../data/tensorboard&#x27;</span>)</span><br><span class="line"><span class="comment"># create grid of images</span></span><br><span class="line">img_grid = torchvision.utils.make_grid(images)</span><br><span class="line">writer.add_image(<span class="string">&#x27;image_grid&#x27;</span>, img_grid)</span><br><span class="line">writer.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将多张图片直接写入</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;../data/tensorboard&#x27;</span>)</span><br><span class="line">writer.add_images(<span class="string">&quot;images&quot;</span>,images,global_step = <span class="number">0</span>)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><br />
<strong>可视化人工绘图</strong>：<br />
如果我们将matplotlib绘图的结果再 tensorboard中展示，可以使用
add_figure.</p>
<p>注意，和writer.add_image不同的是，writer.add_figure需要传入matplotlib的figure对象。<br />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms,datasets </span><br><span class="line"></span><br><span class="line">transform_train = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor()])</span><br><span class="line">transform_valid = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor()])</span><br><span class="line"></span><br><span class="line">ds_train = datasets.ImageFolder(<span class="string">&quot;../data/cifar2/train/&quot;</span>,</span><br><span class="line">            transform = transform_train,target_transform= <span class="keyword">lambda</span> t:torch.tensor([t]).<span class="built_in">float</span>())</span><br><span class="line">ds_valid = datasets.ImageFolder(<span class="string">&quot;../data/cifar2/test/&quot;</span>,</span><br><span class="line">            transform = transform_train,target_transform= <span class="keyword">lambda</span> t:torch.tensor([t]).<span class="built_in">float</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ds_train.class_to_idx)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&#x27;0_airplane&#x27;: 0, &#x27;1_automobile&#x27;: 1&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">%matplotlib inline</span><br><span class="line">%config InlineBackend.figure_format = <span class="string">&#x27;svg&#x27;</span></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line">figure = plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>)) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    img,label = ds_train[i]</span><br><span class="line">    img = img.permute(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">    ax=plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i+<span class="number">1</span>)</span><br><span class="line">    ax.imshow(img.numpy())</span><br><span class="line">    ax.set_title(<span class="string">&quot;label = %d&quot;</span>%label.item())</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([]) </span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tensorboard显示</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;../data/tensorboard&#x27;</span>)</span><br><span class="line">writer.add_figure(<span class="string">&#x27;figure&#x27;</span>,figure,global_step=<span class="number">0</span>)</span><br><span class="line">writer.close()         </span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料">参考资料</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9weXRvcmNoLm9yZy90dXRvcmlhbHMvYmVnaW5uZXIvZGVlcF9sZWFybmluZ182MG1pbl9ibGl0ei5odG1s">Pytorch官网<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aC12Mi5kMmwuYWkvY2hhcHRlcl9wcmVsaW1pbmFyaWVzL25kYXJyYXkuaHRtbA==">动手学深度学习<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9qYWNraWV4aWFvLmdpdGh1Yi5pby9lYXRfcHl0b3JjaF9pbl8yMF9kYXlzLzIuJUU2JUEwJUI4JUU1JUJGJTgzJUU2JUE2JTgyJUU1JUJGJUI1LzItMSUyQyVFNSVCQyVBMCVFOSU4NyU4RiVFNiU5NSVCMCVFNiU4RCVBRSVFNyVCQiU5MyVFNiU5RSU4NC8=">20天吃掉那只Pytorch<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMW92NDExTTd4TD9zcG1faWRfZnJvbT0zMzMuOTk5LjAuMA==">PyTorch视频精讲<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuam1sci5vcmcvcGFwZXJzL3ZvbHVtZTE4LzE3LTQ2OC8xNy00NjgucGRm">Automatic
Differentiation in Machine Learning: a Survey<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2021/02/12/Graph/03.GraphSAGE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/12/Graph/03.GraphSAGE/" class="post-title-link" itemprop="url">GraphSAGE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-12 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-12T00:00:00+08:00">2021-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Graph/" itemprop="url" rel="index"><span itemprop="name">Graph</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="摘要">摘要</h1>
<p>大型图中节点的低维embedding已被证明在各种预测任务中非常有用，从内容推荐到识别蛋白质功能。然而，大多数现有的方法都要求在embedding训练期间图中的所有节点都存在；这些以前的方法本质上是<strong>transductive</strong>（直推式），不能自然地推广到看不见的节点。这里我们介绍GraphSAGE，这是一个通用<strong>inductive</strong>（归纳式）框架，它利用节点特征信息（例如，文本属性）高效地为以前看不见的数据生成节点embedding。我们学习的不是为每个节点训练单个embedding，而是通过从节点的局部邻域采样和聚合特征来生成嵌入的函数。</p>
<p>GraphSAGE是一个经典的基于空域的算法，它从两个方面对传统的GCN做了改进：<br />
（1）<strong>在训练时的，采样方式将GCN的全图采样优化到部分以节点为中心的邻居抽样，这使得大规模图数据的分布式训练成为可能，并且使得网络可以学习没有见过的节点，这也使得GraphSAGE可以做归纳学习（Inductive
Learning）</strong>。<br />
（2）GraphSAGE研究了若干种<strong>邻居聚合</strong>的方式，并通过实验和理论分析对比了不同聚合方式的优缺点。</p>
<p><strong>归纳学习（Inductive
Learning）</strong>：指可以对训练过程中见不到的数据直接计算而不需要重新对整个图进行学习。<br />
<strong>直推学习（Transductive
Learning）</strong>：指所有的数据都可以在训练的时候拿到，学习的过程是在这个固定的图上进行学习，一旦图中的某些节点发生变化，则需要对整个图进行重新训练和学习。</p>
<h1 id="introduction">Introduction</h1>
<p><img src="/images/GraphSAGE/1.png" width="80%"></p>
<p>GraphSAGE的算法核心是<strong>将整张图的采样优化到当前邻居节点的采样</strong>，因此从邻居<strong>采样</strong>（Sample）和邻居<strong>聚合</strong>（aggregate）两个方面来对GraphSAGE进行解释。具体流程如上图所示，可分为三个步骤：</p>
<ol type="1">
<li>对图中每个顶点邻居顶点进行采样，因为每个节点的度是不一致的，为了计算高效，
为每个节点采样固定数量的邻居。</li>
<li>根据聚合函数聚合邻居顶点蕴含的信息。</li>
<li>得到图中各顶点的向量表示供下游任务使用。</li>
</ol>
<h1 id="embedding-generation">Embedding generation</h1>
<p>GraphSAGE的前向传播算法如下，前向传播描述了如何使用聚合函数对节点的邻居信息进行聚合，从而生成节点embedding：</p>
<ol type="1">
<li>首先确定深度K，代表聚合深度，对每一层 <span
class="math inline">\(k=1...K\)</span> 进行遍历；</li>
<li>在当前层<span
class="math inline">\(k\)</span>，<strong>采样</strong>固定size大小的邻居节点进行<strong>聚合</strong>，得到<span
class="math inline">\(h_{N(v)}^k\)</span>，和自己进行CONCAT，做一个线性变换经过激活得到<span
class="math inline">\(h_{v}^k\)</span>，再归一化。</li>
<li>每层都按（1）（2）处理，最后得到顶点的embedding。</li>
</ol>
<p>即在每次迭代(或搜索深度)，顶点从它们的局部邻居聚合信息，并且随着这个过程的迭代，顶点会从越来越远的地方获得信息。</p>
<p><strong>采样</strong>：出于对计算效率的考虑，对每个顶点采样一定数量的邻居顶点作为待聚合信息的顶点。设采样数量为<span
class="math inline">\(m\)</span>，若顶点邻居数少于<span
class="math inline">\(m\)</span>,则采用有放回的抽样方法，直到采样出<span
class="math inline">\(m\)</span>个顶点。若顶点邻居数大于<span
class="math inline">\(m\)</span>，则采用无放回的抽样。作者给出了建议：在二层
<span class="math inline">\(K=2\)</span> 时，第一次采样数量 <span
class="math inline">\(S_1\)</span> 和第二次采样数量 <span
class="math inline">\(S_2\)</span> 满足公式：<span
class="math inline">\(S_1 · S_2 \leq 500\)</span>。<br />
<strong>聚合</strong>：之后会单独介绍。<br />
<img src="/images/GraphSAGE/2.png" width="80%"></p>
<p>举个例子：<br />
<img src="/images/GraphSAGE/2.1.png" width="80%"></p>
<p>在GraphSAGE之前的GCN模型中，都是采用的全图的训练方式，也就是说每一轮的迭代都要对全图的节点进行更新，当图的规模很大时，这种训练方式无疑是很耗时甚至无法更新的。mini-batch的训练时深度学习一个非常重要的特点，那么能否将mini-batch的思想用到GraphSAGE中呢，GraphSAGE提出了一个解决方案：<strong>只需记录当前mini-batch用到的所有节点（包括邻居节点），存储下来，之后再进行训练，这样每次训练就不需要保存整个图的信息</strong>。<br />
<img src="/images/GraphSAGE/3.png" width="80%"><br />
注意，mini-batch采样是从中心点<span
class="math inline">\(K\)</span>层到最外层<span
class="math inline">\(1\)</span>，在聚合时是从最外层<span
class="math inline">\(1\)</span>到中心层<span
class="math inline">\(K\)</span>的。</p>
<p>举个例子：<br />
<img src="/images/GraphSAGE/3.1.png" width="80%"><br />
<img src="/images/GraphSAGE/3.2.png" width="80%"></p>
<h1 id="aggregator-architectures">Aggregator Architectures</h1>
<p>在图中顶点的邻居是无序的，所以希望构造出的聚合函数是<strong>对称的</strong>（即也就是对它输入的各种排列，函数的输出结果不变）和<strong>可导的</strong>。
聚合函数的对称性（symmetry
property）确保了神经网络模型可以被训练且可以应用于任意顺序的顶点邻居特征集合上。因为要进行反向传播求梯度，需要聚合函数可导。</p>
<p><strong>Mean aggregator</strong><br />
mean aggregator将目标顶点和邻居顶点的第<span
class="math inline">\(k-1\)</span>层向量拼接起来，然后对向量的每个维度进行求均值的操作，将得到的结果做一次非线性变换产生目标顶点的第<span
class="math inline">\(k\)</span>层表示向量。<br />
文中用下面的式子替换算法1中的4行AGGREGATE和5行CONCAT得到GCN的inductive变形：<br />
<img src="/images/GraphSAGE/4.png" width="40%"></p>
<p><strong>LSTM aggregator</strong><br />
LSTM本身是有顺序的，但是通过将输入节点随机排列（对顶点的邻居进行一次乱序操作），使得LSTM可以适用于无序的集合。</p>
<p><strong>Pooling aggregator</strong><br />
pooling聚合器，它既是对称的，又是可训练的。Pooling
aggregator先对目标顶点的邻居顶点的embedding向量进行一次非线性变换，之后进行一次pooling操作(max
pooling or mean
pooling)，将得到结果与目标顶点的表示向量拼接，最后再经过一次非线性变换得到目标顶点的第k层表示向量。<br />
<img src="/images/GraphSAGE/5.png" width="50%"></p>
<h1 id="learning-the-parameters-of-graphsage">Learning the parameters of
GraphSAGE</h1>
<p>GraphSAGE支持无监督训练和有监督训练两种方式。</p>
<p>GraphSAGE的<strong>无监督学习</strong>的理论基于假设：节点 <span
class="math inline">\(u\)</span> 与其邻居 <span
class="math inline">\(v\)</span>
相似，那么其表征的距离也近，而与没有交集的节点 <span
class="math inline">\(v_n\)</span>
不相似，那么其表征的距离也远，损失函数为：<br />
<img src="/images/GraphSAGE/6.png" width="50%"><br />
其中 <span class="math inline">\(z_u\)</span> 为节点 <span
class="math inline">\(u\)</span> 通过GraphSAGE得到的embedding，<span
class="math inline">\(v\)</span> 是节点 <span
class="math inline">\(u\)</span> 通过随机游走得到的邻居，<span
class="math inline">\(v_n \sim P_n(v)\)</span> 表示负采样，<span
class="math inline">\(Q\)</span>为样本数。embedding之间相似度通过向量点积计算得到。<br />
损失函数的目的是拉近正样本距离，拉远负样本距离。正样本是通过随机游走得到的。</p>
<p><strong>有监督学习</strong>比较简单，使用满足预测目标的任务作为损失函数，例如交叉熵等。</p>
<h1 id="experiments">Experiments</h1>
<p>实验使用baselines：<br />
1. Random，随机分类器<br />
2. Raw features，手工特征（非图特征）<br />
3. deepwalk（图拓扑特征）<br />
4. DeepWalk + features， deepwalk + 手工特征</p>
<p><img src="/images/GraphSAGE/7.png" width="80%"></p>
<p><strong>实验结果1：分类准确率（micro-averaged F1
scores）</strong><br />
1. 可以看到GraphSAGE的性能显著优于baseline方法。<br />
2.
三个数据集上的实验结果表明，一般是LSTM或pooling效果比较好，有监督都比无监督好。<br />
3.
无监督版本的GraphSAGE-pool对引文数据和Reddit数据的连接（concatenation）性能分别比DeepWalk
embeddings和raw
features的连接性能好13.8%和29.1%，而有监督版本的连接性能分别提高了19.7%和37.2%。<br />
4.
尽管LSTM是为有序数据而不是无序集设计的，但是基于LSTM的聚合器显示了强大的性能。<br />
5.
最后，可以看到无监督GraphSAGE的性能与完全监督的版本相比具有相当的竞争力，这表明文中的框架可以在不进行特定于任务的微调（task-specific
fine-tuning）的情况下实现强大的性能</p>
<p><strong>实验结果2：运行时间和参数敏感性</strong><br />
<strong>计算时间</strong>：GraphSAGE中LSTM训练速度最慢，但相比DeepWalk，GraphSAGE在预测时间减少100-500倍（因为对于未知节点，DeepWalk要重新进行随机游走以及通过SGD学习embedding）。<br />
<strong>邻居采样数量</strong>：图B中邻居采样数量递增，F1也增大，但计算时间也变大。
为了平衡F1和计算时间，将S1设为25<br />
<strong>聚合K跳内信息</strong>：在GraphSAGE， K=2 相比K=1
有10-15%的提升；但将K设置超过2，效果上只有0-5%的提升，但是计算时间却变大了10-100倍。</p>
<p><strong>实验结果3：不同聚合器之间的比较</strong><br />
1. LSTM和pool的效果较好。<br />
2.
为了更定量地了解这些趋势，实验中将设置六种不同的实验，即(3个数据集)×(非监督、监督)。<br />
3.
GraphSAGE-LSTM比GraphSAGE-pool慢得多(≈2×)，这可能使基于pooling的聚合器在总体上略占优势。<br />
4. LSTM方法和pooling方法之间没有显著差异。<br />
5. 文中使用非参数Wilcoxon
Signed-Rank检验来量化实验中不同聚合器之间的差异，在适用的情况下报告T-statistic和p-value。</p>
<h1 id="总结">总结</h1>
<p>GraphSAGE的一个强大之处是它在一个子集学到的模型也可以应用到其它模型上，原因是因为GraphSAGE的参数是共享的（每层计算时的参数W是共享的）。当有一个新的图或者有一个节点加入到已训练的图中时，我们只需要知道这个新图或者新节点的结构信息，通过共享的参数，便可以得到它们的特征向量。</p>
<p>它最大的贡献在于给图模型赋予了归纳学习的能力，从而大范围的扩大了GNN的落地场景。另外GraphSAGE的预测速度非常之快，因为它只需要选择若干跳的若干个邻居即可，而这两个可以选择的参数往往也比较小，往往取两跳邻居就能得到不错的学习效果。GraphSAGE的第三个优点是它非常好理解，不需要复杂的图理论基础，对于学习图神经网络也是非常好的入门读物。</p>
<h1 id="code">Code</h1>
<p>Pytorch（最基础的实现）：https://github.com/williamleif/graphsage-simple/<br />
Tensorflow（全版本）：https://github.com/williamleif/GraphSAGE<br />
Pytorch（全版本）：https://github.com/twjiang/graphSAGE-pytorch</p>
<p>以Pytorch基础版本为例，节点分类任务：<br />
<figure class="highlight python"><figcaption><span>model.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> graphsage.encoders <span class="keyword">import</span> Encoder</span><br><span class="line"><span class="keyword">from</span> graphsage.aggregators <span class="keyword">import</span> MeanAggregator</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Simple supervised GraphSAGE model as well as examples running the model</span></span><br><span class="line"><span class="string">on the Cora and Pubmed datasets.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 有监督学习下的GraphSage</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SupervisedGraphSage</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># num_classes类别数，这里是7</span></span><br><span class="line">    <span class="comment"># enc传入的是enc2，看作递归调用，从外层开始计算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes, enc</span>):</span><br><span class="line">        <span class="built_in">super</span>(SupervisedGraphSage, self).__init__()</span><br><span class="line">        self.enc = enc</span><br><span class="line">        self.xent = nn.CrossEntropyLoss() <span class="comment"># 交叉熵损失</span></span><br><span class="line"></span><br><span class="line">        self.weight = nn.Parameter(torch.FloatTensor(num_classes, enc.embed_dim)) <span class="comment"># 初始权重</span></span><br><span class="line">        init.xavier_uniform(self.weight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, nodes</span>):</span><br><span class="line">        embeds = self.enc(nodes)  <span class="comment"># 通过enc拿到nodes的embeddings</span></span><br><span class="line">        scores = self.weight.mm(embeds) <span class="comment"># 通过W得到score</span></span><br><span class="line">        <span class="keyword">return</span> scores.t() <span class="comment"># score转置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, nodes, labels</span>):</span><br><span class="line">        scores = self.forward(nodes)</span><br><span class="line">        <span class="keyword">return</span> self.xent(scores, labels.squeeze()) <span class="comment"># score和labels交叉熵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_cora</span>():</span><br><span class="line">    num_nodes = <span class="number">2708</span></span><br><span class="line">    num_feats = <span class="number">1433</span></span><br><span class="line">    feat_data = np.zeros((num_nodes, num_feats))</span><br><span class="line">    labels = np.empty((num_nodes,<span class="number">1</span>), dtype=np.int64)</span><br><span class="line">    node_map = &#123;&#125;</span><br><span class="line">    label_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;cora/cora.content&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> i,line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp):</span><br><span class="line">            info = line.strip().split()</span><br><span class="line">            feat_data[i,:] = <span class="built_in">map</span>(<span class="built_in">float</span>, info[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">            node_map[info[<span class="number">0</span>]] = i</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> info[-<span class="number">1</span>] <span class="keyword">in</span> label_map:</span><br><span class="line">                label_map[info[-<span class="number">1</span>]] = <span class="built_in">len</span>(label_map)</span><br><span class="line">            labels[i] = label_map[info[-<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设定字典中默认value为set类型，当key不存在时也不会报错</span></span><br><span class="line">    adj_lists = defaultdict(<span class="built_in">set</span>) </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;cora/cora.cites&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> i,line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp):</span><br><span class="line">            info = line.strip().split()</span><br><span class="line">            paper1 = node_map[info[<span class="number">0</span>]] <span class="comment"># paper1的id</span></span><br><span class="line">            paper2 = node_map[info[<span class="number">1</span>]] <span class="comment"># paper2的id</span></span><br><span class="line">            adj_lists[paper1].add(paper2) <span class="comment"># paper1连接paper2</span></span><br><span class="line">            adj_lists[paper2].add(paper1) <span class="comment"># paper2连接paper1</span></span><br><span class="line">    <span class="comment"># feat_data：(2708,1433)</span></span><br><span class="line">    <span class="comment"># labels：(2708,1)</span></span><br><span class="line">    <span class="comment"># adj_lists：存储边的连接 defaultdict(&lt;class &#x27;set&#x27;&gt;,&#123;163:&#123;1536,2563...&#125;,...&#125;)</span></span><br><span class="line">    <span class="keyword">return</span> feat_data, labels, adj_lists</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_cora</span>():</span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    random.seed(<span class="number">1</span>)</span><br><span class="line">    num_nodes = <span class="number">2708</span></span><br><span class="line">    feat_data, labels, adj_lists = load_cora()</span><br><span class="line">    features = nn.Embedding(<span class="number">2708</span>, <span class="number">1433</span>)</span><br><span class="line">    <span class="comment"># 权重矩阵</span></span><br><span class="line">    features.weight = nn.Parameter(torch.FloatTensor(feat_data), requires_grad=<span class="literal">False</span>)</span><br><span class="line">   <span class="comment"># features.cuda()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用MeanAggregator和Encoder</span></span><br><span class="line">    agg1 = MeanAggregator(features, cuda=<span class="literal">True</span>)</span><br><span class="line">    enc1 = Encoder(features, <span class="number">1433</span>, <span class="number">128</span>, adj_lists, agg1, gcn=<span class="literal">True</span>, cuda=<span class="literal">False</span>)</span><br><span class="line">    agg2 = MeanAggregator(<span class="keyword">lambda</span> nodes : enc1(nodes).t(), cuda=<span class="literal">False</span>)</span><br><span class="line">    enc2 = Encoder(<span class="keyword">lambda</span> nodes : enc1(nodes).t(), enc1.embed_dim, <span class="number">128</span>, adj_lists, agg2,</span><br><span class="line">            base_model=enc1, gcn=<span class="literal">True</span>, cuda=<span class="literal">False</span>)</span><br><span class="line">    enc1.num_samples = <span class="number">5</span> <span class="comment"># 1层搜索size</span></span><br><span class="line">    enc2.num_samples = <span class="number">5</span> <span class="comment"># 2层搜索size</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># num_classes类别数，这里是7</span></span><br><span class="line">    <span class="comment"># 传入的是enc2，看作递归调用</span></span><br><span class="line">    graphsage = SupervisedGraphSage(<span class="number">7</span>, enc2)</span><br><span class="line"><span class="comment">#    graphsage.cuda()</span></span><br><span class="line">    <span class="comment"># permutation随机排列序列，对2708个节点随机排列</span></span><br><span class="line">    rand_indices = np.random.permutation(num_nodes)</span><br><span class="line">    test = rand_indices[:<span class="number">1000</span>] <span class="comment"># 测试集</span></span><br><span class="line">    val = rand_indices[<span class="number">1000</span>:<span class="number">1500</span>] <span class="comment"># 验证集</span></span><br><span class="line">    train = <span class="built_in">list</span>(rand_indices[<span class="number">1500</span>:]) <span class="comment"># 训练集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化优化器，并传递相关参数</span></span><br><span class="line">    optimizer = torch.optim.SGD(<span class="built_in">filter</span>(<span class="keyword">lambda</span> p : p.requires_grad, graphsage.parameters()), lr=<span class="number">0.7</span>)</span><br><span class="line">    times = []</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        batch_nodes = train[:<span class="number">256</span>] <span class="comment"># batch取前256个节点</span></span><br><span class="line">        random.shuffle(train) <span class="comment"># 随即打乱</span></span><br><span class="line">        start_time = time.time() <span class="comment"># 记录开始时间</span></span><br><span class="line">        optimizer.zero_grad() <span class="comment"># 初始化梯度为0</span></span><br><span class="line">        <span class="comment"># 前向传播计算损失</span></span><br><span class="line">        loss = graphsage.loss(batch_nodes, </span><br><span class="line">                Variable(torch.LongTensor(labels[np.array(batch_nodes)])))</span><br><span class="line">        loss.backward() <span class="comment"># 反向传播</span></span><br><span class="line">        optimizer.step() <span class="comment"># 更新梯度</span></span><br><span class="line">        end_time = time.time() <span class="comment"># 记录结束时间</span></span><br><span class="line">        times.append(end_time-start_time) <span class="comment"># 得到时间差</span></span><br><span class="line">        <span class="built_in">print</span> batch, loss.data[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    val_output = graphsage.forward(val) </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Validation F1:&quot;</span>, f1_score(labels[val], val_output.data.numpy().argmax(axis=<span class="number">1</span>), average=<span class="string">&quot;micro&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Average batch time:&quot;</span>, np.mean(times)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_pubmed</span>():</span><br><span class="line">    <span class="comment">#hardcoded for simplicity...</span></span><br><span class="line">    num_nodes = <span class="number">19717</span></span><br><span class="line">    num_feats = <span class="number">500</span></span><br><span class="line">    feat_data = np.zeros((num_nodes, num_feats))</span><br><span class="line">    labels = np.empty((num_nodes, <span class="number">1</span>), dtype=np.int64)</span><br><span class="line">    node_map = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;pubmed-data/Pubmed-Diabetes.NODE.paper.tab&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.readline()</span><br><span class="line">        feat_map = &#123;entry.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]:i-<span class="number">1</span> <span class="keyword">for</span> i,entry <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp.readline().split(<span class="string">&quot;\t&quot;</span>))&#125;</span><br><span class="line">        <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp):</span><br><span class="line">            info = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">            node_map[info[<span class="number">0</span>]] = i</span><br><span class="line">            labels[i] = <span class="built_in">int</span>(info[<span class="number">1</span>].split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>])-<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> word_info <span class="keyword">in</span> info[<span class="number">2</span>:-<span class="number">1</span>]:</span><br><span class="line">                word_info = word_info.split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">                feat_data[i][feat_map[word_info[<span class="number">0</span>]]] = <span class="built_in">float</span>(word_info[<span class="number">1</span>])</span><br><span class="line">    adj_lists = defaultdict(<span class="built_in">set</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;pubmed-data/Pubmed-Diabetes.DIRECTED.cites.tab&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.readline()</span><br><span class="line">        fp.readline()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> fp:</span><br><span class="line">            info = line.strip().split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">            paper1 = node_map[info[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]]</span><br><span class="line">            paper2 = node_map[info[-<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]]</span><br><span class="line">            adj_lists[paper1].add(paper2)</span><br><span class="line">            adj_lists[paper2].add(paper1)</span><br><span class="line">    <span class="keyword">return</span> feat_data, labels, adj_lists</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_pubmed</span>():</span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    random.seed(<span class="number">1</span>)</span><br><span class="line">    num_nodes = <span class="number">19717</span></span><br><span class="line">    feat_data, labels, adj_lists = load_pubmed()</span><br><span class="line">    features = nn.Embedding(<span class="number">19717</span>, <span class="number">500</span>)</span><br><span class="line">    features.weight = nn.Parameter(torch.FloatTensor(feat_data), requires_grad=<span class="literal">False</span>)</span><br><span class="line">   <span class="comment"># features.cuda()</span></span><br><span class="line"></span><br><span class="line">    agg1 = MeanAggregator(features, cuda=<span class="literal">True</span>)</span><br><span class="line">    enc1 = Encoder(features, <span class="number">500</span>, <span class="number">128</span>, adj_lists, agg1, gcn=<span class="literal">True</span>, cuda=<span class="literal">False</span>)</span><br><span class="line">    agg2 = MeanAggregator(<span class="keyword">lambda</span> nodes : enc1(nodes).t(), cuda=<span class="literal">False</span>)</span><br><span class="line">    enc2 = Encoder(<span class="keyword">lambda</span> nodes : enc1(nodes).t(), enc1.embed_dim, <span class="number">128</span>, adj_lists, agg2,</span><br><span class="line">            base_model=enc1, gcn=<span class="literal">True</span>, cuda=<span class="literal">False</span>)</span><br><span class="line">    enc1.num_samples = <span class="number">10</span></span><br><span class="line">    enc2.num_samples = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">    graphsage = SupervisedGraphSage(<span class="number">3</span>, enc2)</span><br><span class="line"><span class="comment">#    graphsage.cuda()</span></span><br><span class="line">    rand_indices = np.random.permutation(num_nodes)</span><br><span class="line">    test = rand_indices[:<span class="number">1000</span>]</span><br><span class="line">    val = rand_indices[<span class="number">1000</span>:<span class="number">1500</span>]</span><br><span class="line">    train = <span class="built_in">list</span>(rand_indices[<span class="number">1500</span>:])</span><br><span class="line"></span><br><span class="line">    optimizer = torch.optim.SGD(<span class="built_in">filter</span>(<span class="keyword">lambda</span> p : p.requires_grad, graphsage.parameters()), lr=<span class="number">0.7</span>)</span><br><span class="line">    times = []</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">        batch_nodes = train[:<span class="number">1024</span>]</span><br><span class="line">        random.shuffle(train)</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss = graphsage.loss(batch_nodes, </span><br><span class="line">                Variable(torch.LongTensor(labels[np.array(batch_nodes)])))</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        times.append(end_time-start_time)</span><br><span class="line">        <span class="built_in">print</span> batch, loss.data[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    val_output = graphsage.forward(val) </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Validation F1:&quot;</span>, f1_score(labels[val], val_output.data.numpy().argmax(axis=<span class="number">1</span>), average=<span class="string">&quot;micro&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Average batch time:&quot;</span>, np.mean(times)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    run_cora()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><figcaption><span>encoders.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Encodes a node&#x27;s using &#x27;convolutional&#x27; GraphSage approach</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features, feature_dim, </span></span><br><span class="line"><span class="params">            embed_dim, adj_lists, aggregator,</span></span><br><span class="line"><span class="params">            num_sample=<span class="number">10</span>,</span></span><br><span class="line"><span class="params">            base_model=<span class="literal">None</span>, gcn=<span class="literal">False</span>, cuda=<span class="literal">False</span>, </span></span><br><span class="line"><span class="params">            feature_transform=<span class="literal">False</span></span>): </span><br><span class="line">        <span class="built_in">super</span>(Encoder, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.features = features <span class="comment"># (2708, 1433)</span></span><br><span class="line">        self.feat_dim = feature_dim <span class="comment"># 输入维度1433</span></span><br><span class="line">        self.adj_lists = adj_lists  <span class="comment"># 边的连接defaultdict(&lt;class &#x27;set&#x27;&gt;,&#123;163:&#123;1536,2563...&#125;,...&#125;)</span></span><br><span class="line">        self.aggregator = aggregator <span class="comment"># MeanAggregator</span></span><br><span class="line">        self.num_sample = num_sample <span class="comment"># 采样邻居节点size</span></span><br><span class="line">        <span class="keyword">if</span> base_model != <span class="literal">None</span>:</span><br><span class="line">            self.base_model = base_model</span><br><span class="line"></span><br><span class="line">        self.gcn = gcn</span><br><span class="line">        self.embed_dim = embed_dim <span class="comment"># 输出维度128</span></span><br><span class="line">        self.cuda = cuda</span><br><span class="line">        self.aggregator.cuda = cuda</span><br><span class="line">        <span class="comment"># 注意concat之后维度是2倍</span></span><br><span class="line">        self.weight = nn.Parameter(</span><br><span class="line">                torch.FloatTensor(embed_dim, self.feat_dim <span class="keyword">if</span> self.gcn <span class="keyword">else</span> <span class="number">2</span> * self.feat_dim))</span><br><span class="line">        init.xavier_uniform(self.weight)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, nodes</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Generates embeddings for a batch of nodes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        nodes     -- list of nodes</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 使用传递过来的aggregator计算（这里是mean），得到所有邻居节点的aggregator信息</span></span><br><span class="line">        neigh_feats = self.aggregator.forward(nodes, [self.adj_lists[<span class="built_in">int</span>(node)] <span class="keyword">for</span> node <span class="keyword">in</span> nodes], </span><br><span class="line">                self.num_sample)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.gcn:</span><br><span class="line">            <span class="keyword">if</span> self.cuda:</span><br><span class="line">                self_feats = self.features(torch.LongTensor(nodes).cuda())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self_feats = self.features(torch.LongTensor(nodes))</span><br><span class="line">            <span class="comment"># CONCAT当前节点和邻居节点</span></span><br><span class="line">            combined = torch.cat([self_feats, neigh_feats], dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            combined = neigh_feats</span><br><span class="line">        <span class="comment"># W*CONCAT</span></span><br><span class="line">        combined = F.relu(self.weight.mm(combined.t()))</span><br><span class="line">        <span class="keyword">return</span> combined</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>aggregators.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Set of modules for aggregating embeddings of neighbors.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MeanAggregator</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Aggregates a node&#x27;s embeddings using mean of neighbors&#x27; embeddings</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features, cuda=<span class="literal">False</span>, gcn=<span class="literal">False</span></span>): </span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initializes the aggregator for a specific graph.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        features -- function mapping LongTensor of node ids to FloatTensor of feature values.</span></span><br><span class="line"><span class="string">        cuda -- whether to use GPU</span></span><br><span class="line"><span class="string">        gcn --- whether to perform concatenation GraphSAGE-style, or add self-loops GCN-style</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(MeanAggregator, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.features = features</span><br><span class="line">        self.cuda = cuda</span><br><span class="line">        self.gcn = gcn</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, nodes, to_neighs, num_sample=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        nodes --- list of nodes in a batch</span></span><br><span class="line"><span class="string">        to_neighs --- list of sets, each set is the set of neighbors for node in batch</span></span><br><span class="line"><span class="string">        num_sample --- number of neighbors to sample. No sampling if None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        nodes：batch节点列表</span></span><br><span class="line"><span class="string">        to_neighs：集合列表，每个集合是batch中一个节点的邻居集合</span></span><br><span class="line"><span class="string">        num_sample：邻居采样size</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Local pointers to functions (speed hack)</span></span><br><span class="line">        _<span class="built_in">set</span> = <span class="built_in">set</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num_sample <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            _sample = random.sample</span><br><span class="line">            <span class="comment"># sample：截取列表的指定长度的随机数，但是不会改变列表本身的排序</span></span><br><span class="line">            <span class="comment"># 从to_neigh中采样num_sample个（当邻居节点数量to_neigh大于num_sample）</span></span><br><span class="line">            samp_neighs = [_<span class="built_in">set</span>(_sample(to_neigh, </span><br><span class="line">                            num_sample,</span><br><span class="line">                            )) <span class="keyword">if</span> <span class="built_in">len</span>(to_neigh) &gt;= num_sample <span class="keyword">else</span> to_neigh <span class="keyword">for</span> to_neigh <span class="keyword">in</span> to_neighs]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            samp_neighs = to_neighs <span class="comment"># num_sample为None，每个节点都对其所有邻居节点全部计算</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.gcn:</span><br><span class="line">            samp_neighs = [samp_neigh + <span class="built_in">set</span>([nodes[i]]) <span class="keyword">for</span> i, samp_neigh <span class="keyword">in</span> <span class="built_in">enumerate</span>(samp_neighs)]</span><br><span class="line">        <span class="comment"># set.union():返回多个集合的并集，即包含了所有集合的元素，重复的元素只会出现一次</span></span><br><span class="line">        unique_nodes_list = <span class="built_in">list</span>(<span class="built_in">set</span>.union(*samp_neighs))</span><br><span class="line">        <span class="comment"># &#123;节点:编号&#125;</span></span><br><span class="line">        unique_nodes = &#123;n:i <span class="keyword">for</span> i,n <span class="keyword">in</span> <span class="built_in">enumerate</span>(unique_nodes_list)&#125;</span><br><span class="line">        <span class="comment"># (采样节点（包括了batch节点）,独一无二节点)</span></span><br><span class="line">        mask = Variable(torch.zeros(<span class="built_in">len</span>(samp_neighs), <span class="built_in">len</span>(unique_nodes)))</span><br><span class="line">        <span class="comment"># 得到采样节点对应的编号</span></span><br><span class="line">        column_indices = [unique_nodes[n] <span class="keyword">for</span> samp_neigh <span class="keyword">in</span> samp_neighs <span class="keyword">for</span> n <span class="keyword">in</span> samp_neigh]  </span><br><span class="line">        <span class="comment"># 每个节点对应采样数量个i作为行坐标 </span></span><br><span class="line">        row_indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(samp_neighs)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(samp_neighs[i]))]</span><br><span class="line">        <span class="comment"># 得到邻接矩阵</span></span><br><span class="line">        mask[row_indices, column_indices] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.cuda:</span><br><span class="line">            mask = mask.cuda()</span><br><span class="line">        <span class="comment"># 统计每个节点的邻居数量</span></span><br><span class="line">        num_neigh = mask.<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>) </span><br><span class="line">        <span class="comment"># 每个邻居节点占比</span></span><br><span class="line">        mask = mask.div(num_neigh)</span><br><span class="line">        <span class="comment"># 得到每个邻居节点的特征</span></span><br><span class="line">        <span class="keyword">if</span> self.cuda:</span><br><span class="line">            embed_matrix = self.features(torch.LongTensor(unique_nodes_list).cuda())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            embed_matrix = self.features(torch.LongTensor(unique_nodes_list))</span><br><span class="line">        <span class="comment"># mean aggregators 计算每个邻居的节点特征mean</span></span><br><span class="line">        to_feats = mask.mm(embed_matrix)</span><br><span class="line">        <span class="keyword">return</span> to_feats</span><br></pre></td></tr></table></figure>
<h1 id="参考文献">参考文献</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MDYuMDIyMTYucGRm">Inductive
Representation Learning on Large Graphs<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzYxOTU4NjI=">GraphSAGE详解<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83OTYzNzc4Nw==">【Graph Neural
Network】GraphSAGE: 算法原理，实现和应用<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5bDQyNDUyNS9hcnRpY2xlL2RldGFpbHMvMTAwNTMyODQ5">[论文笔记]：GraphSAGE：Inductive
Representation Learning on Large Graphs 论文详解 NIPS 2017<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2021/02/10/Graph/02.GAT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/10/Graph/02.GAT/" class="post-title-link" itemprop="url">GAT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-10 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-10T00:00:00+08:00">2021-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Graph/" itemprop="url" rel="index"><span itemprop="name">Graph</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="gcn缺点">GCN缺点</h1>
<p><strong>GCN假设图是无向的</strong>，因为利用了对称的拉普拉斯矩阵
(只有邻接矩阵 A
是对称的，拉普拉斯矩阵才可以正交分解)，不能直接用于有向图。</p>
<p><strong>GCN不能处理动态图</strong>，GCN在训练时依赖于具体的图结构，测试的时候也要在相同的图上进行。因此只能处理transductive任务，不能处理inductive任务。transductive指训练和测试的时候基于相同的图结构，例如在一个社交网络上，知道一部分人的类别，预测另一部分人的类别。inductive指训练和测试使用不同的图结构，例如在一个社交网络上训练，在另一个社交网络上预测。</p>
<p><strong>GCN不能为每个邻居分配不同的权重</strong>，GCN
在卷积时对所有邻居节点均一视同仁，不能根据节点重要性分配不同的权重。</p>
<p>2018年图注意力网络GAT被提出，用于解决GCN的上述问题：GAT 采用了
Attention
机制，对邻近节点特征加权求和。邻近节点特征的权重完全取决于节点特征，而不依赖具体的网络结构，可以用于
inductive 任务。</p>
<h1 id="gat">GAT</h1>
<p>本文作者提出GATs方法，利用一个隐藏的self-attention层，来处理一些图卷积中的问题。不需要复杂的矩阵运算或者对图结构的事先了解，通过叠加self-attention层，在卷积过程中将不同的重要性分配给邻域内的不同节点，同时处理不同大小的邻域。作者分别设计了inductive
setting和transductive
setting的任务实验，GATs模型在基线数据集Cora、Citeseer、Pubmed
citation和PPI数据集上取得了state-of-the-art的结果。</p>
<p>和所有的attention
mechanism一样，GAT的计算也分为两步：<strong>计算注意力系数</strong>（attention
coefficient）和<strong>加权求和</strong>（aggregate）。</p>
<h2 id="计算注意力系数">计算注意力系数</h2>
<p>这里假设层的输入（Garaph）包含 <span class="math inline">\(N\)</span>
个节点，每个节点的特征向量为<span
class="math inline">\(h_i\)</span>，维度是 <span
class="math inline">\(F\)</span>，输出包含 <span
class="math inline">\(N\)</span> 个节点，每个节点的特征向量为<span
class="math inline">\(h_i^{\prime}\)</span>，维度是 <span
class="math inline">\(F^{\prime}\)</span>。为了<span
class="math inline">\(h_i^{\prime}\)</span>获得足够的表达能力，将输入特征转换为更高层次的特征，至少需要一个可学习的线性变换，为此，使用共享权重矩阵<span
class="math inline">\(W\)</span>作用到每个节点。然后我们在节点上使用<strong>self-attention</strong>来计算一个attention系数，即通过
<span class="math inline">\(a\)</span> 得到 <span
class="math inline">\(e_{ij}\)</span>，节点 <span
class="math inline">\(j\)</span> 是节点 <span
class="math inline">\(i\)</span> 的邻居。<br />
<img src="/images/GAT/1.png" width="80%"></p>
<p>论文中说，self-attention是一种<strong>Global graph
attention</strong>，会将注意力分配到图中所有的节点上，这种做法显然会丢失结构信息。通过self-attention注意力机制可以计算任意两个样本的关系，使一个样本用其他所有样本表示，但是第一，基于空间相似假设，一个样本与一定范围内的样本关系较为密切，第二，样本较多的时候，计算量非常大。为了解决这一问题，作者使用了一种
<strong>masked attention</strong>
的方法，<strong>对于一个样本来说只利用邻域内的样本计算注意力系数和新的表示，即仅将注意力分配到节点的一阶邻居节点集上</strong>。</p>
<p>针对每个节点执行self-attention机制<br />
<span class="math display">\[a ： R^{F^{\prime}}×R^{F^{\prime}} \to
R\]</span></p>
<p>计算注意力互相关系数attention coefficients：<br />
<span class="math display">\[e_{ij}=a(Wh_i,Wh_j)\]</span><br />
其中：</p>
<ul>
<li>注意力系数 <span class="math inline">\(e_{ij}\)</span>
表示的节点j对于节点i的重要性。</li>
<li>向量 <span class="math inline">\(h\)</span> 就是特征向量。</li>
<li><span class="math inline">\(a\)</span> 是一个 <span
class="math inline">\(R^{F^{\prime}}×R^{F^{\prime}} \to R\)</span>
的映射。</li>
<li><span class="math inline">\(W \in R^{F^{\prime}×F}\)</span>，使
<span class="math inline">\(W\)</span>
将每个特征转换为可用的表达性更强的特征。</li>
</ul>
<p>为了使注意力系数更容易计算和比较，引入softmax对所有的 <span
class="math inline">\(i\)</span> 的相邻节点 <span
class="math inline">\(j\)</span> 进行正则化：<br />
<img src="/images/GAT/2.png" width="40%"></p>
<p>其中：</p>
<ul>
<li><span class="math inline">\(N_i\)</span> 表示节点 <span
class="math inline">\(i\)</span> 的邻居节点集合。</li>
<li>这个系数 <span class="math inline">\(\alpha\)</span>
就是每次卷积时，用来进行加权求和的系数。</li>
</ul>
<p>实验中，注意力机制 <span class="math inline">\(a\)</span>
是一个单层的前馈神经网络，通过权值向量来确定 <span
class="math inline">\(a\in
R^{2F^{\prime}}\)</span>，并且加入了LeakyRelu的非线性激活，这里小于零斜率为0.2。（Relu:小于0就是0，大于0斜率为1；LRelu:小于0斜率固定一个值，大于0斜率为1；PRelu:小于0斜率可变，大于0斜率为1；
还有CRelu，Elu，SELU）。<br />
<img src="/images/GAT/3.png" width="60%"></p>
<p>本文中使用的是：<br />
<img src="/images/GAT/4.png" width="50%"><br />
其中，<span class="math inline">\(||\)</span>
表示concat操作（串联）。下面左图就是表示 <span
class="math inline">\(Wh_i\)</span>和 <span
class="math inline">\(Wh_j\)</span>经过串联以后，再和权值向量 <span
class="math inline">\(a\in R^{2F^{\prime}}\)</span>
相乘后，最后进行一个softmax归一化处理后的示意图。<br />
<img src="/images/GAT/5.png" width="80%"></p>
<h2 id="加权求和">加权求和</h2>
<p>得到归一化的注意力系数后，使用归一化的值计算对应特征的线性组合，作为每个顶点最后的输出特征（最后可以加一个非线性层<span
class="math inline">\(\sigma\)</span>）。<br />
<img src="/images/GAT/6.png" width="25%"></p>
<p><span class="math inline">\(h_i^{\prime}\)</span> 就是GAT输出的节点
<span class="math inline">\(i\)</span> 融合了邻域信息的新特征。</p>
<h2 id="多头注意力机制">多头注意力机制</h2>
<p>为了使 self-attention 的学习过程更稳定，发现使用
多头注意力（multi-head attention）来扩展注意力机制是很有效的。<br />
使用 <span class="math inline">\(K\)</span> 个独立的 attention
机制执行加权求和这样的变换，然后他们的特征连接（concatednated）在一起，就可以得到如下的输出：<br />
<img src="/images/GAT/7.png" width="30%"></p>
<p>其中，最后的返回输出 <span
class="math inline">\(h^{\prime}\)</span>，每个顶点都会有 <span
class="math inline">\(KF^{\prime}\)</span> 维的特征（不是<span
class="math inline">\(F^{\prime}\)</span>）。</p>
<p>下面右图表示 <span class="math inline">\(K=3\)</span> 时
多头注意力机制示意图。例如此图，节点1在邻域中具有多端注意机制，不同的箭头样式表示独立的注意力计算，通过连接或平均每个head获得<span
class="math inline">\(h_1\)</span>。<br />
<img src="/images/GAT/5.png" width="80%"></p>
<p>对于最后一个卷积层，如果还是使用多头注意力机制，那么就不用采取连接的方式合并不同的attention机制的结果了，而是采用求平均的方式进行处理，即：<br />
<img src="/images/GAT/8.png" width="30%"><br />
这里指的是直接连接softmax的方式，如果接一个全连接层，是无所谓的。</p>
<h2 id="总结">总结</h2>
<p>GAT 不依赖于完整的图结构，只依赖于边，因此可以用于 inductive
任务。<br />
GAT 可用于有向图。<br />
采用 Attention 机制，可以为不同的邻居节点分配不同的权重。<br />
尽管 multi-head attention 使得参数数量和空间复杂度变成 <span
class="math inline">\(K\)</span> 倍，但是每个 head 可以并行计算。</p>
<p>注意力机制以共享的方式应用于图的所有边，因此它不需要预先得到整个图结构或者所有顶点。这带来几个影响：<br />
（1）图可以是有向图，也可以是无向图。如果边 <span
class="math inline">\(j \to i\)</span> 不存在，则我们不需要计算系数
<span class="math inline">\(a_{i,j}\)</span>。<br />
（2）GAT 可以直接应用到归纳学习 inductinve learning
：模型可以预测那些在训练集中从未出现的图。</p>
<p>GraphSage
归纳学习模型对每个顶点采样固定大小的邻域，从而保持计算过程的一致性。这使得模型无法在测试期间访问整个邻域。注意：由于训练期间训练多个
epoch，则可能访问到顶点的整个邻域。也可以使用LSTM
技术来聚合邻域顶点，但是这需要假设邻域中存在一个一致的顶点顺序。GAT
没有这两个问题：GAT
在作用在完整的邻域上，并且不关心邻域内顶点的顺序。</p>
<h2 id="code">Code</h2>
<p>Pytorch：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RpZWdvOTk5L3B5R0FU">pyGAT<i class="fa fa-external-link-alt"></i></span><br />
Tensorflow：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1BldGFyVi0vR0FU">GAT<i class="fa fa-external-link-alt"></i></span><br />
博客：<span class="exturl" data-url="aHR0cHM6Ly9wZXRhci12LmNvbS9HQVQv">GAT<i class="fa fa-external-link-alt"></i></span></p>
<p>以Pytorch版本为例：<br />
<figure class="highlight python"><figcaption><span>train.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> load_data, accuracy</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> GAT, SpGAT</span><br><span class="line"></span><br><span class="line"><span class="comment"># Training settings</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--no-cuda&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;Disables CUDA training.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--fastmode&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;Validate during training pass.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--sparse&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>, <span class="built_in">help</span>=<span class="string">&#x27;GAT with sparse version or not.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">72</span>, <span class="built_in">help</span>=<span class="string">&#x27;Random seed.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">10000</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--lr&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.005</span>, <span class="built_in">help</span>=<span class="string">&#x27;Initial learning rate.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--weight_decay&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">5e-4</span>, <span class="built_in">help</span>=<span class="string">&#x27;Weight decay (L2 loss on parameters).&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--hidden&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">8</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of hidden units.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--nb_heads&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">8</span>, <span class="built_in">help</span>=<span class="string">&#x27;Number of head attentions.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--dropout&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.6</span>, <span class="built_in">help</span>=<span class="string">&#x27;Dropout rate (1 - keep probability).&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--alpha&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.2</span>, <span class="built_in">help</span>=<span class="string">&#x27;Alpha for the leaky_relu.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--patience&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">100</span>, <span class="built_in">help</span>=<span class="string">&#x27;Patience&#x27;</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">args.cuda = <span class="keyword">not</span> args.no_cuda <span class="keyword">and</span> torch.cuda.is_available()</span><br><span class="line"></span><br><span class="line">random.seed(args.seed)</span><br><span class="line">np.random.seed(args.seed)</span><br><span class="line">torch.manual_seed(args.seed)</span><br><span class="line"><span class="keyword">if</span> args.cuda:</span><br><span class="line">    torch.cuda.manual_seed(args.seed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load data</span></span><br><span class="line">adj, features, labels, idx_train, idx_val, idx_test = load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Model and optimizer</span></span><br><span class="line"><span class="keyword">if</span> args.sparse:</span><br><span class="line">    model = SpGAT(nfeat=features.shape[<span class="number">1</span>], </span><br><span class="line">                nhid=args.hidden, </span><br><span class="line">                nclass=<span class="built_in">int</span>(labels.<span class="built_in">max</span>()) + <span class="number">1</span>, </span><br><span class="line">                dropout=args.dropout, </span><br><span class="line">                nheads=args.nb_heads, </span><br><span class="line">                alpha=args.alpha)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    model = GAT(nfeat=features.shape[<span class="number">1</span>], </span><br><span class="line">                nhid=args.hidden, </span><br><span class="line">                nclass=<span class="built_in">int</span>(labels.<span class="built_in">max</span>()) + <span class="number">1</span>, </span><br><span class="line">                dropout=args.dropout, </span><br><span class="line">                nheads=args.nb_heads, </span><br><span class="line">                alpha=args.alpha)</span><br><span class="line">optimizer = optim.Adam(model.parameters(), </span><br><span class="line">                       lr=args.lr, </span><br><span class="line">                       weight_decay=args.weight_decay)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.cuda:</span><br><span class="line">    model.cuda()</span><br><span class="line">    features = features.cuda()</span><br><span class="line">    adj = adj.cuda()</span><br><span class="line">    labels = labels.cuda()</span><br><span class="line">    idx_train = idx_train.cuda()</span><br><span class="line">    idx_val = idx_val.cuda()</span><br><span class="line">    idx_test = idx_test.cuda()</span><br><span class="line"></span><br><span class="line">features, adj, labels = Variable(features), Variable(adj), Variable(labels)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch</span>):</span><br><span class="line">    t = time.time()</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    output = model(features, adj) <span class="comment"># GAT模块 features：(2708,1433) output：(2708,7)</span></span><br><span class="line">    loss_train = F.nll_loss(output[idx_train], labels[idx_train])</span><br><span class="line">    acc_train = accuracy(output[idx_train], labels[idx_train])</span><br><span class="line">    loss_train.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args.fastmode:</span><br><span class="line">        <span class="comment"># Evaluate validation set performance separately,</span></span><br><span class="line">        <span class="comment"># deactivates dropout during validation run.</span></span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        output = model(features, adj)</span><br><span class="line"></span><br><span class="line">    loss_val = F.nll_loss(output[idx_val], labels[idx_val])</span><br><span class="line">    acc_val = accuracy(output[idx_val], labels[idx_val])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Epoch: &#123;:04d&#125;&#x27;</span>.<span class="built_in">format</span>(epoch+<span class="number">1</span>),</span><br><span class="line">          <span class="string">&#x27;loss_train: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(loss_train.data.item()),</span><br><span class="line">          <span class="string">&#x27;acc_train: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(acc_train.data.item()),</span><br><span class="line">          <span class="string">&#x27;loss_val: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(loss_val.data.item()),</span><br><span class="line">          <span class="string">&#x27;acc_val: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(acc_val.data.item()),</span><br><span class="line">          <span class="string">&#x27;time: &#123;:.4f&#125;s&#x27;</span>.<span class="built_in">format</span>(time.time() - t))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss_val.data.item()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_test</span>():</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    output = model(features, adj)</span><br><span class="line">    loss_test = F.nll_loss(output[idx_test], labels[idx_test])</span><br><span class="line">    acc_test = accuracy(output[idx_test], labels[idx_test])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test set results:&quot;</span>,</span><br><span class="line">          <span class="string">&quot;loss= &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(loss_test.data[<span class="number">0</span>]),</span><br><span class="line">          <span class="string">&quot;accuracy= &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(acc_test.data[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Train model</span></span><br><span class="line">t_total = time.time()</span><br><span class="line">loss_values = []</span><br><span class="line">bad_counter = <span class="number">0</span></span><br><span class="line">best = args.epochs + <span class="number">1</span></span><br><span class="line">best_epoch = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(args.epochs):</span><br><span class="line">    loss_values.append(train(epoch))</span><br><span class="line"></span><br><span class="line">    torch.save(model.state_dict(), <span class="string">&#x27;&#123;&#125;.pkl&#x27;</span>.<span class="built_in">format</span>(epoch))</span><br><span class="line">    <span class="keyword">if</span> loss_values[-<span class="number">1</span>] &lt; best:</span><br><span class="line">        best = loss_values[-<span class="number">1</span>]</span><br><span class="line">        best_epoch = epoch</span><br><span class="line">        bad_counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bad_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bad_counter == args.patience:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    files = glob.glob(<span class="string">&#x27;*.pkl&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        epoch_nb = <span class="built_in">int</span>(file.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> epoch_nb &lt; best_epoch:</span><br><span class="line">            os.remove(file)</span><br><span class="line"></span><br><span class="line">files = glob.glob(<span class="string">&#x27;*.pkl&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    epoch_nb = <span class="built_in">int</span>(file.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> epoch_nb &gt; best_epoch:</span><br><span class="line">        os.remove(file)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Optimization Finished!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total time elapsed: &#123;:.4f&#125;s&quot;</span>.<span class="built_in">format</span>(time.time() - t_total))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restore best model</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Loading &#123;&#125;th epoch&#x27;</span>.<span class="built_in">format</span>(best_epoch))</span><br><span class="line">model.load_state_dict(torch.load(<span class="string">&#x27;&#123;&#125;.pkl&#x27;</span>.<span class="built_in">format</span>(best_epoch)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Testing</span></span><br><span class="line">compute_test()</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><figcaption><span>model.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> layers <span class="keyword">import</span> GraphAttentionLayer, SpGraphAttentionLayer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GAT</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nfeat, nhid, nclass, dropout, alpha, nheads</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Dense version of GAT.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(GAT, self).__init__()</span><br><span class="line">        self.dropout = dropout</span><br><span class="line"></span><br><span class="line">        <span class="comment"># nfeat：输入特征1433，nhid：隐层特征8，nheads：多头数量8</span></span><br><span class="line">        <span class="comment"># 因为用了多头，结果包含nheads个layer</span></span><br><span class="line">        self.attentions = [GraphAttentionLayer(nfeat, nhid, dropout=dropout, alpha=alpha, concat=<span class="literal">True</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nheads)]</span><br><span class="line">        <span class="keyword">for</span> i, attention <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.attentions):</span><br><span class="line">            self.add_module(<span class="string">&#x27;attention_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i), attention)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第二层（最后一层）的attention layer</span></span><br><span class="line">        self.out_att = GraphAttentionLayer(nhid * nheads, nclass, dropout=dropout, alpha=alpha, concat=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, adj</span>):</span><br><span class="line">        x = F.dropout(x, self.dropout, training=self.training)</span><br><span class="line">        <span class="comment"># 将每层attention拼接，8次，x：(2708,64)</span></span><br><span class="line">        x = torch.cat([att(x, adj) <span class="keyword">for</span> att <span class="keyword">in</span> self.attentions], dim=<span class="number">1</span>) </span><br><span class="line">        x = F.dropout(x, self.dropout, training=self.training)</span><br><span class="line">        x = F.elu(self.out_att(x, adj)) <span class="comment"># 第二层的attention layer </span></span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>) <span class="comment"># 输出(2708,7)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpGAT</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nfeat, nhid, nclass, dropout, alpha, nheads</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Sparse version of GAT.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(SpGAT, self).__init__()</span><br><span class="line">        self.dropout = dropout</span><br><span class="line"></span><br><span class="line">        self.attentions = [SpGraphAttentionLayer(nfeat, </span><br><span class="line">                                                 nhid, </span><br><span class="line">                                                 dropout=dropout, </span><br><span class="line">                                                 alpha=alpha, </span><br><span class="line">                                                 concat=<span class="literal">True</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(nheads)]</span><br><span class="line">        <span class="keyword">for</span> i, attention <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.attentions):</span><br><span class="line">            self.add_module(<span class="string">&#x27;attention_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i), attention)</span><br><span class="line"></span><br><span class="line">        self.out_att = SpGraphAttentionLayer(nhid * nheads, </span><br><span class="line">                                             nclass, </span><br><span class="line">                                             dropout=dropout, </span><br><span class="line">                                             alpha=alpha, </span><br><span class="line">                                             concat=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, adj</span>):</span><br><span class="line">        x = F.dropout(x, self.dropout, training=self.training)</span><br><span class="line">        x = torch.cat([att(x, adj) <span class="keyword">for</span> att <span class="keyword">in</span> self.attentions], dim=<span class="number">1</span>)</span><br><span class="line">        x = F.dropout(x, self.dropout, training=self.training)</span><br><span class="line">        x = F.elu(self.out_att(x, adj))</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>layers.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAttentionLayer</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Simple GAT layer, similar to https://arxiv.org/abs/1710.10903</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_features, out_features, dropout, alpha, concat=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GraphAttentionLayer, self).__init__()</span><br><span class="line">        self.dropout = dropout</span><br><span class="line">        self.in_features = in_features <span class="comment"># 1433</span></span><br><span class="line">        self.out_features = out_features <span class="comment"># 8</span></span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        self.concat = concat</span><br><span class="line"></span><br><span class="line">        self.W = nn.Parameter(torch.empty(size=(in_features, out_features))) <span class="comment"># (1433,8)</span></span><br><span class="line">        nn.init.xavier_uniform_(self.W.data, gain=<span class="number">1.414</span>)</span><br><span class="line">        self.a = nn.Parameter(torch.empty(size=(<span class="number">2</span>*out_features, <span class="number">1</span>))) <span class="comment"># (16,1) 公式中的a</span></span><br><span class="line">        nn.init.xavier_uniform_(self.a.data, gain=<span class="number">1.414</span>)</span><br><span class="line"></span><br><span class="line">        self.leakyrelu = nn.LeakyReLU(self.alpha)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, h, adj</span>):</span><br><span class="line">        Wh = torch.mm(h, self.W) <span class="comment"># h.shape: (N, in_features), Wh.shape: (N, out_features)</span></span><br><span class="line">        <span class="comment"># a_input：(2708,2708,16) 每一个节点和所有节点特征拼接。</span></span><br><span class="line">        a_input = self._prepare_attentional_mechanism_input(Wh) </span><br><span class="line">        e = self.leakyrelu(torch.matmul(a_input, self.a).squeeze(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 之前计算的是一个节点和所有节点的attention，其实需要的是连接的节点的attention系数</span></span><br><span class="line">        zero_vec = -<span class="number">9e15</span>*torch.ones_like(e)</span><br><span class="line">        <span class="comment"># adj &gt; 0 表示相邻的</span></span><br><span class="line">        attention = torch.where(adj &gt; <span class="number">0</span>, e, zero_vec) <span class="comment"># 将邻接矩阵中小于0的变成负无穷</span></span><br><span class="line">        attention = F.softmax(attention, dim=<span class="number">1</span>) <span class="comment"># 按行求softmax，sum(axis=1)==1</span></span><br><span class="line">        attention = F.dropout(attention, self.dropout, training=self.training)</span><br><span class="line">        h_prime = torch.matmul(attention, Wh) <span class="comment"># 聚合邻居函数 h_prime：(2708,8)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.concat:</span><br><span class="line">            <span class="keyword">return</span> F.elu(h_prime) <span class="comment"># elu-激活函数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> h_prime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_prepare_attentional_mechanism_input</span>(<span class="params">self, Wh</span>):</span><br><span class="line">        N = Wh.size()[<span class="number">0</span>] <span class="comment"># number of nodes</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Below, two matrices are created that contain embeddings in their rows in different orders.</span></span><br><span class="line">        <span class="comment"># (e stands for embedding)</span></span><br><span class="line">        <span class="comment"># These are the rows of the first matrix (Wh_repeated_in_chunks): </span></span><br><span class="line">        <span class="comment"># e1, e1, ..., e1,            e2, e2, ..., e2,            ..., eN, eN, ..., eN</span></span><br><span class="line">        <span class="comment"># &#x27;-------------&#x27; -&gt; N times  &#x27;-------------&#x27; -&gt; N times       &#x27;-------------&#x27; -&gt; N times</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        <span class="comment"># These are the rows of the second matrix (Wh_repeated_alternating): </span></span><br><span class="line">        <span class="comment"># e1, e2, ..., eN, e1, e2, ..., eN, ..., e1, e2, ..., eN </span></span><br><span class="line">        <span class="comment"># &#x27;----------------------------------------------------&#x27; -&gt; N times</span></span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        </span><br><span class="line">        Wh_repeated_in_chunks = Wh.repeat_interleave(N, dim=<span class="number">0</span>) <span class="comment"># 复制</span></span><br><span class="line">        Wh_repeated_alternating = Wh.repeat(N, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># Wh_repeated_in_chunks.shape == Wh_repeated_alternating.shape == (N * N, out_features)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># The all_combination_matrix, created below, will look like this (|| denotes concatenation):</span></span><br><span class="line">        <span class="comment"># e1 || e1</span></span><br><span class="line">        <span class="comment"># e1 || e2</span></span><br><span class="line">        <span class="comment"># e1 || e3</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># e1 || eN</span></span><br><span class="line">        <span class="comment"># e2 || e1</span></span><br><span class="line">        <span class="comment"># e2 || e2</span></span><br><span class="line">        <span class="comment"># e2 || e3</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># e2 || eN</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># eN || e1</span></span><br><span class="line">        <span class="comment"># eN || e2</span></span><br><span class="line">        <span class="comment"># eN || e3</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># eN || eN</span></span><br><span class="line"></span><br><span class="line">        all_combinations_matrix = torch.cat([Wh_repeated_in_chunks, Wh_repeated_alternating], dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># all_combinations_matrix.shape == (N * N, 2 * out_features)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> all_combinations_matrix.view(N, N, <span class="number">2</span> * self.out_features)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__class__.__name__ + <span class="string">&#x27; (&#x27;</span> + <span class="built_in">str</span>(self.in_features) + <span class="string">&#x27; -&gt; &#x27;</span> + <span class="built_in">str</span>(self.out_features) + <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialSpmmFunction</span>(torch.autograd.Function):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Special function for only sparse region backpropataion layer.&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">ctx, indices, values, shape, b</span>):</span><br><span class="line">        <span class="keyword">assert</span> indices.requires_grad == <span class="literal">False</span></span><br><span class="line">        a = torch.sparse_coo_tensor(indices, values, shape)</span><br><span class="line">        ctx.save_for_backward(a, b)</span><br><span class="line">        ctx.N = shape[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> torch.matmul(a, b)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">ctx, grad_output</span>):</span><br><span class="line">        a, b = ctx.saved_tensors</span><br><span class="line">        grad_values = grad_b = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> ctx.needs_input_grad[<span class="number">1</span>]:</span><br><span class="line">            grad_a_dense = grad_output.matmul(b.t())</span><br><span class="line">            edge_idx = a._indices()[<span class="number">0</span>, :] * ctx.N + a._indices()[<span class="number">1</span>, :]</span><br><span class="line">            grad_values = grad_a_dense.view(-<span class="number">1</span>)[edge_idx]</span><br><span class="line">        <span class="keyword">if</span> ctx.needs_input_grad[<span class="number">3</span>]:</span><br><span class="line">            grad_b = a.t().matmul(grad_output)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, grad_values, <span class="literal">None</span>, grad_b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialSpmm</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, indices, values, shape, b</span>):</span><br><span class="line">        <span class="keyword">return</span> SpecialSpmmFunction.apply(indices, values, shape, b)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpGraphAttentionLayer</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Sparse version GAT layer, similar to https://arxiv.org/abs/1710.10903</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_features, out_features, dropout, alpha, concat=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(SpGraphAttentionLayer, self).__init__()</span><br><span class="line">        self.in_features = in_features</span><br><span class="line">        self.out_features = out_features</span><br><span class="line">        self.alpha = alpha</span><br><span class="line">        self.concat = concat</span><br><span class="line"></span><br><span class="line">        self.W = nn.Parameter(torch.zeros(size=(in_features, out_features)))</span><br><span class="line">        nn.init.xavier_normal_(self.W.data, gain=<span class="number">1.414</span>)</span><br><span class="line">                </span><br><span class="line">        self.a = nn.Parameter(torch.zeros(size=(<span class="number">1</span>, <span class="number">2</span>*out_features)))</span><br><span class="line">        nn.init.xavier_normal_(self.a.data, gain=<span class="number">1.414</span>)</span><br><span class="line"></span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line">        self.leakyrelu = nn.LeakyReLU(self.alpha)</span><br><span class="line">        self.special_spmm = SpecialSpmm()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span>, adj</span>):</span><br><span class="line">        dv = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> <span class="built_in">input</span>.is_cuda <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"></span><br><span class="line">        N = <span class="built_in">input</span>.size()[<span class="number">0</span>]</span><br><span class="line">        edge = adj.nonzero().t()</span><br><span class="line"></span><br><span class="line">        h = torch.mm(<span class="built_in">input</span>, self.W)</span><br><span class="line">        <span class="comment"># h: N x out</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> torch.isnan(h).<span class="built_in">any</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Self-attention on the nodes - Shared attention mechanism</span></span><br><span class="line">        edge_h = torch.cat((h[edge[<span class="number">0</span>, :], :], h[edge[<span class="number">1</span>, :], :]), dim=<span class="number">1</span>).t()</span><br><span class="line">        <span class="comment"># edge: 2*D x E</span></span><br><span class="line"></span><br><span class="line">        edge_e = torch.exp(-self.leakyrelu(self.a.mm(edge_h).squeeze()))</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> torch.isnan(edge_e).<span class="built_in">any</span>()</span><br><span class="line">        <span class="comment"># edge_e: E</span></span><br><span class="line"></span><br><span class="line">        e_rowsum = self.special_spmm(edge, edge_e, torch.Size([N, N]), torch.ones(size=(N,<span class="number">1</span>), device=dv))</span><br><span class="line">        <span class="comment"># e_rowsum: N x 1</span></span><br><span class="line"></span><br><span class="line">        edge_e = self.dropout(edge_e)</span><br><span class="line">        <span class="comment"># edge_e: E</span></span><br><span class="line"></span><br><span class="line">        h_prime = self.special_spmm(edge, edge_e, torch.Size([N, N]), h)</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> torch.isnan(h_prime).<span class="built_in">any</span>()</span><br><span class="line">        <span class="comment"># h_prime: N x out</span></span><br><span class="line">        </span><br><span class="line">        h_prime = h_prime.div(e_rowsum)</span><br><span class="line">        <span class="comment"># h_prime: N x out</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> torch.isnan(h_prime).<span class="built_in">any</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.concat:</span><br><span class="line">            <span class="comment"># if this layer is not last layer,</span></span><br><span class="line">            <span class="keyword">return</span> F.elu(h_prime)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># if this layer is last layer,</span></span><br><span class="line">            <span class="keyword">return</span> h_prime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__class__.__name__ + <span class="string">&#x27; (&#x27;</span> + <span class="built_in">str</span>(self.in_features) + <span class="string">&#x27; -&gt; &#x27;</span> + <span class="built_in">str</span>(self.out_features) + <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>utils.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_onehot</span>(<span class="params">labels</span>):</span><br><span class="line">    <span class="comment"># The classes must be sorted before encoding to enable static class encoding.</span></span><br><span class="line">    <span class="comment"># In other words, make sure the first class always maps to index 0.</span></span><br><span class="line">    classes = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(labels)))</span><br><span class="line">    classes_dict = &#123;c: np.identity(<span class="built_in">len</span>(classes))[i, :] <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(classes)&#125;</span><br><span class="line">    labels_onehot = np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(classes_dict.get, labels)), dtype=np.int32)</span><br><span class="line">    <span class="keyword">return</span> labels_onehot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">path=<span class="string">&quot;./data/cora/&quot;</span>, dataset=<span class="string">&quot;cora&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Load citation network dataset (cora only for now)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loading &#123;&#125; dataset...&#x27;</span>.<span class="built_in">format</span>(dataset))</span><br><span class="line"></span><br><span class="line">    idx_features_labels = np.genfromtxt(<span class="string">&quot;&#123;&#125;&#123;&#125;.content&quot;</span>.<span class="built_in">format</span>(path, dataset), dtype=np.dtype(<span class="built_in">str</span>))</span><br><span class="line">    features = sp.csr_matrix(idx_features_labels[:, <span class="number">1</span>:-<span class="number">1</span>], dtype=np.float32)</span><br><span class="line">    labels = encode_onehot(idx_features_labels[:, -<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># build graph</span></span><br><span class="line">    idx = np.array(idx_features_labels[:, <span class="number">0</span>], dtype=np.int32)</span><br><span class="line">    idx_map = &#123;j: i <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(idx)&#125;</span><br><span class="line">    <span class="comment"># 将边导入</span></span><br><span class="line">    edges_unordered = np.genfromtxt(<span class="string">&quot;&#123;&#125;&#123;&#125;.cites&quot;</span>.<span class="built_in">format</span>(path, dataset), dtype=np.int32)</span><br><span class="line">    <span class="comment"># 将点对应到dictionary中</span></span><br><span class="line">    edges = np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(idx_map.get, edges_unordered.flatten())), dtype=np.int32).reshape(edges_unordered.shape)</span><br><span class="line">    <span class="comment"># 建立边的邻接矩阵</span></span><br><span class="line">    adj = sp.coo_matrix((np.ones(edges.shape[<span class="number">0</span>]), (edges[:, <span class="number">0</span>], edges[:, <span class="number">1</span>])), shape=(labels.shape[<span class="number">0</span>], labels.shape[<span class="number">0</span>]), dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># build symmetric adjacency matrix 构建对称矩阵</span></span><br><span class="line">    adj = adj + adj.T.multiply(adj.T &gt; adj) - adj.multiply(adj.T &gt; adj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 归一化</span></span><br><span class="line">    features = normalize_features(features)</span><br><span class="line">    adj = normalize_adj(adj + sp.eye(adj.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    idx_train = <span class="built_in">range</span>(<span class="number">140</span>)</span><br><span class="line">    idx_val = <span class="built_in">range</span>(<span class="number">200</span>, <span class="number">500</span>)</span><br><span class="line">    idx_test = <span class="built_in">range</span>(<span class="number">500</span>, <span class="number">1500</span>)</span><br><span class="line"></span><br><span class="line">    adj = torch.FloatTensor(np.array(adj.todense()))</span><br><span class="line">    features = torch.FloatTensor(np.array(features.todense()))</span><br><span class="line">    labels = torch.LongTensor(np.where(labels)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    idx_train = torch.LongTensor(idx_train)</span><br><span class="line">    idx_val = torch.LongTensor(idx_val)</span><br><span class="line">    idx_test = torch.LongTensor(idx_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adj, features, labels, idx_train, idx_val, idx_test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize_adj</span>(<span class="params">mx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Row-normalize sparse matrix&quot;&quot;&quot;</span></span><br><span class="line">    rowsum = np.array(mx.<span class="built_in">sum</span>(<span class="number">1</span>))</span><br><span class="line">    r_inv_sqrt = np.power(rowsum, -<span class="number">0.5</span>).flatten()</span><br><span class="line">    r_inv_sqrt[np.isinf(r_inv_sqrt)] = <span class="number">0.</span></span><br><span class="line">    r_mat_inv_sqrt = sp.diags(r_inv_sqrt)</span><br><span class="line">    <span class="keyword">return</span> mx.dot(r_mat_inv_sqrt).transpose().dot(r_mat_inv_sqrt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize_features</span>(<span class="params">mx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Row-normalize sparse matrix&quot;&quot;&quot;</span></span><br><span class="line">    rowsum = np.array(mx.<span class="built_in">sum</span>(<span class="number">1</span>))</span><br><span class="line">    r_inv = np.power(rowsum, -<span class="number">1</span>).flatten()</span><br><span class="line">    r_inv[np.isinf(r_inv)] = <span class="number">0.</span></span><br><span class="line">    r_mat_inv = sp.diags(r_inv)</span><br><span class="line">    mx = r_mat_inv.dot(mx)</span><br><span class="line">    <span class="keyword">return</span> mx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">output, labels</span>):</span><br><span class="line">    preds = output.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">1</span>].type_as(labels)</span><br><span class="line">    correct = preds.eq(labels).double()</span><br><span class="line">    correct = correct.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(labels)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>visualize_graph.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> graphviz <span class="keyword">import</span> Digraph</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_dot</span>(<span class="params">var, params</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Produces Graphviz representation of PyTorch autograd graph</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Blue nodes are the Variables that require grad, orange are Tensors</span></span><br><span class="line"><span class="string">    saved for backward in torch.autograd.Function</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        var: output Variable</span></span><br><span class="line"><span class="string">        params: dict of (name, Variable) to add names to node that</span></span><br><span class="line"><span class="string">            require grad (TODO: make optional)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    param_map = &#123;<span class="built_in">id</span>(v): k <span class="keyword">for</span> k, v <span class="keyword">in</span> params.items()&#125;</span><br><span class="line">    <span class="built_in">print</span>(param_map)</span><br><span class="line">    </span><br><span class="line">    node_attr = <span class="built_in">dict</span>(style=<span class="string">&#x27;filled&#x27;</span>,</span><br><span class="line">                     shape=<span class="string">&#x27;box&#x27;</span>,</span><br><span class="line">                     align=<span class="string">&#x27;left&#x27;</span>,</span><br><span class="line">                     fontsize=<span class="string">&#x27;12&#x27;</span>,</span><br><span class="line">                     ranksep=<span class="string">&#x27;0.1&#x27;</span>,</span><br><span class="line">                     height=<span class="string">&#x27;0.2&#x27;</span>)</span><br><span class="line">    dot = Digraph(node_attr=node_attr, graph_attr=<span class="built_in">dict</span>(size=<span class="string">&quot;12,12&quot;</span>))</span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size_to_str</span>(<span class="params">size</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>+(<span class="string">&#x27;, &#x27;</span>).join([<span class="string">&#x27;%d&#x27;</span>% v <span class="keyword">for</span> v <span class="keyword">in</span> size])+<span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_nodes</span>(<span class="params">var</span>):</span><br><span class="line">        <span class="keyword">if</span> var <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">if</span> torch.is_tensor(var):</span><br><span class="line">                dot.node(<span class="built_in">str</span>(<span class="built_in">id</span>(var)), size_to_str(var.size()), fillcolor=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">hasattr</span>(var, <span class="string">&#x27;variable&#x27;</span>):</span><br><span class="line">                u = var.variable</span><br><span class="line">                node_name = <span class="string">&#x27;%s\n %s&#x27;</span> % (param_map.get(<span class="built_in">id</span>(u)), size_to_str(u.size()))</span><br><span class="line">                dot.node(<span class="built_in">str</span>(<span class="built_in">id</span>(var)), node_name, fillcolor=<span class="string">&#x27;lightblue&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dot.node(<span class="built_in">str</span>(<span class="built_in">id</span>(var)), <span class="built_in">str</span>(<span class="built_in">type</span>(var).__name__))</span><br><span class="line">            seen.add(var)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(var, <span class="string">&#x27;next_functions&#x27;</span>):</span><br><span class="line">                <span class="keyword">for</span> u <span class="keyword">in</span> var.next_functions:</span><br><span class="line">                    <span class="keyword">if</span> u[<span class="number">0</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                        dot.edge(<span class="built_in">str</span>(<span class="built_in">id</span>(u[<span class="number">0</span>])), <span class="built_in">str</span>(<span class="built_in">id</span>(var)))</span><br><span class="line">                        add_nodes(u[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(var, <span class="string">&#x27;saved_tensors&#x27;</span>):</span><br><span class="line">                <span class="keyword">for</span> t <span class="keyword">in</span> var.saved_tensors:</span><br><span class="line">                    dot.edge(<span class="built_in">str</span>(<span class="built_in">id</span>(t)), <span class="built_in">str</span>(<span class="built_in">id</span>(var)))</span><br><span class="line">                    add_nodes(t)</span><br><span class="line">    add_nodes(var.grad_fn)</span><br><span class="line">    <span class="keyword">return</span> dot</span><br><span class="line"></span><br><span class="line">inputs = torch.randn(<span class="number">100</span>, <span class="number">50</span>).cuda()</span><br><span class="line">adj = torch.randn(<span class="number">100</span>, <span class="number">100</span>).cuda()</span><br><span class="line">model = models.SpGAT(<span class="number">50</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">0.5</span>, <span class="number">0.01</span>, <span class="number">3</span>)</span><br><span class="line">model = model.cuda()</span><br><span class="line">y = model(inputs, adj)</span><br><span class="line"></span><br><span class="line">g = make_dot(y, model.state_dict())</span><br><span class="line">g.view()</span><br></pre></td></tr></table></figure>
<h1 id="参考文献">参考文献</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MTAuMTA5MDMucGRm">GRAPH ATTENTION
NETWORKS<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTY3MTAyODk2NDU0NDg4NDc0OSZ3ZnI9c3BpZGVyJmZvcj1wYw==">GAT
图注意力网络 Graph Attention Network<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MzEyMTQxL2FydGljbGUvZGV0YWlscy8xMDYyOTExOTU=">图注意力网络(GAT)<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlxaXpoaXhpbi5jb20vYXJ0aWNsZXMvMjAxOS0wMi0xOS03">深入理解图注意力机制<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzkwODc3MDY=">GAT详解<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2021/02/05/Graph/01.GCN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/05/Graph/01.GCN/" class="post-title-link" itemprop="url">GCN</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-05 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-05T00:00:00+08:00">2021-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Graph/" itemprop="url" rel="index"><span itemprop="name">Graph</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="图论">图论</h1>
<p>最开始是1707年由 Seven bridges
问题而来的，欧拉把这个问题转成图解决。近代图论1959年 Erdos 和 Renyi
发表的 Random Graph
一系列论文建立起来的全新领域。目前学术界和工业界是基于1999年 brabasi
提出的 Scale-free Network 进行的。</p>
<h2 id="degree-distribution">degree-distribution</h2>
<p><strong>度分布，即每个节点按边的数量分类，每类节点占总结点比例</strong>。一般
Random Graph 的度分布是
<strong>泊松分布</strong>（poisson，类似正态分布）。但基于 Scale-free
Network 的提出，我们发现很多网络结构是
<strong>幂律分布</strong>（power-law）。</p>
<p><img src="/images/GCN/随机网络.png" width="80%"><br />
<img src="/images/GCN/无标度网络.png" width="80%"></p>
<h2 id="distancehilbert-space">Distance(Hilbert Space)</h2>
<p>每个节点具有多维features，可以看成多维空间，计算Distance也可看作Similarity。为什么在
Hilbert Space ，因为要方便后面约束优化。</p>
<p>GCN要求：<br />
（1）weights <span class="math inline">\(\geq\)</span> 0<br />
（2）linear calculation<br />
（3）Inner product</p>
<p>Hilbert Space（括号表示内积）：<br />
（1）对称性：<span class="math inline">\((\vec{y}, \vec{x})\)</span> =
<span class="math inline">\((\vec{x}, \vec{y})\)</span><br />
（2）线性：<span class="math inline">\((a\vec{x\_1}+b \vec{x\_2},
\vec{y})\)</span> = <span class="math inline">\(a(\vec{x_1},
\vec{y})+b(\vec{x_2}, \vec{y})\)</span><br />
（3）半正定性：<span class="math inline">\((\vec{x}, \vec{x}) \geq
0\)</span>，if <span
class="math inline">\(\vec{x}=\vec{0}\)</span>，<span
class="math inline">\((\vec{x}, \vec{x}) = 0\)</span></p>
<p>Distance(Hilbert Space)：<span class="math inline">\(d(\vec{x},
\vec{y})=||\vec{x}-\vec{y}||=\sqrt{(\vec{x}-\vec{y},
\vec{x}-\vec{y})}\)</span></p>
<h2 id="adjacency-matrix">adjacency matrix</h2>
<p>邻接矩阵。阶为<span class="math inline">\(n\)</span>的图<span
class="math inline">\(G\)</span>的邻接矩阵<span
class="math inline">\(A\)</span>是<span class="math inline">\(n\times
n\)</span>的。将<span class="math inline">\(G\)</span>的顶点标签为<span
class="math inline">\(v_{1},v_{2},...,v_{n}\)</span>。若<span
class="math inline">\((v_{i},v_{j})\in E(G)\)</span>，<span
class="math inline">\(A_{ij}=1\)</span>，否则<span
class="math inline">\(A_{ij}=0\)</span>。也可以用大于0的值表示边的权值，例如可以用边权值表示一个点到另一个点的距离。</p>
<p>无向图的邻接矩阵计算方法是每条边为对应的单元加上1，而每个自环加上2。这样让某一节点的度数可以通过邻接矩阵的对应行或者列求和得到。<br />
<img src="/images/GCN/邻接矩阵.png" width="50%"></p>
<p>有向图的邻接矩阵可以是不对称的。我们可以定义有向图的邻接矩阵中的某个元素
<span class="math inline">\(A_{ij}\)</span> 代表：<br />
（1）从 <span class="math inline">\(i\)</span> 指向 <span
class="math inline">\(j\)</span> 的边数目。<br />
（2）从 <span class="math inline">\(j\)</span> 指向 <span
class="math inline">\(i\)</span> 的边数目。<br />
在第一种定义下，有向图的某个节点的入度可以通过对应的列（column）求和而得，出度可以通过对应的行（row）求和而得。在第二种定义下，入度可以通过对应的行（row）求和而得，出度可以通过对应的列（column）求和而得。<br />
<img src="/images/GCN/邻接矩阵2.png" width="50%"></p>
<h2 id="clustering-coefficient">Clustering coefficient</h2>
<p>聚类系数，一个图中的顶点之间结集成团的程度的系数。集聚系数分为整体与局部两种。整体集聚系数可以给出一个图中整体的集聚程度的评估，而局部集聚系数则可以测量图中每一个结点附近的集聚程度。</p>
<p><strong>分子</strong>：闭三点组（邻近三点组成“三角形”）数量。<br />
<strong>分母</strong>：闭三点组（邻近三点组成“三角形”）数量 +
开三点组（邻近三点组成“缺一条边的三角形”）数量。</p>
<p>整体聚类系数：对每个节点的聚类系数求和取均值。<strong>如果该值很大，表示图是很稠密的，节点和节点之间联系紧密</strong>。</p>
<h2 id="betweenness">Betweenness</h2>
<p>也叫Betweenness centrality，分node和edge两种计算方法：<br />
（1）<strong>node
Betweenness</strong>：计算经过一个点的最短路径的数量占所有最短路径数量比例。两点一组，遍历所有组，计算每组中经过一个点的最短路径的数量占该组最短路径数量比例，最后求和。<br />
（2）<strong>edge Betweenness</strong>：node Betweenness
换成边即可。</p>
<p><strong>这个值很大，表示此node或edge很重要，因为很多最短路径都要经过它，表现流通性</strong>。</p>
<p>缺点：需要遍历所有点找到所有最短路径，一般的算法有
迪杰斯特拉算法（Dijkstra） 和 弗洛伊德算法（Floyd），时间复杂度都为
<span class="math inline">\(O(n^3)\)</span>。</p>
<h1 id="gcn">GCN</h1>
<p>GCN（Graph Convolutional
Networks，图卷积神经网络），实际上跟CNN的作用一样，就是一个特征提取器，只不过它的对象是图数据。<br />
GCN精妙地设计了一种从图数据中提取特征的方法，从而让我们可以使用这些特征去对图数据进行<strong>节点分类</strong>（node
classification）、<strong>图分类</strong>（graph
classification）、<strong>边预测</strong>（link
prediction），还可以顺便得到<strong>图的嵌入表示</strong>（graph
embedding）。</p>
<p>GCN发展历史，那么肯定绕不过下面三篇论文：<br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzEzMTIuNjIwMy5wZGY=">Spectral Networks and Deep
Locally Connected Networks on Graphs<i class="fa fa-external-link-alt"></i></span> 2014年<br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE2MDYuMDkzNzUucGRm">Convolutional Neural
Networks on Graphs with Fast Localized Spectral Filtering<i class="fa fa-external-link-alt"></i></span>
2016年<br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE2MDkuMDI5MDcucGRm">Semi-Supervised
Classification with Graph Convolutional Networks<i class="fa fa-external-link-alt"></i></span> 2017年</p>
<p>在计算机科学领域、理论物理复杂网络领域的研究者在图（Graph）的空间域（spatial
domain）和频谱域（spectral
domain）分别提出了不同形式的图神经网络，并最终在2017年实现了空间域模型和频谱域模型的融合，即目前我们使用的第三代GCN。</p>
<p>对于其中理论和公式非常感兴趣的参考<span class="exturl" data-url="aHR0cDovL3h0ZjYxNS5jb20vMjAxOS8wMi8yNC9nY24v">图卷积神经网络理论基础<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="fourier-transform">Fourier transform</h2>
<p><span class="math display">\[
F(w)=\frac{1}{2\pi}\int_{-\infty}^{+\infty} f(t)e^{-j\omega t} {\rm d}t
\]</span></p>
<p><span class="math inline">\(F(\omega)\)</span>
就是<strong>傅里叶变换</strong>，得到的就是<strong>频域曲线</strong>。每个频率<span
class="math inline">\(\omega\)</span>下都有对应的振幅<span
class="math inline">\(F(\omega)\)</span>。从几何上来看，<span
class="math inline">\(f(t)\)</span> 以 <span
class="math inline">\(e^{-j\omega t}\)</span> 为基函数投影，<span
class="math inline">\(F(w)\)</span> 就是以频率 <span
class="math inline">\(\omega\)</span> 对应基上的投影的坐标。</p>
<p>从数学角度来看，<span class="math inline">\(f(x)\)</span> 是函数
<span class="math inline">\(f\)</span> 在 <span
class="math inline">\(t\)</span>
处的取值，所有基都对该处取值有贡献，即把每个<span
class="math inline">\(F(w)\)</span> 投影到 <span
class="math inline">\(e^{-j\omega t}\)</span>
基方向上分量累加起来，得到的就是该点处的函数值。<br />
<span class="math display">\[
f(t) = \int_{-\infty}^{+\infty}F(w)e^{-j\omega t}\, {\rm
d}\omega=\sum_{\omega}F(w)e^{-j\omega t}
\]</span><br />
上面简化了一下，用 <span class="math inline">\(w\)</span>
代表频率。这个公式也叫做<strong>逆傅里叶变换</strong>。</p>
<h2 id="laplacian-operater">Laplacian operater</h2>
<p><span class="math display">\[
\Delta f = \Delta^2 f = \sum_{i=1}^{n}\frac{\partial^2 f}{\partial
x_i^2}
\]</span><br />
<span class="math inline">\(f\)</span>
是拉普拉斯算子作用的函数，求函数各向二阶导数再求和，定义为 <span
class="math inline">\(f\)</span> 上的拉普拉斯算子。<br />
可以理解为：<strong>二阶导数等于其在所有自由度上微扰之后获得的增益</strong>。<br />
更形象的理解：<strong>拉普拉斯算子就是在所有自由度上进行微小变化后获得的增益</strong>。</p>
<p>求 <span class="math inline">\(e^{-j\omega t}\)</span> 上的 Laplacian
operater：<br />
<span class="math display">\[
\Delta f = \Delta e^{-j\omega t} = \sum_{i=1}^{n}\frac{\partial^2
e^{-j\omega t}}{\partial t^2}=-\omega^2 e^{-j\omega t}
\]</span><br />
由此可知，<span class="math inline">\(e^{-j\omega t}\)</span> 是
<strong>Laplacian operater 的特征向量</strong>（满足特征方程 <span
class="math inline">\(A\vec{x}=\lambda \vec{x}\)</span>）。</p>
<h2 id="graph-laplacian-operater">Graph Laplacian operater</h2>
<p>Laplacian operater 推广到
Graph：假设<strong>图是一个完全图，即任意两个节点之间都有一条边，那么对一个节点进行微扰，它可能变成任意一个节点</strong>。即：<br />
<span class="math display">\[
f=(f_1,f_2...f_N)
\]</span><br />
是函数 <span class="math inline">\(f\)</span> 在节点 <span
class="math inline">\(1..N\)</span>
上的函数值，代表<strong>跟节点相关的信息</strong>，如节点属性等，此时可看作每一个节点是一个向量。</p>
<p>假设一个节点 <span class="math inline">\(f_i\)</span>
，其一阶邻域节点集合为 <span class="math inline">\(N_i\)</span> ，<span
class="math inline">\(f_j\)</span>为 <span
class="math inline">\(N_i\)</span> 集合的一个节点，对于任意节点 <span
class="math inline">\(f_i\)</span> ，对 <span
class="math inline">\(f_i\)</span>
节点进行微扰，它可能变为任意一个与他相邻的节点 <span
class="math inline">\(f_j \in
N_i\)</span>。前面提到，拉普拉斯算子就是在所有自由度上进行微小变化后获得的增益。对于
Graph 而言，从节点 <span class="math inline">\(i\)</span> 变化到节点
<span class="math inline">\(j\)</span> 增益是 <span
class="math inline">\(f_i−f_j\)</span>，即节点 <span
class="math inline">\(f_i\)</span> 的 <strong>Graph Laplacian
operater</strong>：<br />
<span class="math display">\[
\Delta f_i =\sum_{j \in N_i} (f_i - f_j)
\]</span><br />
通俗理解，当前节点的 Graph Laplacian operater 就是
<strong>当前节点和所有邻接节点的差值</strong>。</p>
<h2 id="laplacian-matrix">Laplacian Matrix</h2>
<p>把 Graph Laplacian operater
公式变换一下，<strong>考虑权重</strong>：<span
class="math inline">\(w_{ij}=0\)</span> 表示 <span
class="math inline">\(i,j\)</span> 不相邻，<span
class="math inline">\(w_{ij}=1\)</span> 表示 <span
class="math inline">\(i,j\)</span> 相邻，那么上面公式可以转换为：<br />
<span class="math display">\[
\begin{aligned}
\Delta f_i &amp;=\sum_{j \in N} w_{ij}(f_i - f_j)\\
&amp;=\sum_{j \in N} w_{ij}f_i - \sum_{j \in N} w_{ij}f_j\\
&amp;=d_if_i-w_if
\end{aligned}
\]</span><br />
其中：令 <span class="math inline">\(d_i=\sum_{j \in N}w_{ij}\)</span>
，表示节点 <span class="math inline">\(i\)</span> 的度。令 <span
class="math inline">\(w_i=[w_{i1},...,w_{iN}]\)</span> 行。令 <span
class="math inline">\(f=[f_1,...f_N]^T\)</span> 列。<br />
对于所有节点：<br />
<span class="math display">\[
\begin{aligned}
\Delta f&amp;=
\begin{bmatrix}
   d_1f_1-w_1f \\
   d_2f_2-w_2f \\
   \cdots \\
   d_Nf_N-w_Nf
\end{bmatrix}\\
&amp;=
\begin{equation*}
    \begin{bmatrix}
    d_1 &amp;0&amp;\cdots&amp;0 \\
    0&amp;d_2&amp;\cdots&amp;0\\
    \vdots&amp;\vdots&amp; \ddots&amp;\vdots \\
    0&amp;0&amp;\cdots&amp;d_N
    \end{bmatrix}
    \end{equation*}f-\begin{bmatrix}
   w_1\\
   w_2\\
   \cdots \\
   w_N
\end{bmatrix}f\\
&amp;=(D-W)f
\end{aligned}
\]</span></p>
<p><span class="math inline">\(D\)</span>
就是<strong>度矩阵</strong>（dgree matrix），<span
class="math inline">\(W\)</span>
就是<strong>邻接矩阵</strong>（adjacency matrix），<span
class="math inline">\(L=D-W\)</span>
就是<strong>拉普拉斯矩阵</strong>（Laplacian Matrix）。</p>
<p><img src="/images/GCN/LM.png" width="80%"></p>
<p>根据<span class="math inline">\(\Delta f = Lf\)</span>，那么可以看作
<strong>Laplacian operater 等于 Laplacian Matrix</strong> ，即<span
class="math inline">\(\Delta=L\)</span>。这样<strong>求 Graph Laplacian
operater 等价于求 Laplacian Matrix</strong>。</p>
<p>Laplacian Matrix
是<strong>半正定对称矩阵</strong>，因此拥有诸多优秀性质：</p>
<ul>
<li>对称矩阵一定n个线性无关的特征向量</li>
<li>半正定矩阵的特征值一定非负</li>
<li>对阵矩阵的特征向量相互正交，即所有特征向量构成的矩阵为正交矩阵</li>
</ul>
<p>对 Laplacian Matrix 进行特征分解：<br />
<span class="math display">\[
\Delta=L=U\Lambda U^T
\]</span><br />
其中，<span class="math inline">\(U\)</span>的每一列为<span
class="math inline">\(L\)</span>的<strong>特征向量</strong>，<span
class="math inline">\(\Lambda\)</span> 是<span
class="math inline">\(L\)</span>的<strong>特征值矩阵</strong>，<span
class="math inline">\(U^T\)</span>的每一行为<span
class="math inline">\(L\)</span>的<strong>特征向量</strong>。</p>
<h2 id="graph-fourier-transform">Graph Fourier transform</h2>
<p>前面提到，<span class="math inline">\(e^{-j\omega t}\)</span> 是
<span class="math inline">\(\Delta\)</span>
的<strong>特征向量</strong>，而后推导出：<span
class="math inline">\(\Delta=L=U\Lambda U^T\)</span> ，<span
class="math inline">\(U^T\)</span>的每一行为<span
class="math inline">\(L\)</span>的<strong>特征向量</strong><span
class="math inline">\(\phi_w\)</span>，因此我们可得到：</p>
<ul>
<li>频率<span class="math inline">\(w\)</span> <span
class="math inline">\(\to\)</span> 特征值<span
class="math inline">\(\lambda_w\)</span></li>
<li>正弦函数 <span class="math inline">\(e^{-j\omega t}\)</span> <span
class="math inline">\(\to\)</span> 特征向量<span
class="math inline">\(\phi_w\)</span></li>
<li>振幅<span class="math inline">\(F(w)\)</span> <span
class="math inline">\(\to\)</span> 振幅<span
class="math inline">\(F(\lambda_w)\)</span></li>
</ul>
<p>这样就把传统傅里叶变换推广到了图傅里叶变换。推广到矩阵形式：<br />
<span class="math display">\[
\hat{f} = U^Tf
\]</span><br />
逆变换：<br />
<span class="math display">\[
f = U\hat{f}
\]</span></p>
<h2 id="graph-convolution">Graph Convolution</h2>
<p><strong>卷积定理：函数卷积的傅里叶变换是函数傅立叶变换的乘积，即对于函数
<span class="math inline">\(f\)</span> 与 <span
class="math inline">\(g\)</span>
两者的卷积是其函数傅立叶变换乘积的逆变换</strong>。时域上的卷积-&gt;频域上的相乘后逆变换。从而方便计算，可以看作一种Mapping方式，把时域信号转成频域信号处理。<br />
<span class="math display">\[
f*g = \mathcal{F}^{-1}\{\mathcal{F}\{f\} \cdot \mathcal{F}\{g\}\}
\]</span><br />
其中，<span class="math inline">\(f\)</span> 是图信号，<span
class="math inline">\(g\)</span> 是卷积核。通过 Graph Fourier
transform：<br />
<span class="math display">\[
f*g=U(U^Tg\cdot U^Tf)
\]</span><br />
由于对 <span class="math inline">\(g\)</span> 和 <span
class="math inline">\(f\)</span> 进行傅里叶变换的结果为 <span
class="math inline">\(U^Tg\)</span> 和 <span
class="math inline">\(U^Tf\)</span>
都是一个列向量，所以也可以写成：<br />
<span class="math display">\[
f*g=U(U^Tg\odot U^Tf)
\]</span><br />
<span
class="math inline">\(\odot\)</span>表示哈达马积，对于两个向量，就是进行内积运算；对于维度相同的两个矩阵，就是对应元素的乘积运算。</p>
<p>通常把 <span class="math inline">\(U^Tg\)</span>
整体看作可学习的卷积核，这里把它写作 <span
class="math inline">\(g_{\theta}\)</span>（由参数 <span
class="math inline">\(\theta\)</span> 构成的对角矩阵 <span
class="math inline">\(diag(\theta)\)</span>）。最终图上的卷积公式：<br />
<span class="math display">\[
f*g=Ug_{\theta}U^Tf
\]</span><br />
由于参数 <span class="math inline">\(\theta\)</span> 的确定与 <span
class="math inline">\(L\)</span> 的特征值有关，可把 <span
class="math inline">\(g_{\theta}\)</span> 看作是特征值 <span
class="math inline">\(\Lambda\)</span> 的一个函数，那么可把 <span
class="math inline">\(g_{\theta}\)</span> 看成是拉普拉斯矩阵 <span
class="math inline">\(L\)</span>
的一系列特征值组成的对角矩阵的形式，即定义<span
class="math inline">\(g_{\theta}=diag(U^Tg)=g_{\theta}(\Lambda)\)</span>：<br />
<span class="math display">\[
f*g=Ug_{\theta}(\Lambda)U^Tf=U
\begin{equation*}
    \begin{bmatrix}
    \hat{g}(\lambda_1) &amp;   &amp;\\
    &amp; \ddots &amp; \\
    &amp; &amp; \hat{g}(\lambda_N)
    \end{bmatrix}
    \end{equation*}
U^Tf
\]</span></p>
<h2 id="graph-convolution-networks">Graph Convolution Networks</h2>
<p><strong>第一代GCN</strong>（Spectral CNN）：简单的把 <span
class="math inline">\(g_{\theta}\)</span>（由参数 <span
class="math inline">\(\theta\)</span> 构成的对角矩阵 <span
class="math inline">\(diag(\theta)\)</span>）看作是一个可学习参数的集合，其中
<span class="math inline">\(x\)</span> 是节点特征向量：<br />
<span class="math display">\[
f*g=x*g_{\theta}=Ug_{\theta}U^Tx
\]</span><br />
第一代GCN缺点：<br />
（1）计算复杂度高<span
class="math inline">\(O(n^2)\)</span>，每次计算都需要特征分解求U；每一次前向传播，都要计算<span
class="math inline">\(U,g_{\theta},U^T\)</span> 三者的乘积。<br />
（2）没有正则化（no normalization）。<br />
（3）没有考虑自身权重（no self-weight）。</p>
<hr />
<p><strong>第二代GCN</strong>（ChebNet）：定义特征向量对角矩阵的切比雪夫多项式为滤波器：<br />
<span class="math display">\[
g_{\theta&#39;}(\Lambda) \approx
\sum_{k=0}^{K}\theta_{k}^{&#39;}\Lambda^k=\sum_{k=0}^{K}\theta_{k}^{&#39;}T_{k}(\tilde{\Lambda})
\]</span><br />
其中：</p>
<ul>
<li><span
class="math inline">\(\tilde{\Lambda}=\frac{2}{\lambda_{max}}\Lambda-I_N\)</span>，<span
class="math inline">\(\lambda_{max}\)</span>是L的最大特征值。</li>
<li><span class="math inline">\(\theta \in \mathbb{R}^K\)</span>
是切比雪夫系数的向量。</li>
<li>切比雪夫多项式（类似泰勒展开）定义为：<span
class="math inline">\(T_{k}(x)=2xT_{k-1}(x)-T_{k-2}(x)\)</span>，其中
<span class="math inline">\(T_0(x)=1,T_1(x)=x\)</span>。</li>
</ul>
<p>就是利用Chebyshev多项式拟合卷积核的方法，来降低计算复杂度。但首先提出Chebyshev多项式K阶截断展开来拟合，并对
<span class="math inline">\(\Lambda\)</span>
进行归一化使其元素位于[-1,1]之间的是<span class="exturl" data-url="aHR0cHM6Ly9oYWwuaW5yaWEuZnIvaW5yaWEtMDA1NDE4NTUvZG9jdW1lbnQ=">Hammond et al.(2011)
：Wavelets on graphs via spectral graph
theory<i class="fa fa-external-link-alt"></i></span>，二代GCN借鉴了这一方法。</p>
<p>回到 <span class="math inline">\(g_{\theta}\)</span> 和输入 <span
class="math inline">\(x\)</span> 的卷积：<br />
<span class="math display">\[
\begin{aligned}
g_{\theta}*x &amp;= U \sum_{k=0}^{K}\theta_{k}^{&#39;}\Lambda^k U^Tx\\
&amp;=\sum_{k=0}^{K}\theta_{k}^{&#39;}(U \Lambda^kU^T) x\\
&amp;=\sum_{k=0}^{K}\theta_{k}^{&#39;}(U \Lambda U^T)^k x\\
&amp;=\sum_{k=0}^{K}\theta_{k}^{&#39;}L^{k}x
\end{aligned}
\]</span><br />
这里面就用到拉普拉斯矩阵 <span
class="math inline">\(L\)</span>。计算复杂度为 <span
class="math inline">\(O(kn^2)\)</span>。使用切比雪夫展开，其中 <span
class="math inline">\(\tilde{L}=\frac{2}{\lambda_{max}}L-I_N\)</span>：<br />
<span class="math display">\[
g_{\theta^{&#39;}}*x=\sum_{k=0}^{K}\theta_{k}^{&#39;}T_{x}(\tilde{L})x
\]</span></p>
<hr />
<p><strong>第三代GCN</strong>（一阶ChebNet）：只对切比雪夫展开到一阶，即
<span class="math inline">\(K=1,\lambda_{max}=2\)</span>，那么 <span
class="math inline">\(\tilde{L}=L-I_N\)</span>，且 <span
class="math inline">\(T_0(\tilde{L})=1,T_1(\tilde{L})=\tilde{L}\)</span>
，第二代公式可简化为：<br />
<span class="math display">\[
\begin{aligned}
g_{\theta^{&#39;}}*x &amp;=
\theta_0^{&#39;}T_0(\tilde{L})x+\theta_1^{&#39;}T_1(\tilde{L})x\\
&amp;=\theta_0^{&#39;}x+\theta_1^{&#39;}(L-I_N)x\\
\end{aligned}
\]</span><br />
对<span class="math inline">\(L\)</span>做归一化处理：<br />
<span class="math display">\[
\begin{aligned}
\hat{L}&amp;=D^{-\frac{1}{2}}(L)D^{-\frac{1}{2}}\\
&amp;=D^{-\frac{1}{2}}(D-W)D^{-\frac{1}{2}}\\
&amp;=I_N-D^{-\frac{1}{2}}WD^{-\frac{1}{2}}
\end{aligned}
\]</span><br />
代入到前式中得到：<br />
<span class="math display">\[
\theta_0^{\prime}x+\theta_1^{\prime}(L-I_N)x=\theta_0^{&#39;}x+(-\theta_1^{&#39;}(D^{-\frac{1}{2}}WD^{-\frac{1}{2}})x)
\]</span><br />
由于不希望 <span class="math inline">\(\theta_0^{\prime}\)</span> 和
<span class="math inline">\(\theta_1^{\prime}\)</span> 出现，所以假设
<span
class="math inline">\(\theta_0^{\prime}=-\theta_1^{\prime}=\theta\)</span>：<br />
<span class="math display">\[
g_{\theta^{&#39;}}*x=\theta(I_N+D^{-\frac{1}{2}}WD^{-\frac{1}{2}})x
\]</span><br />
注意 <span
class="math inline">\(I_N+D^{-\frac{1}{2}}WD^{-\frac{1}{2}}\)</span>
的特征值被限制在了[0,2]中。由于这一步输出可能作为下一层的输入，会再次与
<span
class="math inline">\(I_N+D^{-\frac{1}{2}}WD^{-\frac{1}{2}}\)</span>
相乘重复这样的操作将会导致数值不稳定、梯度消失/爆炸等问题。</p>
<p>为了解决该问题，引入renormalization（就是加了自环）：令 <span
class="math inline">\(\tilde{W}=W+I_N, \tilde{D}_i=\sum_j
\tilde{W}_{ij}\)</span>：<br />
<span class="math display">\[
I_N+D^{-\frac{1}{2}}WD^{-\frac{1}{2}} \approx
\tilde{D}^{-\frac{1}{2}}\tilde{W}\tilde{D}^{-\frac{1}{2}}
\]</span><br />
那么，带入之前的公式得到：<br />
<span class="math display">\[
\underbrace{\boldsymbol{g}_{\boldsymbol{\theta^{\prime}}} *
\boldsymbol{x}}_{\mathbb{R}^{n \times n}} =
\theta(\underbrace{\tilde{\boldsymbol{D}}^{-1/2}\tilde{\boldsymbol{W}}
\tilde{\boldsymbol{D}}^{-1/2}}_{\mathbb{R}^{n \times n}})
\underbrace{\boldsymbol{x}}_{\mathbb{R}^{n \times 1}}
\]</span><br />
推广到多通道和多卷积，则卷积结果写作矩阵形式如下：<br />
<span class="math display">\[
\underbrace{\boldsymbol{Z}}_{\mathbb{R}^{N \times F}} =
\underbrace{\tilde{\boldsymbol{D}}^{-1/2}\tilde{\boldsymbol{W}}
\tilde{\boldsymbol{D}}^{-1/2}}_{\mathbb{R}^{N \times N}}
\underbrace{\boldsymbol{X}}_{\mathbb{R}^{N \times C}} \ \
\underbrace{\boldsymbol{\Theta}}_{\mathbb{R}^{C \times F}}
\]</span><br />
其中，<span class="math inline">\(N\)</span>
是<strong>节点数量</strong>，<span class="math inline">\(C\)</span>
是通道数或者称作节点的<strong>特征维度</strong>，<span
class="math inline">\(F\)</span> 为<strong>卷积核数量</strong>。<span
class="math inline">\(D\)</span> 就是<strong>度矩阵</strong>，<span
class="math inline">\(W\)</span> 就是<strong>邻接矩阵</strong>，<span
class="math inline">\(X\)</span>
是节点的<strong>特征矩阵</strong>，<span
class="math inline">\(\Theta\)</span>
是<strong>卷积核参数矩阵</strong>，最终得到的卷积结果 <span
class="math inline">\(\boldsymbol{Z} \in \mathbb{R}^{N \times
F}\)</span>，即每个节点的卷积结果的维数等于卷积核数量。上述操作可以叠加多层，对
<span class="math inline">\(Z\)</span> 激活一下，然后将激活后的 <span
class="math inline">\(Z\)</span> 作为下一层的节点的特征矩阵。</p>
<p>第三代GCN特点总结：</p>
<ul>
<li>解决了计算复杂度高的问题：复杂度为<span
class="math inline">\(O(E)\)</span> (稀疏矩阵优化的话)，<span
class="math inline">\(E\)</span> 是图中边的几何。</li>
<li>只考虑1-hop，若要建模多hop，通过叠加层数，获得更大的感受野。（联想NLP中使用卷积操作语句序列时，也是通过叠加多层来达到获取长依赖的目的）。</li>
</ul>
<h1 id="code">Code</h1>
<p>作者给出了源码，分两个版本：</p>
<ul>
<li>tensorflow：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RraXBmL2djbg==">gcn<i class="fa fa-external-link-alt"></i></span></li>
<li>pytorch：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RraXBmL3B5Z2Nu">pygcn<i class="fa fa-external-link-alt"></i></span></li>
<li>数据集地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5xcy1kYXRhLnNvZS51Y3NjLmVkdS9wdWJsaWMvbGJjL2NvcmEudGd6">cora<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>cora数据集有2708个样本，每个样本由1433维特征表示，每个样本是一篇科学论文，每篇论文可能为7个类别，样本和样本之间包括了5429个连接。</p>
<p>模型输入：<br />
<strong>X</strong>：N×D的特征矩阵，N表示节点数量（cora数据集就是2708），D表示输入特征（cora数据集就是1433）。<br />
<strong>A</strong>：邻接矩阵。<br />
模型输出：<br />
<strong>Z</strong>：N×F的特征矩阵，F是每个输出节点的特征维度（这个维度自己设置）。</p>
<p>使用的公式：<br />
<span class="math inline">\(H^{(l+1)}=f(H^{(l)},A),\qquad H^{(0)}=X,
H^{(L)}=Z\)</span><br />
<span class="math inline">\(f(H^{(l)},A)=\sigma(AH^{(l)}W^{(l)}),\qquad
f(H^{(l)},A)=\sigma(\hat{D}^{-\frac{1}{2}}\hat{A}\hat{D}^{-\frac{1}{2}}H^{(l)}W^{(l)})\)</span></p>
<p>其中，<span class="math inline">\(\hat{A}=A+I\)</span>，<span
class="math inline">\(I\)</span>是对角矩阵(自环)，<span
class="math inline">\(\hat{A}\)</span>
是加上自环(节点本身信息)后的邻接矩阵。如果一个节点有非常多的邻居，那么函数<span
class="math inline">\(f\)</span>就会越来越大，所以加上一个归一化<span
class="math inline">\(\hat{D}\)</span>是<span
class="math inline">\(\hat{A}\)</span>的度矩阵，有两种方法<span
class="math inline">\(\hat{D}^{-1}A\)</span>和<span
class="math inline">\(\hat{D}^{-\frac{1}{2}}\hat{A}\hat{D}^{-\frac{1}{2}}\)</span>。</p>
<p>以pytorch版本为例：<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">文件结构：</span><br><span class="line">├── data      // 图数据</span><br><span class="line">├── pygcn</span><br><span class="line">    ├── inits    // 初始化的一些公用函数</span><br><span class="line">    ├── layers     // GCN层的定义</span><br><span class="line">        ├── class GraphConvolution</span><br><span class="line">        ├── reset parameters</span><br><span class="line">        ├── forward</span><br><span class="line">    ├── models     // 模型结构定义</span><br><span class="line">        ├── class GCN</span><br><span class="line">        ├── forward</span><br><span class="line">    ├── train    // 训练</span><br><span class="line">        ├── def train</span><br><span class="line">        ├── def test </span><br><span class="line">    └── utils    //  工具函数的定义</span><br><span class="line">        ├── encode_onehot</span><br><span class="line">        ├── load_data</span><br><span class="line">        ├── normazlize</span><br><span class="line">        ├── accuracy</span><br><span class="line">        ├── sparse mx to torch sparse tensor</span><br><span class="line">├── setup.py //启动函数</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><figcaption><span>model.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> pygcn.layers <span class="keyword">import</span> GraphConvolution</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nfeat, nhid, nclass, dropout</span>):</span><br><span class="line">        <span class="built_in">super</span>(GCN, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.gc1 = GraphConvolution(nfeat, nhid)  <span class="comment"># nfeat：N×D的D</span></span><br><span class="line">        self.gc2 = GraphConvolution(nhid, nclass) <span class="comment"># nclass：类别，这里是7类</span></span><br><span class="line">        self.dropout = dropout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, adj</span>):</span><br><span class="line">        x = F.relu(self.gc1(x, adj)) <span class="comment"># 第一层输出+relu</span></span><br><span class="line">        x = F.dropout(x, self.dropout, training=self.training)</span><br><span class="line">        x = self.gc2(x, adj)  <span class="comment"># 第二层输出</span></span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>) <span class="comment"># 第二层输出+log_softmax</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>layers.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.nn.parameter <span class="keyword">import</span> Parameter</span><br><span class="line"><span class="keyword">from</span> torch.nn.modules.module <span class="keyword">import</span> Module</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphConvolution</span>(<span class="title class_ inherited__">Module</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Simple GCN layer, similar to https://arxiv.org/abs/1609.02907</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_features, out_features, bias=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(GraphConvolution, self).__init__()</span><br><span class="line">        self.in_features = in_features  <span class="comment"># 每层的输入维度</span></span><br><span class="line">        self.out_features = out_features   <span class="comment"># 每层的输出维度</span></span><br><span class="line">        self.weight = Parameter(torch.FloatTensor(in_features, out_features))</span><br><span class="line">        <span class="keyword">if</span> bias:</span><br><span class="line">            self.bias = Parameter(torch.FloatTensor(out_features))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.register_parameter(<span class="string">&#x27;bias&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        self.reset_parameters()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset_parameters</span>(<span class="params">self</span>): <span class="comment"># 参数初始化方法</span></span><br><span class="line">        stdv = <span class="number">1.</span> / math.sqrt(self.weight.size(<span class="number">1</span>))</span><br><span class="line">        self.weight.data.uniform_(-stdv, stdv)</span><br><span class="line">        <span class="keyword">if</span> self.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.bias.data.uniform_(-stdv, stdv)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span>, adj</span>): <span class="comment"># 实现AHW，第一次时H是X</span></span><br><span class="line">        support = torch.mm(<span class="built_in">input</span>, self.weight) <span class="comment"># 实现XW</span></span><br><span class="line">        <span class="comment"># Sparse matrix multiplication, https://github.com/tkipf/pygcn/issues/19</span></span><br><span class="line">        <span class="comment"># output = torch.spmm(adj, support) # spmm后续版本被移除了，使用sparse.mm替代</span></span><br><span class="line">        output = torch.sparse.mm(adj, support) <span class="comment"># 实现AXW</span></span><br><span class="line">        <span class="keyword">if</span> self.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> output + self.bias</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__class__.__name__ + <span class="string">&#x27; (&#x27;</span> \</span><br><span class="line">               + <span class="built_in">str</span>(self.in_features) + <span class="string">&#x27; -&gt; &#x27;</span> \</span><br><span class="line">               + <span class="built_in">str</span>(self.out_features) + <span class="string">&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>util.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> sp</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># focus</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_onehot</span>(<span class="params">labels</span>):</span><br><span class="line">    classes = <span class="built_in">set</span>(labels)</span><br><span class="line">    classes_dict = &#123;c: np.identity(<span class="built_in">len</span>(classes))[i, :] <span class="keyword">for</span> i, c <span class="keyword">in</span></span><br><span class="line">                    <span class="built_in">enumerate</span>(classes)&#125;</span><br><span class="line">    labels_onehot = np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(classes_dict.get, labels)),</span><br><span class="line">                             dtype=np.int32)</span><br><span class="line">    <span class="keyword">return</span> labels_onehot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">path=<span class="string">&quot;../data/cora/&quot;</span>, dataset=<span class="string">&quot;cora&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Load citation network dataset (cora only for now)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loading &#123;&#125; dataset...&#x27;</span>.<span class="built_in">format</span>(dataset))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读进来的数据为：idx，features，labels</span></span><br><span class="line">    idx_features_labels = np.genfromtxt(<span class="string">&quot;&#123;&#125;&#123;&#125;.content&quot;</span>.<span class="built_in">format</span>(path, dataset),</span><br><span class="line">                                        dtype=np.dtype(<span class="built_in">str</span>))</span><br><span class="line">    <span class="comment"># csr_matrix数据存储成稀疏方式，格式为csr</span></span><br><span class="line">    features = sp.csr_matrix(idx_features_labels[:, <span class="number">1</span>:-<span class="number">1</span>], dtype=np.float32)</span><br><span class="line">    labels = encode_onehot(idx_features_labels[:, -<span class="number">1</span>]) <span class="comment"># 使用onehot编码类别 (2708, 7)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># build graph</span></span><br><span class="line">    idx = np.array(idx_features_labels[:, <span class="number">0</span>], dtype=np.int32)</span><br><span class="line">    idx_map = &#123;j: i <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(idx)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读进来的数据为：edges，unordered</span></span><br><span class="line">    <span class="comment"># [[     35,    1033],</span></span><br><span class="line">    <span class="comment">#  [     35,  103482],...]</span></span><br><span class="line">    edges_unordered = np.genfromtxt(<span class="string">&quot;&#123;&#125;&#123;&#125;.cites&quot;</span>.<span class="built_in">format</span>(path, dataset),</span><br><span class="line">                                    dtype=np.int32)</span><br><span class="line">    <span class="comment"># 转成对应map编号</span></span><br><span class="line">    <span class="comment"># [[ 163,  402],</span></span><br><span class="line">    <span class="comment">#  [ 163,  659],...]</span></span><br><span class="line">    edges = np.array(<span class="built_in">list</span>(<span class="built_in">map</span>(idx_map.get, edges_unordered.flatten())),</span><br><span class="line">                     dtype=np.int32).reshape(edges_unordered.shape)</span><br><span class="line">    <span class="comment"># (edges[:, 0], edges[:, 1])坐标点，(np.ones(edges.shape[0])每个坐标位置的值为1</span></span><br><span class="line">    <span class="comment"># 此步得到的是有向图邻接矩阵</span></span><br><span class="line">    adj = sp.coo_matrix((np.ones(edges.shape[<span class="number">0</span>]), (edges[:, <span class="number">0</span>], edges[:, <span class="number">1</span>])),</span><br><span class="line">                        shape=(labels.shape[<span class="number">0</span>], labels.shape[<span class="number">0</span>]),</span><br><span class="line">                        dtype=np.float32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># build symmetric adjacency matrix !</span></span><br><span class="line">    <span class="comment"># 无向图，邻接矩阵是对称的，https://zhuanlan.zhihu.com/p/78191258</span></span><br><span class="line">    <span class="comment"># see https://github.com/tkipf/pygcn/issues/3</span></span><br><span class="line">    adj = adj + adj.T.multiply(adj.T &gt; adj) - adj.multiply(adj.T &gt; adj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># see https://github.com/tkipf/pygcn/issues/47</span></span><br><span class="line">    <span class="comment"># 归一化防止梯度消失</span></span><br><span class="line">    features = normalize(features)</span><br><span class="line">    adj = normalize(adj + sp.eye(adj.shape[<span class="number">0</span>])) <span class="comment"># 加对角矩阵I，即A+I=\hat&#123;A&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 切分数据</span></span><br><span class="line">    idx_train = <span class="built_in">range</span>(<span class="number">140</span>)</span><br><span class="line">    idx_val = <span class="built_in">range</span>(<span class="number">200</span>, <span class="number">500</span>)</span><br><span class="line">    idx_test = <span class="built_in">range</span>(<span class="number">500</span>, <span class="number">1500</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转成Tensor</span></span><br><span class="line">    features = torch.FloatTensor(np.array(features.todense()))</span><br><span class="line">    labels = torch.LongTensor(np.where(labels)[<span class="number">1</span>])</span><br><span class="line">    adj = sparse_mx_to_torch_sparse_tensor(adj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转成Tensor</span></span><br><span class="line">    idx_train = torch.LongTensor(idx_train)</span><br><span class="line">    idx_val = torch.LongTensor(idx_val)</span><br><span class="line">    idx_test = torch.LongTensor(idx_test)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adj, features, labels, idx_train, idx_val, idx_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># focus</span></span><br><span class="line"><span class="comment"># 对特征矩阵features和邻接矩阵adj做标准化，防止梯度消失</span></span><br><span class="line"><span class="comment"># 每个值除以它所在行的和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">normalize</span>(<span class="params">mx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Row-normalize sparse matrix&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># see https://github.com/tkipf/gcn/blob/master/gcn/utils.py#L122</span></span><br><span class="line">    <span class="comment"># 对每行求和得到rowsum</span></span><br><span class="line">    rowsum = np.array(mx.<span class="built_in">sum</span>(<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 求逆得到r_inv</span></span><br><span class="line">    r_inv = np.power(rowsum, -<span class="number">1</span>).flatten()</span><br><span class="line">    <span class="comment"># 如果某一行全为0，则r_inv算出来会等于无穷大，将这些行的r_inv置为0</span></span><br><span class="line">    r_inv[np.isinf(r_inv)] = <span class="number">0.</span></span><br><span class="line">    r_mat_inv = sp.diags(r_inv)</span><br><span class="line">    mx = r_mat_inv.dot(mx)</span><br><span class="line">    <span class="keyword">return</span> mx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">output, labels</span>):</span><br><span class="line">    preds = output.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">1</span>].type_as(labels)</span><br><span class="line">    correct = preds.eq(labels).double()</span><br><span class="line">    correct = correct.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> correct / <span class="built_in">len</span>(labels)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sparse_mx_to_torch_sparse_tensor</span>(<span class="params">sparse_mx</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Convert a scipy sparse matrix to a torch sparse tensor.&quot;&quot;&quot;</span></span><br><span class="line">    sparse_mx = sparse_mx.tocoo().astype(np.float32)</span><br><span class="line">    indices = torch.from_numpy(</span><br><span class="line">        np.vstack((sparse_mx.row, sparse_mx.col)).astype(np.int64))</span><br><span class="line">    values = torch.from_numpy(sparse_mx.data)</span><br><span class="line">    shape = torch.Size(sparse_mx.shape)</span><br><span class="line">    <span class="keyword">return</span> torch.sparse.FloatTensor(indices, values, shape)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><figcaption><span>train.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pygcn.utils <span class="keyword">import</span> load_data, accuracy</span><br><span class="line"><span class="keyword">from</span> pygcn.models <span class="keyword">import</span> GCN</span><br><span class="line"></span><br><span class="line"><span class="comment"># Training settings</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--no-cuda&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;Disables CUDA training.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--fastmode&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, default=<span class="literal">False</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;Validate during training pass.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--seed&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">42</span>, <span class="built_in">help</span>=<span class="string">&#x27;Random seed.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--epochs&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">200</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;Number of epochs to train.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--lr&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.01</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;Initial learning rate.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--weight_decay&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">5e-4</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;Weight decay (L2 loss on parameters).&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--hidden&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">16</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;Number of hidden units.&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--dropout&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">0.5</span>,</span><br><span class="line">                    <span class="built_in">help</span>=<span class="string">&#x27;Dropout rate (1 - keep probability).&#x27;</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">args.cuda = <span class="keyword">not</span> args.no_cuda <span class="keyword">and</span> torch.cuda.is_available()</span><br><span class="line"></span><br><span class="line">np.random.seed(args.seed)</span><br><span class="line">torch.manual_seed(args.seed)</span><br><span class="line"><span class="keyword">if</span> args.cuda:</span><br><span class="line">    torch.cuda.manual_seed(args.seed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load data</span></span><br><span class="line">adj, features, labels, idx_train, idx_val, idx_test = load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Model and optimizer</span></span><br><span class="line">model = GCN(nfeat=features.shape[<span class="number">1</span>],</span><br><span class="line">            nhid=args.hidden,</span><br><span class="line">            nclass=labels.<span class="built_in">max</span>().item() + <span class="number">1</span>,</span><br><span class="line">            dropout=args.dropout)</span><br><span class="line">optimizer = optim.Adam(model.parameters(),</span><br><span class="line">                       lr=args.lr, weight_decay=args.weight_decay)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.cuda:</span><br><span class="line">    model.cuda()</span><br><span class="line">    features = features.cuda()</span><br><span class="line">    adj = adj.cuda()</span><br><span class="line">    labels = labels.cuda()</span><br><span class="line">    idx_train = idx_train.cuda()</span><br><span class="line">    idx_val = idx_val.cuda()</span><br><span class="line">    idx_test = idx_test.cuda()</span><br><span class="line"></span><br><span class="line"><span class="comment"># focus</span></span><br><span class="line"><span class="comment"># 这里训练时给140个带标签，输入的是全部数据特征，整体是个半监督的任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">epoch</span>):</span><br><span class="line">    t = time.time()</span><br><span class="line">    model.train()</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    output = model(features, adj)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># classify each node</span></span><br><span class="line">    <span class="comment"># 只考虑 train ids 计算 loss</span></span><br><span class="line">    <span class="comment"># see https://github.com/tkipf/pygcn/issues/50</span></span><br><span class="line">    <span class="comment"># 如果输出用softmax，这里就用交叉熵损失cross_entropy</span></span><br><span class="line">    <span class="comment"># 这里使用负对数似然损失nll_loss，因为前面输出用的是log_softmax</span></span><br><span class="line">    <span class="comment"># torch.nn.CrossEntropyLoss、cross_entropy都是上面两个函数的组合nll_loss(log_softmax(input))</span></span><br><span class="line">    loss_train = F.nll_loss(output[idx_train], labels[idx_train])</span><br><span class="line">    acc_train = accuracy(output[idx_train], labels[idx_train])</span><br><span class="line">    loss_train.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args.fastmode:</span><br><span class="line">        <span class="comment"># Evaluate validation set performance separately,</span></span><br><span class="line">        <span class="comment"># deactivates dropout during validation run.</span></span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        output = model(features, adj)</span><br><span class="line"></span><br><span class="line">    loss_val = F.nll_loss(output[idx_val], labels[idx_val])</span><br><span class="line">    acc_val = accuracy(output[idx_val], labels[idx_val])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Epoch: &#123;:04d&#125;&#x27;</span>.<span class="built_in">format</span>(epoch+<span class="number">1</span>),</span><br><span class="line">          <span class="string">&#x27;loss_train: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(loss_train.item()),</span><br><span class="line">          <span class="string">&#x27;acc_train: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(acc_train.item()),</span><br><span class="line">          <span class="string">&#x27;loss_val: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(loss_val.item()),</span><br><span class="line">          <span class="string">&#x27;acc_val: &#123;:.4f&#125;&#x27;</span>.<span class="built_in">format</span>(acc_val.item()),</span><br><span class="line">          <span class="string">&#x27;time: &#123;:.4f&#125;s&#x27;</span>.<span class="built_in">format</span>(time.time() - t))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    output = model(features, adj)</span><br><span class="line">    loss_test = F.nll_loss(output[idx_test], labels[idx_test])</span><br><span class="line">    acc_test = accuracy(output[idx_test], labels[idx_test])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test set results:&quot;</span>,</span><br><span class="line">          <span class="string">&quot;loss= &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(loss_test.item()),</span><br><span class="line">          <span class="string">&quot;accuracy= &#123;:.4f&#125;&quot;</span>.<span class="built_in">format</span>(acc_test.item()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Train model</span></span><br><span class="line">t_total = time.time()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(args.epochs):</span><br><span class="line">    train(epoch)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Optimization Finished!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Total time elapsed: &#123;:.4f&#125;s&quot;</span>.<span class="built_in">format</span>(time.time() - t_total))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Testing</span></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<h1 id="参考文献">参考文献</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTlBJThGJUU2JTlDJUJBJUU1JTlCJUJF">随机图<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTk3JUEwJUU1JUIwJUJBJUU1JUJBJUE2JUU3JUJEJTkxJUU3JUJCJTlD">无尺度网络<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGVlengvcC85NDM2ODIwLmh0bWw=">Scale Free
Network<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUJBJUE2JUU1JTg4JTg2JUU1JUI4JTgz">度分布<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTgyJUJCJUU2JThFJUE1JUU3JTlGJUE5JUU5JTk4JUI1">邻接矩阵<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2x1c3RlcmluZ19jb2VmZmljaWVudA==">Clustering
coefficient<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmV0d2Vlbm5lc3M=">Betweenness<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzE5OTY3Nzc4">如何理解希尔伯特空间？<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUI4JThDJUU1JUIwJTk0JUU0JUJDJUFGJUU3JTg5JUI5JUU3JUE5JUJBJUU5JTk3JUI0">希尔伯特空间<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRm91cmllcl90cmFuc2Zvcm0=">Fourier
transform<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTgyJTg1JUU5JTg3JThDJUU1JThGJUI2JUU1JThGJTk4JUU2JThEJUEy">傅里叶变换<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3RraXBmLmdpdGh1Yi5pby9ncmFwaC1jb252b2x1dGlvbmFsLW5ldHdvcmtzLw==">GRAPH
CONVOLUTIONAL NETWORKS<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuc29odS5jb20vYS8zNDI2MzQyOTFfNjUxODkz">跳出公式，看清全局，图神经网络（GCN）原理详解<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5bDQyNDUyNS9hcnRpY2xlL2RldGFpbHMvMTAwMDU4MjY0I0dDTl84Mjg=">图卷积网络
GCN Graph Convolutional Network（谱域GCN）的理解和详细推导<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cDovL3h0ZjYxNS5jb20vMjAxOS8wMi8yNC9nY24v">图卷积神经网络理论基础<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83NjAwMTA4MA==">GNN综述——从入门到入门<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnhmLXJhYmJpdDc1L3AvMTEzMDYxOTguaHRtbA==">GCN总结<i class="fa fa-external-link-alt"></i></span></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2021/02/03/Graph/00.%E5%9B%BE%E6%B7%B1%E5%BA%A6%E8%A1%A8%E7%A4%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/03/Graph/00.%E5%9B%BE%E6%B7%B1%E5%BA%A6%E8%A1%A8%E7%A4%BA/" class="post-title-link" itemprop="url">图深度表示</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-03 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-03T00:00:00+08:00">2021-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Graph/" itemprop="url" rel="index"><span itemprop="name">Graph</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="图结构">图结构</h1>
<p>在现实中，很多情景的构成是不规则的图结构，比如社交网络、金融网络、化学分子结构等等。</p>
<h1 id="什么是图表示学习">什么是图表示学习？</h1>
<p>简单讲就是把图结构映射到向量空间（也叫graph
embedding），或者由向量空间映射到图结构（也叫 graph generate）。</p>
<p>我们为什么这么做呢？或者说将图映射到向量空间的优势是什么？<br />
（1）向量表示相对传统图表示（邻接矩阵、邻接表）对现有机器学习算法更友好。<br />
（2）可以更好的将拓扑信息和节点本身特征结合。</p>
<h1 id="基于图结构的表示学习">基于图结构的表示学习</h1>
<p>图论、数据挖掘角度：如何在学习到向量的表示中保留尽可能多的图拓扑结构的信息。</p>
<p>节点的向量表示只来源于图的拓扑结构（nxn
的邻接矩阵表达的图结构），只是对图结构的单一表示，缺乏对图节点特征消息的表示。下图d远远小于n。</p>
<p><img src="/images/图深度表示/图表示1.png" width="100%"></p>
<h2 id="传统方法">传统方法</h2>
<p>第一个想法就是<strong>降维</strong>（nxn -&gt;
nxd），利用现有的降维方法实现，比如PCA、LDA等等。致命缺点：时间复杂度高；<strong>不能保留图中节点和节点之间的拓扑信息</strong>。</p>
<ul>
<li><p>这里有个问题：什么叫做<strong>保留拓扑信息</strong>？</p></li>
<li><p>目标：<strong>在拓扑域里面‘邻近’&lt;==&gt;
在向量域‘邻近’</strong>。</p></li>
<li><p>问题：<strong>如何建模节点之间的邻近信息？ -&gt;
如何定义'邻近'？</strong></p></li>
<li><p>定义邻近的方法很多：<strong>共同出现、高阶邻近（n-hop邻居）、团体邻近（属于某一个团体）</strong>。</p></li>
</ul>
<p>所以现有算法都是围绕着 <strong>定义‘邻近’</strong> 和
<strong>求解‘邻近’</strong> 这两个点展开。</p>
<h2 id="deepwalk">Deepwalk</h2>
<ul>
<li><strong>动机</strong>：如何动态的建模邻居信息？</li>
<li><strong>1-hop建模</strong>：对于某个节点只看其邻居节点。两个相邻的结点就可以定义为邻近。
<ul>
<li>太局部，忽略了图上的一些全局信息。</li>
</ul></li>
<li><strong>n-hop建模</strong>：对于某个节点考虑其n步邻居节点。两个n阶临近的结点也可以定义为邻近。
<ul>
<li>组合爆炸，复杂度高，且没必要。</li>
</ul></li>
<li>解决方法：
<ul>
<li>考虑有限步的情况，例如只考虑1，2 hop，即 LINE 2015。</li>
<li>使用采样的方式————随机游走（Random Walk）思想的 Deepwalk 2014。</li>
</ul></li>
</ul>
<p><strong>Deepwalk</strong>：<strong>利用随机游走采样生成的序列去定义节点间的邻近关系</strong>。<strong>在足够多的采样情况下，可以很好的刻画节点之间的邻近信息</strong>。<strong>这样就把图信息，转成了序列信息，通过Word2Vec把序列向量化即可（每个点看成词）</strong>。<br />
总结：<br />
（1）使用定长的随机游走去采样图中节点的邻近关系。<br />
（2）节点-&gt;词语，随机游走序列-&gt;句子。<br />
（3）使用自然语言处理相关模型（例如word2vec）对随机游走得到的序列进行表示学习。</p>
<p>基于Random Walk的思路出现了很多 XXX2vec 的论文，基本套路都一样。</p>
<h2 id="node2vec">Node2vec</h2>
<p><strong>动机</strong>：简单的随机游走采样不够好（不能体现出BFS/DFS性质）。<br />
<strong>核心思想</strong>：等概率跳 -&gt; 人工设计概率来跳。</p>
<p>当从结点 t 跳跃到结点 v 之后，算法下一步从结点 v
向邻居结点跳跃的概率是不同的。<br />
<img src="/images/图深度表示/node2vec.png" width="50%"></p>
<p>从结点 v 回跳到上一个结点 t 的 <span
class="math inline">\(\alpha\)</span> 为 <span
class="math inline">\(\frac{1}{p}\)</span>，从结点 v 跳到 t、v
的公共邻居结点的 <span class="math inline">\(\alpha\)</span> 为
1，从结点 v 跳到其他邻居的 <span class="math inline">\(\alpha\)</span>
为 <span class="math inline">\(\frac{1}{q}\)</span>。<br />
<img src="/images/图深度表示/node2vec2.png" width="50%"></p>
<p>我们发现，当 p 比较小的时候，结点间的跳转类似于
BFS，结点间的“接近”就可以理解为结点在<strong>邻接关系</strong>上“接近”；当
q 比较小的时候，结点间的跳转类似于
DFS，节点间的“接近”就可以视作是<strong>结构上相似</strong>。<br />
<img src="/images/图深度表示/node2vec3.png" width="50%"></p>
<h2 id="struc2vec">Struc2vec</h2>
<p><strong>动机</strong>：保留局部结构一致性。<br />
<strong>核心思想</strong>：在原来的图上构建一个新图。</p>
<h2 id="metapath2vec">Metapath2vec</h2>
<p><strong>动机</strong>：异构图上存在不同类型的节点，这些节点不能等同看待，其间关系可能存在一些固定模式。<br />
<strong>核心思路</strong>：使用预定义的Meta-Path来进行Random Walk。</p>
<h1 id="基于图特征的学习图神经网络">基于图特征的学习（图神经网络）</h1>
<p>节点的向量表示既包含了图的拓扑信息（nxn
的邻接矩阵表达的图结构）也包含了节点的特征向量集合（nxf
的特征向量）。<br />
<img src="/images/图深度表示/图表示2.png" width="100%"></p>
<p>机器学习、特征工程角度：如何通过有效利用图拓扑结构信息结合现有的特征向量得到新的特征。<br />
比如：图像-&gt;向量，视频-&gt;向量...。可以不严谨的说<strong>所有深度学习问题都可以归结为表示学习的问题</strong>。<br />
<strong>挑战</strong>：如何利用我们在图片/视频上取得的成功经验来应对图特征的表示学习问题？</p>
<p><strong>卷积神经网络</strong>（Convolutional Neural
Network）：表示学习利器。<br />
从图的角度看图像上的CNN：在欧式空间上的格点图（平移不变性、多尺度结构）。<br />
<strong>目标</strong>：将在欧式空间上的CNN扩展到拓扑空间————<strong>图卷积</strong>。</p>
<h2 id="gcn">GCN</h2>
<p>GCN(Graph Convolutional Networks，图卷积神经网络):</p>
<ul>
<li><strong>输入</strong>：邻接矩阵（节点数×节点数），特征矩阵（节点数×输入特征数）。</li>
<li><strong>输出</strong>：新的特征矩阵（节点数×输出特征数）。</li>
<li>网络层面：多层网络可以叠加。</li>
<li>节点层面：节点<strong>自身特征</strong>和其<strong>邻域特征</strong>的聚合。</li>
</ul>
<p><img src="/images/图深度表示/GCN1.png" width="100%"></p>
<p>公式如下：<br />
<img src="/images/图深度表示/GCN2.png" width="40%"></p>
<p><span
class="math inline">\(\tilde{A}=A+I_N\)</span>：带自环的邻接矩阵。<br />
<span class="math inline">\(\tilde{D}=\sum_j
\tilde{A}_{ij}\)</span>：度矩阵。<br />
<span class="math inline">\(H\)</span>：特征矩阵。<br />
<span class="math inline">\(W\)</span>：模型参数。<br />
<span class="math inline">\(\sigma(.)\)</span>：激活函数。</p>
<p><strong>两层GCN构造&amp;损失函数</strong>：<br />
<img src="/images/图深度表示/GCN3.png" width="50%"><br />
<img src="/images/图深度表示/GCN4.png" width="25%"></p>
<p><strong>GCN的推导思路</strong>：在图的拓扑空间近似在谱空间中的图滤波的操作，减少可学习参数。</p>
<p><strong>从另一个角度理解GCN</strong>：对<strong>邻居节点</strong>特征的<strong>带权重</strong>（<span
class="math inline">\(\tilde{D}^{-\frac{1}{2}}\)</span>）的<strong>聚合</strong>（<span
class="math inline">\(\tilde{A}H^{(l)}\)</span>）。</p>
<h2 id="graphsage">GraphSAGE</h2>
<p>对<strong>聚合</strong>和<strong>邻居节点</strong>进行了扩展定义：<br />
（1）<strong>聚合</strong>：Mean Pooling/Max Pooling/LSTM，etc。<br />
（2）<strong>邻居节点</strong>：Fix-length sample -&gt;
可以用来加速GCN计算。</p>
<p><img src="/images/图深度表示/GraphSAGE.png" width="100%"></p>
<h2 id="gat">GAT</h2>
<p>GAT（GRAPH ATTENTION
NETWORKS，图注意力网络）：对<strong>权重</strong>（<span
class="math inline">\(\tilde{D}^{-\frac{1}{2}}\)</span>）进行了扩展。<br />
（1）GCN中使用的邻接矩阵权重是提前给定的<span
class="math inline">\(\tilde{D}^{-\frac{1}{2}}\)</span>。<br />
（2）图注意力网络引入了<strong>自注意力机制</strong>，利用当前节点的特征以及其邻居节点的特征计算邻居节点的重要性，把该重要性作为新的邻接矩阵进行卷积计算。<br />
（3）有势：利用节点特征的相似性更能反映邻接信息。<br />
<img src="/images/图深度表示/GAT1.png" width="80%"></p>
<p><img src="/images/图深度表示/GAT2.png" width="50%"><br />
<img src="/images/图深度表示/GAT3.png" width="40%"></p>
<h1 id="图学习面临的挑战">图学习面临的挑战</h1>
<h2
id="如何将图神经网络模型做到更大的图上如何做大">如何将图神经网络模型做到更大的图上（如何做大）？</h2>
<p>因为<span
class="math inline">\(\tilde{D}^{-\frac{1}{2}}\tilde{A}\tilde{D}^{-\frac{1}{2}}\)</span>中邻接矩阵用到所有节点，难以处理超大图。即<strong>对所有邻接节点进行聚合并不高效</strong>。</p>
<p><strong>思路</strong>：采样，采用一部分点/边来进行运算。<br />
<strong>FastGCN</strong>：<br />
（1）把图节点特征看作有一个隐含概率分布产生，利用该分布对每一层的所有节点<strong>整体采样</strong>，避免了采样点个数的指数增加。<br />
（2）采样的目标是尽量减少采样的方差-&gt;基于节点degree的采样。<br />
（3）<strong>缺点</strong>：没有考虑层间点和点的关系。</p>
<p>为了克服这个缺点出现了层间采样的方法：<br />
<strong>ASGCN</strong>：FastGCN采样方式并不合理，在图极大而采样比例极少时，层间连接会急剧减少。<br />
（1）自顶向下Layer-dependent的采样方式。<br />
（2）在控制每层采样个数的同时，确保上下两层之间的连接是密集。<br />
（3）通过公式证明了可以保证采样无偏和减小采样方差。<br />
（4）扩展：加入了残差连接，能考虑二阶邻居的信息传播。在采样设置下，实现了注意力机制。</p>
<h2
id="如何有效训练更复杂的图神经网络模型如何做深">如何有效训练更复杂的图神经网络模型（如何做深）？</h2>
<p>为什么不能做深？<br />
（1）过拟合（Overfitting）：参数数量过多造成的泛化性降低。<br />
（2）<strong>过平滑</strong>（Over-Smoothing）：<strong>多层的邻居聚合造成的特征均化</strong>。</p>
<p>Over-Smoothing的定义：经过L层特征聚合后特征收敛到一个和输入特征无关的子空间M的现象。<br />
<img src="/images/图深度表示/Dropedge2.png" width="20%"></p>
<p><strong>挑战</strong>：如何减弱Over-Smoothing？<br />
<strong>DropEdge</strong>：<strong>在每个epoch训练前，随机丢掉一定比例的边</strong>。<br />
<img src="/images/图深度表示/Dropedge.png" width="20%"></p>
<p>为什么DropEdge可以减弱Over-Smoothing？<br />
（1）<strong>DropEdge可以减缓收敛到子空间M的速度</strong>。<img src="/images/图深度表示/Dropedge3.png" width="20%"><br />
（2）<strong>DropEdge可以减少收敛过程中的信息损失</strong>。<img src="/images/图深度表示/Dropedge4.png" width="30%"></p>
<p>由此通过减弱Over-Smoothing的影响，可以使我们可以成功在更复杂更深层的图神经网络上进行训练，并且提升精度。</p>
<h1 id="应用">应用</h1>
<p>药物属性预测和可解释性问题：DualMPNN。所有属性预测数据上大幅超越SOTA算法并提供了模型的可解释性。<br />
复杂层次图学习问题：SEAL算法。基于复杂层次图结构的GNN模型。应用于安全场景中的群分类任务。<br />
社交网络谣言检测：Bi-GCN。首创双向GCN结构并将其应用于谣言检测问题。<br />
统一黑盒攻击框架：GF-Attacker。首个可以对于多种图模型进行黑盒攻击的攻击框架。</p>
<h2 id="seal">SEAL</h2>
<p><strong>背景</strong>：在实际数据中，图相互之间的关系可以建模成图，即层级图结构。比如QQ群和QQ群的关系、学术论文引用（不同领域间的引用构成层次图，领域内的文章引用构成实例图）。<br />
<img src="/images/图深度表示/SEAL.png" width="70%"></p>
<p><strong>问题</strong>：如何预测实例图的分类标签？<br />
<strong>挑战</strong>：<br />
（1）<strong>如何利用统一长度的向量来表示具有不同大小的实例图</strong>？</p>
<ul>
<li>在不同层级下学习图的表示：
<ul>
<li>节点层级：<span class="math inline">\(G(V,E) -&gt;
H^{n×v}\)</span></li>
<li>层图级：<span class="math inline">\(G(V,E) -&gt; \it
e^{v}\)</span></li>
</ul></li>
<li>自注意力图表示学习（Self-Attentive Graph Embedding）
<ul>
<li>图大小不变性————自注意力机制（<span class="math inline">\(\it e \in
R^{r×v}\)</span>）</li>
<li>节点重要性——————自注意力机制</li>
<li>排列不变性——————GCN Smoothing</li>
</ul></li>
</ul>
<p><img src="/images/图深度表示/SEAL2.png" width="80%"></p>
<p>（2）<strong>如何在不同层级去融合实例图和层次图的信息</strong>？</p>
<ul>
<li><strong>实例图层次</strong>（Instance Classifier）：Graph Level
Learning （SEGA）。</li>
<li><strong>层次图层次</strong>（Hierarchical Classifier）：Node Level
Learning（GCN）。</li>
<li><strong>特征共享</strong>：将实例图的输出作为层次图模型的输入。<br />
<img src="/images/图深度表示/SEAL3.png" width="90%"></li>
</ul>
<h1 id="时间线">时间线</h1>
<p><img src="/images/图深度表示/GNN.png" width="50%"></p>
<h1 id="参考文献">参考文献</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlCJUJFXyglRTYlOTUlQjAlRTUlQUQlQTYp">图
(数学)<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTlCJUJFJUU4JUFFJUJB">图论<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU5JTgyJUJCJUU2JThFJUE1JUU3JTlGJUE5JUU5JTk4JUI1">邻接矩阵<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2ODM1MTk3NjU/ZnJvbT1zZWFyY2gmc2VpZD00MjExNDE0NTk3NTQ4MjM5Njc2">图深度表示（GNN）的基础和前沿进展<i class="fa fa-external-link-alt"></i></span><br />
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbnhmLXJhYmJpdDc1L3AvMTEzMDYxOTguaHRtbA==">GCN总结<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE0MDMuNjY1Mi5wZGYlQzMlQUYlQzIlQkMlRTIlODAlQkE=">DeepWalk:
Online Learning of Social Representations<i class="fa fa-external-link-alt"></i></span> DeepWalk 2014年<br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE1MDMuMDM1NzgucGRmJUMyJUEwJUUzJTgwJTkwV1dX">LINE:
Large-scale Information Network Embedding<i class="fa fa-external-link-alt"></i></span> LINE 2015年<br />
<span class="exturl" data-url="aHR0cHM6Ly93d3ctY3MtZmFjdWx0eS5zdGFuZm9yZC5lZHUvcGVvcGxlL2p1cmUvcHVicy9ub2RlMnZlYy1rZGQxNi5wZGY=">node2vec:
Scalable Feature Learning for Networks<i class="fa fa-external-link-alt"></i></span> node2vec 2016年<br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MDQuMDMxNjUucGRm">struc2vec: Learning Node
Representations from Structural Identity<i class="fa fa-external-link-alt"></i></span> struc2vec 2017年<br />
<span class="exturl" data-url="aHR0cHM6Ly9kbC5hY20ub3JnL2RvaS9wZGYvMTAuMTE0NS8zMDk3OTgzLjMwOTgwMzY=">metapath2vec:
Scalable Representation Learning for Heterogeneous Networks<i class="fa fa-external-link-alt"></i></span>
metapath2vec 2017年</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9vcGVucmV2aWV3Lm5ldC9wZGY/aWQ9U0pVNGF5WWds">SEMI-SUPERVISED
CLASSIFICATION WITH GRAPH CONVOLUTIONAL NETWORKS<i class="fa fa-external-link-alt"></i></span> GCN 2017年<br />
<span class="exturl" data-url="aHR0cHM6Ly9wcm9jZWVkaW5ncy5uZXVyaXBzLmNjL3BhcGVyLzIwMTcvZmlsZS81ZGQ5ZGI1ZTAzM2RhOWM2ZmI1YmE4M2M3YTdlYmVhOS1QYXBlci5wZGY=">Inductive
Representation Learning on Large Graphs<i class="fa fa-external-link-alt"></i></span> GraphSAGE 2017年<br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MTAuMTA5MDMucGRm">GRAPH ATTENTION
NETWORKS<i class="fa fa-external-link-alt"></i></span> GAT 2018年</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE4MDEuMTAyNDcucGRm">FASTGCN: FAST LEARNING
WITH GRAPH CONVOLU TIONAL NETWORKS VIA IMPORTANCE SAMPLING<i class="fa fa-external-link-alt"></i></span> FASTGCN
2018年<br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE4MDkuMDUzNDMucGRm">Adaptive Sampling Towards
Fast Graph Representation Learning<i class="fa fa-external-link-alt"></i></span> ASGCN 2018年</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE5MDcuMTA5MDMucGRm">DROPEDGE: TOWARDS DEEP
GRAPH CONVOLU TIONAL NETWORKS ON NODE CLASSIFICATION<i class="fa fa-external-link-alt"></i></span> DROPEDGE
2020年<br />
<span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE5MDQuMDUwMDMucGRm">Semi-Supervised Graph
Classification: A Hierarchical Graph Perspective<i class="fa fa-external-link-alt"></i></span> SEAL 2019年</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2020/10/17/ML/40.cheatsheet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/17/ML/40.cheatsheet/" class="post-title-link" itemprop="url">cheatsheet</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-10-17T00:00:00+08:00">2020-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ML/" itemprop="url" rel="index"><span itemprop="name">ML</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="总结">总结</h1>
<h2 id="math">Math</h2>
<ol type="1">
<li><p>MLE<br />
<span class="math display">\[
\theta_{MLE}=\mathop{argmax}\limits _{\theta}\log
p(X|\theta)\mathop{=}\limits _{iid}\mathop{argmax}\limits
_{\theta}\sum\limits _{i=1}^{N}\log p(x_{i}|\theta)
\]</span></p></li>
<li><p>MAP<br />
<span class="math display">\[
\theta_{MAP}=\mathop{argmax}\limits
_{\theta}p(\theta|X)=\mathop{argmax}\limits _{\theta}p(X|\theta)\cdot
p(\theta)
\]</span></p></li>
<li><p>Gaussian Distribution<br />
<span class="math display">\[
\begin{align}&amp;p(x|\mu,\Sigma)=\frac{1}{(2\pi)^{p/2}|\Sigma|^{1/2}}e^{-\frac{1}{2}(x-\mu)^{T}\Sigma^{-1}(x-\mu)}\\
&amp;\Delta=(x-\mu)^{T}\Sigma^{-1}(x-\mu)=\sum\limits
_{i=1}^{p}(x-\mu)^{T}u_{i}\frac{1}{\lambda_{i}}u_{i}^{T}(x-\mu)=\sum\limits
_{i=1}^{p}\frac{y_{i}^{2}}{\lambda_{i}}
\end{align}
\]</span></p></li>
<li><p>已知 <span class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma),
y\sim Ax+b\)</span>，有：<br />
<span class="math display">\[
\begin{align}y\sim\mathcal{N}(A\mu+b, A\Sigma A^T)
\end{align}
\]</span></p></li>
<li><p>记 <span class="math inline">\(x=(x_1,
x_2,\cdots,x_p)^T=(x_{a,m\times 1},
x_{b,n\times1})^T,\mu=(\mu_{a,m\times1},
\mu_{b,n\times1}),\Sigma=\begin{pmatrix}\Sigma_{aa}&amp;\Sigma_{ab}\\\Sigma_{ba}&amp;\Sigma_{bb}\end{pmatrix}\)</span>，已知
<span
class="math inline">\(x\sim\mathcal{N}(\mu,\Sigma)\)</span>，则：<br />
<span class="math display">\[
\begin{align}&amp;x_a\sim\mathcal{N}(\mu_a,\Sigma_{aa})\\
&amp;x_b|x_a\sim\mathcal{N}(\mu_{b|a},\Sigma_{b|a})\\
&amp;\mu_{b|a}=\Sigma_{ba}\Sigma_{aa}^{-1}(x_a-\mu_a)+\mu_b\\
&amp;\Sigma_{b|a}=\Sigma_{bb}-\Sigma_{ba}\Sigma_{aa}^{-1}\Sigma_{ab}
\end{align}
\]</span></p></li>
</ol>
<h2 id="linear-regression">Linear Regression</h2>
<h3 id="model">Model</h3>
<ol type="1">
<li><p>Dataset:<br />
<span class="math display">\[
\mathcal{D}=\{(x_1, y_1),(x_2, y_2),\cdots,(x_N, y_N)\}
\]</span></p></li>
<li><p>Notation:<br />
<span class="math display">\[
X=(x_1,x_2,\cdots,x_N)^T,Y=(y_1,y_2,\cdots,y_N)^T
\]</span></p></li>
<li><p>Model:<br />
<span class="math display">\[
f(w)=w^Tx
\]</span></p></li>
</ol>
<h3 id="loss-function">Loss Function</h3>
<ol type="1">
<li>最小二乘误差/高斯噪声的MLE<br />
<span class="math display">\[
L(w)=\sum\limits_{i=1}^N||w^Tx_i-y_i||^2_2
\]</span></li>
</ol>
<h3 id="闭式解">闭式解</h3>
<p><span class="math display">\[
\begin{align}\hat{w}=(X^TX)^{-1}X^TY=X^+Y\\
X=U\Sigma V^T\\
X^+=V\Sigma^{-1}U^T
\end{align}
\]</span></p>
<h3 id="正则化">正则化</h3>
<p><span class="math display">\[
\begin{align}
L1-Gaussian \
priori&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||_1,\lambda\gt0\\
L2-Laplasian\
priori-Sparsity&amp;:\mathop{argmin}\limits_wL(w)+\lambda||w||^2_2,\lambda
\gt 0
\end{align}
\]</span></p>
<h2 id="linear-classification">Linear Classification</h2>
<h3 id="hard">Hard</h3>
<h4 id="pca">PCA</h4>
<ol type="1">
<li><p>Idea: 在线性模型上加入激活函数</p></li>
<li><p>Loss Function:</p></li>
</ol>
<p><span class="math display">\[
L(w)=\sum\limits_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i
\]</span></p>
<ol start="3" type="1">
<li>Parameters:</li>
</ol>
<p><span class="math display">\[
w^{t+1}\leftarrow w^{t}+\lambda y_ix_i
\]</span></p>
<h4 id="fisher">Fisher</h4>
<ol type="1">
<li><p>Idea: 投影，类内小，类间大。</p></li>
<li><p>Loss Function:<br />
<span class="math display">\[
\begin{align}&amp;J(w)=\frac{w^TS_bw}{w^TS_ww}\\
&amp;S_b=(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^T\\
&amp;S_w=S_1+S_2
\end{align}
\]</span></p></li>
<li><p>闭式解，投影方向:<br />
<span class="math display">\[
S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})
\]</span></p></li>
</ol>
<h3 id="soft">Soft</h3>
<h4 id="判别模型">判别模型</h4>
<h5 id="logistic-regression">Logistic Regression</h5>
<ol type="1">
<li><p>Idea，激活函数:<br />
<span class="math display">\[
\begin{align}p(C_1|x)&amp;=\frac{1}{1+\exp(-a)}\\
a&amp;=w^Tx
\end{align}
\]</span></p></li>
<li><p>Loss Function(交叉熵):<br />
<span class="math display">\[
\hat{w}=\mathop{argmax}_wJ(w)=\mathop{argmax}_w\sum\limits_{i=1}^N(y_i\log
p_1+(1-y_i)\log p_0)
\]</span></p></li>
<li><p>解法，SGD<br />
<span class="math display">\[
J&#39;(w)=\sum\limits_{i=1}^N(y_i-p_1)x_i
\]</span></p></li>
</ol>
<h4 id="生成模型">生成模型</h4>
<h5 id="gda">GDA</h5>
<ol type="1">
<li><p>Model</p>
<ol type="1">
<li><span class="math inline">\(y\sim Bernoulli(\phi)\)</span></li>
<li><span
class="math inline">\(x|y=1\sim\mathcal{N}(\mu_1,\Sigma)\)</span></li>
<li><span
class="math inline">\(x|y=0\sim\mathcal{N}(\mu_0,\Sigma)\)</span></li>
</ol></li>
<li><p>MAP<br />
<span class="math display">\[
\begin{align}
&amp;\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\log p(X|Y)p(Y)\nonumber\\
&amp;=\mathop{argmax}_{\phi,\mu_0,\mu_1,\Sigma}\sum\limits_{i=1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)+y_i\log
\mathcal{N}(\mu_1,\Sigma)+y_i\log\phi+(1-y_i)\log(1-\phi))
\end{align}
\]</span></p></li>
<li><p>解<br />
<span class="math display">\[
\begin{align}\phi&amp;=\frac{N_1}{N}\\
\mu_1&amp;=\frac{\sum\limits_{i=1}^Ny_ix_i}{N_1}\\
\mu_0&amp;=\frac{\sum\limits_{i=1}^N(1-y_i)x_i}{N_0}\\
\Sigma&amp;=\frac{N_1S_1+N_2S_2}{N}
\end{align}
\]</span></p></li>
</ol>
<h5 id="naive-bayesian">Naive Bayesian</h5>
<ol type="1">
<li><p>Model, 对单个数据点的各个维度作出限制<br />
<span class="math display">\[
x_i\perp x_j|y,\forall\  i\ne j
\]</span></p>
<ol type="1">
<li><span class="math inline">\(x_i\)</span> 为连续变量：<span
class="math inline">\(p(x_i|y)=\mathcal{N}(\mu_i,\sigma_i^2)\)</span></li>
<li><span class="math inline">\(x_i\)</span>
为离散变量：类别分布（Categorical）：<span
class="math inline">\(p(x_i=i|y)=\theta_i,\sum\limits_{i=1}^K\theta_i=1\)</span></li>
<li><span class="math inline">\(p(y)=\phi^y(1-\phi)^{1-y}\)</span></li>
</ol></li>
<li><p>解：和GDA相同</p></li>
</ol>
<h2 id="dimension-reduction">Dimension Reduction</h2>
<p>中心化：<br />
<span class="math display">\[
\begin{align}S
&amp;=\frac{1}{N}X^T(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})(E_N-\frac{1}{N}\mathbb{I}_{N1}\mathbb{I}_{1N})^TX\nonumber\\
&amp;=\frac{1}{N}X^TH^2X=\frac{1}{N}X^THX
\end{align}
\]</span></p>
<h3 id="pca-1">PCA</h3>
<ol type="1">
<li><p>Idea:
坐标变换，寻找线性无关的新基矢，取信息损失最小的前几个维度</p></li>
<li><p>Loss Function:<br />
<span class="math display">\[
\begin{align}J
&amp;=\sum\limits_{j=1}^qu_j^TSu_j\ ,\ s.t.\ u_j^Tu_j=1
\end{align}
\]</span></p></li>
<li><p>解：</p>
<ol type="1">
<li><p>特征分解法<br />
<span class="math display">\[
S=U\Lambda U^T
\]</span></p></li>
<li><p>SVD for X/S<br />
<span class="math display">\[
\begin{align}HX=U\Sigma V^T\\
S=\frac{1}{N}V\Sigma^T\Sigma V^T
\\new\ co=HX\cdot V\end{align}
\]</span></p></li>
<li><p>SVD for T<br />
<span class="math display">\[
\begin{align}T=HXX^TH=U\Sigma\Sigma^TU^T\\
new\ co=U\Sigma
\end{align}
\]</span></p></li>
</ol></li>
</ol>
<h3 id="p-pca">p-PCA</h3>
<ol type="1">
<li><p>Model:<br />
<span class="math display">\[
\begin{align}
z&amp;\sim\mathcal{N}(\mathbb{O}_{q1},\mathbb{I}_{qq})\\
x&amp;=Wz+\mu+\varepsilon\\
\varepsilon&amp;\sim\mathcal{N}(0,\sigma^2\mathbb{I}_{pp})
\end{align}
\]</span></p></li>
<li><p>Learning: E-M</p></li>
<li><p>Inference:<br />
<span class="math display">\[
p(z|x)=\mathcal{N}(W^T(WW^T+\sigma^2\mathbb{I})^{-1}(x-\mu),\mathbb{I}-W^T(WW^T+\sigma^2\mathbb{I})^{-1}W)
\]</span></p></li>
</ol>
<h2 id="svm">SVM</h2>
<ol type="1">
<li>强对偶关系：凸优化+（松弛）Slater 条件-&gt;强对偶。</li>
<li>参数求解：KKT条件
<ol type="1">
<li>可行域</li>
<li>互补松弛+梯度为0</li>
</ol></li>
</ol>
<h3 id="hard-margin">Hard-margin</h3>
<ol type="1">
<li><p>Idea: 最大化间隔</p></li>
<li><p>Model:<br />
<span class="math display">\[
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw\ s.t.\
y_i(w^Tx_i+b)\ge1,i=1,2,\cdots,N
\]</span></p></li>
<li><p>对偶问题<br />
<span class="math display">\[
\max_{\lambda}-\frac{1}{2}\sum\limits_{i=1}^N\sum\limits_{j=1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum\limits_{i=1}^N\lambda_i,\
s.t.\ \lambda_i\ge0
\]</span></p></li>
<li><p>模型参数<br />
<span class="math display">\[
\hat{w}=\sum\limits_{i=1}^N\lambda_iy_ix_i\\
\hat{b}=y_k-w^Tx_k=y_k-\sum\limits_{i=1}^N\lambda_iy_ix_i^Tx_k,\exists
k,1-y_k(w^Tx_k+b)=0
\]</span></p></li>
</ol>
<h3 id="soft-margin">Soft-margin</h3>
<ol type="1">
<li><p>Idea:允许少量错误</p></li>
<li><p>Model:<br />
<span class="math display">\[
error=\sum\limits_{i=1}^N\max\{0,1-y_i(w^Tx_i+b)\}\\
\mathop{argmin}_{w,b}\frac{1}{2}w^Tw+C\sum\limits_{i=1}^N\xi_i\ s.t.\
y_i(w^Tx_i+b)\ge1-\xi_i,\xi_i\ge0,i=1,2,\cdots,N
\]</span></p></li>
</ol>
<h3 id="kernel">Kernel</h3>
<p>对称的正定函数都可以作为正定核。</p>
<h2 id="exp-family">Exp Family</h2>
<ol type="1">
<li><p>表达式<br />
<span class="math display">\[
p(x|\eta)=h(x)\exp(\eta^T\phi(x)-A(\eta))=\frac{1}{\exp(A(\eta))}h(x)\exp(\eta^T\phi(x))
\]</span></p></li>
<li><p>对数配分函数<br />
<span class="math display">\[
\begin{align}
A&#39;(\eta)=\mathbb{E}_{p(x|\eta)}[\phi(x)]\\
A&#39;&#39;(\eta)=Var_{p(x|\eta)}[\phi(x)]
\end{align}
\]</span></p></li>
<li><p>指数族分布满足最大熵定理</p></li>
</ol>
<h2 id="pgm">PGM</h2>
<h3 id="representation">Representation</h3>
<ol type="1">
<li><p>有向图<br />
<span class="math display">\[
p(x_1,x_2,\cdots,x_p)=\prod\limits_{i=1}^pp(x_i|x_{parent(i)})
\]</span><br />
D-separation<br />
<span class="math display">\[
p(x_i|x_{-i})=\frac{p(x)}{\int
p(x)dx_{i}}=\frac{\prod\limits_{j=1}^pp(x_j|x_{parents(j)})}{\int\prod\limits_{j=1}^pp(x_j|x_{parents(j)})dx_i}=\frac{p(x_i|x_{parents(i)})p(x_{child(i)}|x_i)}{\int
p(x_i|x_{parents(i)})p(x_{child(i)}|x_i)dx_i}
\]</span></p></li>
<li><p>无向图<br />
<span class="math display">\[
\begin{align}p(x)=\frac{1}{Z}\prod\limits_{i=1}^{K}\phi(x_{ci})\\
Z=\sum\limits_{x\in\mathcal{X}}\prod\limits_{i=1}^{K}\phi(x_{ci})\\
\phi(x_{ci})=\exp(-E(x_{ci}))
\end{align}
\]</span></p></li>
<li><p>有向转无向</p>
<ol type="1">
<li>将每个节点的父节点两两相连</li>
<li>将有向边替换为无向边</li>
</ol></li>
</ol>
<h3 id="learning">Learning</h3>
<p>参数学习-EM</p>
<ol type="1">
<li><p>目的：解决具有隐变量的混合模型的参数估计（极大似然估计）</p></li>
<li><p>参数：<br />
<span class="math display">\[
\theta_{MLE}=\mathop{argmax}\limits_\theta\log p(x|\theta)
\]</span></p></li>
<li><p>迭代求解：<br />
<span class="math display">\[
\theta^{t+1}=\mathop{argmax}\limits_{\theta}\int_z\log
[p(x,z|\theta)]p(z|x,\theta^t)dz=\mathbb{E}_{z|x,\theta^t}[\log
p(x,z|\theta)]
\]</span></p></li>
<li><p>原理<br />
<span class="math display">\[
\log p(x|\theta^t)\le\log p(x|\theta^{t+1})
\]</span></p></li>
<li><p>广义EM</p>
<ol type="1">
<li><p>E step：<br />
<span class="math display">\[
\hat{q}^{t+1}(z)=\mathop{argmax}_q\int_zq^t(z)\log\frac{p(x,z|\theta)}{q^t(z)}dz,fixed\
\theta
\]</span></p></li>
<li><p>M step：<br />
<span class="math display">\[
\hat{\theta}=\mathop{argmax}_\theta
\int_zq^{t+1}(z)\log\frac{p(x,z|\theta)}{q^{t+1}(z)}dz,fixed\ \hat{q}
\]</span></p></li>
</ol></li>
</ol>
<h3 id="inference">Inference</h3>
<ol type="1">
<li><p>精确推断</p>
<ol type="1">
<li><p>VE</p></li>
<li><p>BP<br />
<span class="math display">\[
m_{j\to i}(i)=\sum\limits_j\phi_j(j)\phi_{ij}(ij)\prod\limits_{k\in
Neighbour(j)-i}m_{k\to j}(j)
\]</span></p></li>
<li><p>MP<br />
<span class="math display">\[
m_{j\to i}=\max\limits_{j}\phi_j\phi_{ij}\prod\limits_{k\in
Neighbour(j)-i}m_{k\to j}
\]</span></p></li>
</ol></li>
<li><p>近似推断</p>
<ol type="1">
<li><p>确定性近似，VI</p>
<ol type="1">
<li><p>变分表达式<br />
<span class="math display">\[
\hat{q}(Z)=\mathop{argmax}_{q(Z)}L(q)
\]</span></p></li>
<li><p>平均场近似下的 VI-坐标上升<br />
<span class="math display">\[
\mathbb{E}_{\prod\limits_{i\ne j}q_i(Z_i)}[\log p(X,Z)]=\log
\hat{p}(X,Z_j)\\
q_j(Z_j)=\hat{p}(X,Z_j)
\]</span></p></li>
<li><p>SGVI-变成优化问题，重参数法<br />
<span class="math display">\[
\begin{aligned}
\mathop{argmax}_{q(Z)}L(q)=\mathop{argmax}_{\phi}L(\phi)\\
\nabla_\phi L(\phi)=\mathbb{E}_{q_\phi}[(\nabla_\phi\log q_\phi)(\log
p_\theta(x^i,z)-\log q_\phi(z))]\\
=\mathbb{E}_{p(\varepsilon)}[\nabla_z[\log p_\theta(x^i,z)-\log
q_\phi(z)]\nabla_\phi g_\phi(\varepsilon,x^i)]\\
z=g_\phi(\varepsilon,x^i),\varepsilon\sim p(\varepsilon)
\end{aligned}
\]</span></p></li>
</ol></li>
<li><p>随机性近似</p>
<ol type="1">
<li><p>蒙特卡洛方法采样</p>
<ol type="1">
<li><p>CDF 采样</p></li>
<li><p>拒绝采样， <span class="math inline">\(q(z)\)</span>，使得 <span
class="math inline">\(\forall z_i,Mq(z_i)\ge
p(z_i)\)</span>，拒绝因子：<span
class="math inline">\(\alpha=\frac{p(z^i)}{Mq(z^i)}\le1\)</span></p></li>
<li><p>重要性采样<br />
<span class="math display">\[
\mathbb{E}_{p(z)}[f(z)]=\int p(z)f(z)dz=\int
\frac{p(z)}{q(z)}f(z)q(z)dz\simeq\frac{1}{N}\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span></p></li>
<li><p>重要性重采样：重要性采样+重采样</p></li>
</ol></li>
<li><p>MCMC：构建马尔可夫链概率序列，使其收敛到平稳分布 <span
class="math inline">\(p(z)\)</span>。</p>
<ol type="1">
<li><p>转移矩阵（提议分布）<br />
<span class="math display">\[
p(z)\cdot Q_{z\to z^*}\alpha(z,z^*)=p(z^*)\cdot Q_{z^*\to
z}\alpha(z^*,z)\\
\alpha(z,z^*)=\min\{1,\frac{p(z^*)Q_{z^*\to z}}{p(z)Q_{z\to z^*}}\}
\]</span></p></li>
<li><p>算法（MH）：</p>
<ol type="1">
<li>通过在0，1之间均匀分布取点 <span
class="math inline">\(u\)</span></li>
<li>生成 <span class="math inline">\(z^*\sim
Q(z^*|z^{i-1})\)</span></li>
<li>计算 <span class="math inline">\(\alpha\)</span> 值</li>
<li>如果 <span class="math inline">\(\alpha\ge u\)</span>，则 <span
class="math inline">\(z^i=z^*\)</span>，否则 <span
class="math inline">\(z^{i}=z^{i-1}\)</span></li>
</ol></li>
</ol></li>
<li><p>Gibbs 采样：给定初始值 <span
class="math inline">\(z_1^0,z_2^0,\cdots\)</span>在 <span
class="math inline">\(t+1\)</span> 时刻，采样 <span
class="math inline">\(z_i^{t+1}\sim
p(z_i|z_{-i})\)</span>，从第一个维度一个个采样。</p></li>
</ol></li>
</ol></li>
</ol>
<h2 id="gmm">GMM</h2>
<ol type="1">
<li><p>Model<br />
<span class="math display">\[
p(x)=\sum\limits_{k=1}^Kp_k\mathcal{N}(x|\mu_k,\Sigma_k)
\]</span></p></li>
<li><p>求解-EM<br />
<span class="math display">\[
\begin{align}Q(\theta,\theta^t)&amp;=\sum\limits_z[\log\prod\limits_{i=1}^Np(x_i,z_i|\theta)]\prod
\limits_{i=1}^Np(z_i|x_i,\theta^t)\nonumber\\
&amp;=\sum\limits_z[\sum\limits_{i=1}^N\log p(x_i,z_i|\theta)]\prod
\limits_{i=1}^Np(z_i|x_i,\theta^t)\nonumber\\
&amp;=\sum\limits_{i=1}^N\sum\limits_{z_i}\log
p(x_i,z_i|\theta)p(z_i|x_i,\theta^t)\nonumber\\
&amp;=\sum\limits_{i=1}^N\sum\limits_{z_i}\log
p_{z_i}\mathcal{N(x_i|\mu_{z_i},\Sigma_{z_i})}\frac{p_{z_i}^t\mathcal{N}(x_i|\mu_{z_i}^t,\Sigma_{z_i}^t)}{\sum\limits_kp_k^t\mathcal{N}(x_i|\mu_k^t,\Sigma_k^t)}
\end{align}
\]</span></p>
<p><span class="math display">\[
p_k^{t+1}=\frac{1}{N}\sum\limits_{i=1}^Np(z_i=k|x_i,\theta^t)
\]</span></p></li>
</ol>
<h2 id="序列模型-hmmldsparticle">序列模型-HMM，LDS，Particle</h2>
<ol type="1">
<li><p>假设：</p>
<ol type="1">
<li><p>齐次 Markov 假设（未来只依赖于当前）：<br />
<span class="math display">\[
p(i_{t+1}|i_t,i_{t-1},\cdots,i_1,o_t,o_{t-1},\cdots,o_1)=p(i_{t+1}|i_t)
\]</span></p></li>
<li><p>观测独立假设：<br />
<span class="math display">\[
p(o_t|i_t,i_{t-1},\cdots,i_1,o_{t-1},\cdots,o_1)=p(o_t|i_t)
\]</span></p></li>
</ol></li>
<li><p>参数<br />
<span class="math display">\[
\lambda=(\pi,A,B)
\]</span></p></li>
</ol>
<h3 id="离散线性隐变量-hmm">离散线性隐变量-HMM</h3>
<ol type="1">
<li><p>Evaluation：<span
class="math inline">\(p(O|\lambda)\)</span>，Forward-Backward 算法<br />
<span class="math display">\[
p(O|\lambda)=\sum\limits_{i=1}^Np(O,i_T=q_i|\lambda)=\sum\limits_{i=1}^N\alpha_T(i)=\sum\limits_{i=1}^Nb_i(o_1)\pi_i\beta_1(i)\\
\alpha_{t+1}(j)=\sum\limits_{i=1}^Nb_{j}(o_t)a_{ij}\alpha_t(i)\\
\beta_t(i)=\sum\limits_{j=1}^Nb_j(o_{t+1})a_{ij}\beta_{t+1}(j)
\]</span></p></li>
<li><p>Learning：<span
class="math inline">\(\lambda=\mathop{argmax}\limits_{\lambda}p(O|\lambda)\)</span>，EM
算法（Baum-Welch）<br />
<span class="math display">\[
\lambda^{t+1}=\mathop{argmax}_\lambda\sum\limits_I\log
p(O,I|\lambda)p(O,I|\lambda^t)\\=\sum\limits_I[\log
\pi_{i_1}+\sum\limits_{t=2}^T\log
a_{i_{t-1},i_t}+\sum\limits_{t=1}^T\log b_{i_t}(o_t)]p(O,I|\lambda^t)
\]</span></p></li>
<li><p>Decoding：<span
class="math inline">\(I=\mathop{argmax}\limits_{I}p(I|O,\lambda)\)</span>，Viterbi
算法-动态规划<br />
<span class="math display">\[
\delta_{t}(j)=\max\limits_{i_1,\cdots,i_{t-1}}p(o_1,\cdots,o_t,i_1,\cdots,i_{t-1},i_t=q_i)\\\delta_{t+1}(j)=\max\limits_{1\le
i\le
N}\delta_t(i)a_{ij}b_j(o_{t+1})\\\psi_{t+1}(j)=\mathop{argmax}\limits_{1\le
i\le N}\delta_t(i)a_{ij}
\]</span></p></li>
</ol>
<h3 id="连续线性隐变量-lds">连续线性隐变量-LDS</h3>
<ol type="1">
<li><p>Model<br />
<span class="math display">\[
\begin{align}
p(z_t|z_{t-1})&amp;\sim\mathcal{N}(A\cdot z_{t-1}+B,Q)\\
p(x_t|z_t)&amp;\sim\mathcal{N}(C\cdot z_t+D,R)\\
z_1&amp;\sim\mathcal{N}(\mu_1,\Sigma_1)
\end{align}
\]</span></p></li>
<li><p>滤波<br />
<span class="math display">\[
p(z_t|x_{1:t})=p(x_{1:t},z_t)/p(x_{1:t})\propto
p(x_{1:t},z_t)\\=p(x_t|z_t)p(z_t|x_{1:t-1})p(x_{1:t-1})\propto
p(x_t|z_t)p(z_t|x_{1:t-1})
\]</span></p></li>
<li><p>递推求解-线性高斯模型</p>
<ol type="1">
<li><p>Prediction<br />
<span class="math display">\[
p(z_t|x_{1:t-1})=\int_{z_{t-1}}p(z_t|z_{t-1})p(z_{t-1}|x_{1:t-1})dz_{t-1}=\int_{z_{t-1}}\mathcal{N}(Az_{t-1}+B,Q)\mathcal{N}(\mu_{t-1},\Sigma_{t-1})dz_{t-1}
\]</span></p></li>
<li><p>Update:<br />
<span class="math display">\[
p(z_t|x_{1:t})\propto p(x_t|z_t)p(z_t|x_{1:t-1}
\]</span></p></li>
</ol></li>
</ol>
<h3 id="连续非线性隐变量-粒子滤波">连续非线性隐变量-粒子滤波</h3>
<p>通过采样(SIR)解决：<br />
<span class="math display">\[
\mathbb{E}[f(z)]=\int_zf(z)p(z)dz=\int_zf(z)\frac{p(z)}{q(z)}q(z)dz=\sum\limits_{i=1}^Nf(z_i)\frac{p(z_i)}{q(z_i)}
\]</span></p>
<ol type="1">
<li><p>采样<br />
<span class="math display">\[
w_t^i\propto\frac{p(x_t|z_t)p(z_t|z_{t-1})}{q(z_t|z_{1:t-1},x_{1:t})}w_{t-1}^i\\
q(z_t|z_{1:t-1},x_{1:t})=p(z_t|z_{t-1})
\]</span></p></li>
<li><p>重采样</p></li>
</ol>
<h2 id="crf">CRF</h2>
<ol type="1">
<li><p>PDF<br />
<span class="math display">\[
p(Y=y|X=x)=\frac{1}{Z(x,\theta)}\exp[\theta^TH(y_t,y_{t-1},x)]
\]</span></p></li>
<li><p>边缘概率<br />
<span class="math display">\[
\begin{aligned}
p(y_t=i|x)=\sum\limits_{y_{1:t-1}}\sum\limits_{y_{t+1:T}}\frac{1}{Z}\prod\limits_{t&#39;=1}^T\phi_{t&#39;}(y_{t&#39;-1},y_{t&#39;},x)\\
p(y_t=i|x)=\frac{1}{Z}\Delta_l\Delta_r\\
\Delta_l=\sum\limits_{y_{1:t-1}}\phi_{1}(y_0,y_1,x)\phi_2(y_1,y_2,x)\cdots\phi_{t-1}(y_{t-2},y_{t-1},x)\phi_t(y_{t-1},y_t=i,x)\\
\Delta_r=\sum\limits_{y_{t+1:T}}\phi_{t+1}(y_t=i,y_{t+1},x)\phi_{t+2}(y_{t+1},y_{t+2},x)\cdots\phi_T(y_{T-1},y_T,x)
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
\alpha_t(i)=\Delta_l=\sum\limits_{j\in
S}\phi_t(y_{t-1}=j,y_t=i,x)\alpha_{t-1}(j)\\
\Delta_r=\beta_t(i)=\sum\limits_{j\in
S}\phi_{t+1}(y_t=i,y_{t+1}=j,x)\beta_{t+1}(j)
\end{aligned}
\]</span></p></li>
<li><p>学习<br />
<span class="math display">\[
\nabla_\lambda
L=\sum\limits_{i=1}^N\sum\limits_{t=1}^T[f(y_{t-1},y_t,x^i)-\sum\limits_{y_{t-1}}\sum\limits_{y_t}p(y_{t-1},y_t|x^i)f(y_{t-1},y_t,x^i)]
\]</span></p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2020/10/16/ML/39.ApproInference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/16/ML/39.ApproInference/" class="post-title-link" itemprop="url">ApproInference</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-16 00:00:00" itemprop="dateCreated datePublished" datetime="2020-10-16T00:00:00+08:00">2020-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ML/" itemprop="url" rel="index"><span itemprop="name">ML</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>367</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="近似推断">近似推断</h1>
<p>这一讲中的近似推断具体描述在深度生成模型中的近似推断。推断的目的有下面几个部分：</p>
<ol type="1">
<li>推断本身，根据结果（观测）得到原因（隐变量）。</li>
<li>为参数的学习提供帮助。</li>
</ol>
<p>但是推断本身是一个困难的额任务，计算复杂度往往很高，对于无向图，由于节点之间的联系过多，那么因子分解很难进行，并且相互之间都有耦合，于是很难求解，仅仅在某些情况如
RBM
中可解，在有向图中，常常由于条件独立性问题，如两个节点之间条件相关（explain
away），于是求解这些节点的条件概率就很困难，仅仅在某些概率假设情况下可解如高斯模型，于是需要近似推断。</p>
<p>事实上，我们常常讲推断问题变为优化问题，即：<br />
<span class="math display">\[
Log-likehood:\sum\limits_{v\in V}\log p(v)
\]</span><br />
对上面这个问题，由于：<br />
<span class="math display">\[
\log
p(v)=\log\frac{p(v,h)}{p(h|v)}=\log\frac{p(v,h)}{q(h|v)}+\log\frac{q(h|v)}{p(h|v)}
\]</span><br />
左右两边对 <span class="math inline">\(h\)</span> 积分：<br />
<span class="math display">\[
\int_h\log p(v)\cdot q(h|v)dh=\log p(v)
\]</span><br />
右边积分有：<br />
<span class="math display">\[
\mathbb{E}_{q(h|v)}[\log\frac{p(v,h)}{q(h|v)}]+KL(q(h|v)||p(h|v))=\mathbb{E}_{q(h|v)}[\log
p(v,h)]+H(q)+KL(q||p)
\]</span><br />
其中前两项是 ELBO，于是这就变成一个优化 ELBO 的问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://soundmemories.github.io/2020/10/15/ML/38.PartitionFunction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avstar.png">
      <meta itemprop="name" content="SoundMemories">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SoundMemories">
      <meta itemprop="description" content="今日事，今日毕">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SoundMemories">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/10/15/ML/38.PartitionFunction/" class="post-title-link" itemprop="url">PartitionFunction</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-10-15T00:00:00+08:00">2020-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ML/" itemprop="url" rel="index"><span itemprop="name">ML</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="配分函数">配分函数</h1>
<p>在学习和推断中，对于一个概率的归一化因子很难处理，这个归一化因子和配分函数相关。假设一个概率分布：<br />
<span class="math display">\[
p(x|\theta)=\frac{1}{Z(\theta)}\hat{p}(x|\theta),Z(\theta)=\int\hat{p}(x|\theta)dx
\]</span></p>
<h2 id="包含配分函数的-mle">包含配分函数的 MLE</h2>
<p>在学习任务中，采用最大似然：<br />
<span class="math display">\[
\begin{align}
\hat{\theta}&amp;=\mathop{argmax}_{\theta}p(x|\theta)=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log
p(x_i|\theta)\nonumber\\
&amp;=\mathop{argmax}_\theta\sum\limits_{i=1}^N\log
\hat{p}(x|\theta)-N\log Z(\theta)\nonumber\\
&amp;=\mathop{argmax}_{\theta}\frac{1}{N}\sum\limits_{i=1}^N\log
\hat{p}(x|\theta)-\log Z(\theta)=\mathop{argmax}_\theta l(\theta)
\end{align}
\]</span><br />
求导：<br />
<span class="math display">\[
\begin{align}\nabla_\theta\log
Z(\theta)&amp;=\frac{1}{Z(\theta)}\nabla_\theta Z(\theta)\nonumber\\
&amp;=\frac{p(x|\theta)}{\hat{p}(x|\theta)}\int\nabla_\theta
\hat{p}(x|\theta)dx\nonumber\\
&amp;=\int\frac{p(x|\theta)}{\hat{p}(x|\theta)}\nabla_\theta\hat{p}(x|\theta)dx\nonumber\\
&amp;=\mathbb{E}_{p(x|\theta)}[\nabla_\theta\log\hat{p}(x|\theta)]
\end{align}
\]</span><br />
由于这个表达式和未知的概率相关，于是无法直接精确求解，需要近似采样，如果没有这一项，那么可以采用梯度下降，但是存在配分函数就无法直接采用梯度下降了。</p>
<p>上面这个期望值，是对模型假设的概率分布，定义真实概率分布为 <span
class="math inline">\(p_{data}\)</span>，于是，<span
class="math inline">\(l(\theta)\)</span>
中的第一项的梯度可以看成是从这个概率分布中采样出来的 <span
class="math inline">\(N\)</span> 个点求和平均，可以近似期望值。<br />
<span class="math display">\[
\nabla_\theta
l(\theta)=\mathbb{E}_{p_{data}}[\nabla_\theta\log\hat{p}(x|\theta)]-\mathbb{E}_{p(x|\theta)}[\nabla_\theta\log\hat{p}(x|\theta)]
\]</span><br />
于是，相当于真实分布和模型假设越接近越好。上面这个式子第一项叫做正相，第二项叫做负相。为了得到负相的值，需要采用各种采样方法，如
MCMC。</p>
<p>采样得到 <span class="math inline">\(\hat{x}_{1-m}\sim
p_{model}(x|\theta^t)\)</span>，那么：<br />
<span class="math display">\[
\theta^{t+1}=\theta^t+\eta(\sum\limits_{i=1}^m\nabla_\theta \log
\hat{p}(x_i|\theta^t)-\sum\limits_{i=1}^m\nabla_\theta\log
\hat{p}(\hat{x_i}|\theta^t))
\]</span><br />
这个算法也叫做基于 MCMC
采样的梯度上升。每次通过采样得到的样本叫做幻想粒子，如果这些幻想粒子区域的概率高于实际分布，那么最大化参数的结果就是降低这些部分的概率。</p>
<h2 id="对比散度-cd-learning">对比散度-CD Learning</h2>
<p>上面对于负相的采样，最大的问题是，采样到达平稳分布的步骤数量是未知的。对比散度的方法，是对上述的采样是的初始值作出限制，直接采样
<span
class="math inline">\(\hat{x}_i=x_i\)</span>，这样可以缩短采样的混合时间。这个算法叫做
CD-k 算法，<span class="math inline">\(k\)</span>
就是初始化后进行的演化时间，很多时候，即使 <span
class="math inline">\(k=1\)</span> 也是可以的。</p>
<p>我们看 MLE 的表达式：<br />
<span class="math display">\[
\begin{align}\hat{\theta}&amp;=\mathop{argmax}_{\theta}p(x|\theta)=\mathop{argmax}_{\theta}\frac{1}{N}\sum\limits_{i=1}^N\log
p(x_i|\theta)=\mathbb{E}_{p_{data}}[\log p_{model}(x|\theta)]\nonumber\\
&amp;=\mathop{argmax}_\theta\int p_{data}\log p_{model}dx\nonumber\\
&amp;=\mathop{argmax}_\theta\int p_{data}\log
\frac{p_{model}}{p_{data}}dx\nonumber\\
&amp;=\mathop{argmin}_\theta KL(p_{data}||p_{model})
\end{align}
\]</span><br />
对于 CD-k 的采样过程，可以将初始值这些点表示为：<br />
<span class="math display">\[
p^0=p_{data}
\]</span><br />
而我们的模型需要采样过程达到平稳分布：<br />
<span class="math display">\[
p^\infty=p_{model}
\]</span><br />
因此，我们需要的是 <span
class="math inline">\(KL(p^0||p^\infty)\)</span>。定义 CD：<br />
<span class="math display">\[
KL(p^0||p^\infty)-KL(p^k||p^\infty)
\]</span><br />
这就是 CD-k 算法第 <span class="math inline">\(k\)</span>
次采样的目标函数。</p>
<h2 id="rbm-的学习问题">RBM 的学习问题</h2>
<p>RBM 的参数为：<br />
<span class="math display">\[
\begin{align}
h=(h_1,\cdots,h_m)^T\\
v=(v_1,\cdots,v_n)^T\\
w=(w_{ij})_{mn}\\
\alpha=(\alpha_1,\cdots,\alpha_n)^T\\
\beta=(\beta_1,\cdots,\beta_m)^T
\end{align}
\]</span><br />
学习问题关注的概率分布为：<br />
<span class="math display">\[
\begin{align}
\log p(v)&amp;=\log\sum\limits_{h}p(h,v)\nonumber\\
&amp;=\log\sum\limits_h\frac{1}{Z}\exp(-E(v,h))\nonumber\\
&amp;=\log\sum\limits_{h}\exp(-E(v,h))-\log\sum\limits_{v,h}\exp(-E(h,v))
\end{align}
\]</span><br />
对上面这个式子求导第一项：<br />
<span class="math display">\[
\frac{\partial
\log\sum\limits_{h}\exp(-E(v,h))}{\partial\theta}=-\frac{\sum\limits_h\exp(-E(v,h))\frac{\partial
E(v,h)}{\partial\theta}}{\sum\limits_{h}\exp(-E(v,h))}\\
=-\sum\limits_h\frac{\exp(-E(v,h))\frac{\partial
E(v,h)}{\partial\theta}}{\sum\limits_{h}\exp(-E(v,h))}=-\sum\limits_hp(h|v)\frac{\partial
E(v,h)}{\partial\theta}
\]</span><br />
第二项：<br />
<span class="math display">\[
\frac{\partial
\log\sum\limits_{v,h}\exp(-E(h,v))}{\partial\theta}=-\sum\limits_{h,v}\frac{\exp(-E(v,h))\frac{\partial
E(v,h)}{\partial\theta}}{\sum\limits_{h,v}\exp(-E(v,h))}=-\sum\limits_{v,h}p(v,h)\frac{\partial
E(v,h)}{\partial\theta}
\]</span><br />
所以有：<br />
<span class="math display">\[
\frac{\partial}{\partial\theta}\log
p(v)=-\sum\limits_hp(h|v)\frac{\partial
E(v,h)}{\partial\theta}+\sum\limits_{v,h}p(v,h)\frac{\partial
E(v,h)}{\partial\theta}
\]</span><br />
将 RBM 的模型假设代入：<br />
<span class="math display">\[
E(v,h)=-(h^Twv+\alpha^Tv+\beta^Th)
\]</span></p>
<ol type="1">
<li><p><span class="math inline">\(w_{ij}\)</span>：<br />
<span class="math display">\[
\frac{\partial}{\partial w_{ij}}E(v,h)=-h_iv_j
\]</span><br />
于是：<br />
<span class="math display">\[
\frac{\partial}{\partial\theta}\log
p(v)=\sum\limits_{h}p(h|v)h_iv_j-\sum\limits_{h,v}p(h,v)h_iv_j
\]</span><br />
第一项：<br />
<span class="math display">\[
\sum\limits_{h_1,h_2,\cdots,h_m}p(h_1,h_2,\cdots,h_m|v)h_iv_j=\sum\limits_{h_i}p(h_i|v)h_iv_j=p(h_i=1|v)v_j
\]</span><br />
这里假设了 <span class="math inline">\(h_i\)</span> 是二元变量。</p>
<p>第二项：<br />
<span class="math display">\[
\sum\limits_{h,v}p(h,v)h_iv_j=\sum\limits_{h,v}p(v)p(h|v)h_iv_j=\sum\limits_vp(v)p(h_i=1|v)v_j
\]</span><br />
这个求和是指数阶的，于是需要采样解决，我么使用 CD-k 方法。</p>
<p>对于第一项，可以直接使用训练样本得到，第二项采用 CD-k
采样方法，首先使用样本 <span
class="math inline">\(v^0=v\)</span>，然后采样得到 <span
class="math inline">\(h^0\)</span>，然后采样得到 <span
class="math inline">\(v^1\)</span>，这样顺次进行，最终得到 <span
class="math inline">\(v^k\)</span>，对于每个样本都得到一个 <span
class="math inline">\(v^k\)</span>，最终采样得到 <span
class="math inline">\(N\)</span> 个 $v^k $，于是第二项就是：<br />
<span class="math display">\[
p(h_i=1|v^k)v_j^k
\]</span><br />
具体的算法为：</p>
<ol type="1">
<li>对每一个样本中的 <span class="math inline">\(v\)</span>，进行采样：
<ol type="1">
<li>使用这个样本初始化采样</li>
<li>进行 <span class="math inline">\(k\)</span> 次采样（0-k-1）：
<ol type="1">
<li><span class="math inline">\(h_i^l\sim p(h_i|v^l)\)</span></li>
<li><span class="math inline">\(v_i^{l+1}\sim p(v_i|h^l)\)</span></li>
</ol></li>
<li>将这些采样出来的结果累加进梯度中</li>
</ol></li>
<li>重复进行上述过程，最终的梯度除以 <span
class="math inline">\(N\)</span></li>
</ol></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SoundMemories</span>
  </div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9tdXNlLw==">NexT.Muse</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js" integrity="sha256-2Pmvv0kuTBOenSvLm6bvfBSSHrUJ+3A7x6P5Ebd07/g=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.8/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.2.12/pdfobject.min.js","integrity":"sha256-g2xji1rlE3KsGVClvuxTbcR0Kn2+wtQADSff2Tbb4zA="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"neutral","dark":"neutral"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.2.3/mermaid.min.js","integrity":"sha256-JFptYy4KzJ5OQP+Q9fubNf3cxpPPmZKqUOovyEONKrQ="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://soundmemories.github.io/page/3/"}</script>
  <script src="/js/third-party/quicklink.js"></script>

</body>
</html>
